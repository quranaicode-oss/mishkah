<!doctype html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mishkah HTMLx — تجربة عملية</title>
    <meta name="description" content="نموذج شامل يستعرض قدرات محرك HTMLx الجديد في مشكاة" />
  </head>
  <body>
    <div id="app"></div>

    <!-- القالب الأول: عدّاد تفاعلي مع سجل وتحكم بالحالات -->
    <template id="counter-demo">
      <style>
        :host {
          display: grid;
          gap: 1.25rem;
          padding: 2.5rem 1.75rem;
          background: radial-gradient(circle at top, rgba(79, 70, 229, 0.08), transparent 65%),
            linear-gradient(180deg, rgba(15, 23, 42, 0.035), transparent 55%);
          border-radius: 2rem;
          box-shadow: 0 35px 120px -60px rgba(15, 23, 42, 0.55);
        }

        header {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 0.35rem;
        }

        h1 {
          font-size: clamp(1.75rem, 2.1vw, 2.4rem);
          font-weight: 700;
          margin: 0;
        }

        .badge {
          display: inline-flex;
          align-items: center;
          gap: 0.4rem;
          padding: 0.25rem 0.75rem;
          border-radius: 999px;
          font-size: 0.85rem;
          background: rgba(99, 102, 241, 0.12);
          color: #312e81;
        }

        .actions {
          display: flex;
          flex-wrap: wrap;
          gap: 0.75rem;
          align-items: center;
        }

        button.primary {
          background: linear-gradient(135deg, #4f46e5, #7c3aed);
          color: white;
          padding: 0.65rem 1.5rem;
          border-radius: 999px;
          border: none;
          font-weight: 600;
          cursor: pointer;
        }

        button.secondary {
          background: white;
          color: #312e81;
          padding: 0.65rem 1.5rem;
          border-radius: 999px;
          border: 1px solid rgba(99, 102, 241, 0.3);
          font-weight: 600;
          cursor: pointer;
        }

        ul.history {
          list-style: none;
          margin: 0;
          padding: 0;
          display: grid;
          gap: 0.75rem;
        }

        ul.history li {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 0.6rem 0.9rem;
          border-radius: 1rem;
          border: 1px solid rgba(148, 163, 184, 0.25);
          background: rgba(248, 250, 252, 0.8);
        }

        ul.history li span.meta {
          font-size: 0.8rem;
          opacity: 0.75;
        }

        @keyframes pulse {
          from {
            transform: scale(1);
          }

          50% {
            transform: scale(1.04);
          }

          to {
            transform: scale(1);
          }
        }

        .is-hot {
          animation: pulse 1.6s ease-in-out infinite;
          border-color: rgba(220, 38, 38, 0.35);
          background: rgba(254, 226, 226, 0.8);
        }
      </style>

      <comp-card class="space-y-6">
        <header>
          <span class="badge">
            <strong>HTMLx</strong>
            <span>المثال الأول</span>
          </span>
          <h1>{state.data.counter.value} مرة</h1>
          <p>{state.data.counter.subtitle}</p>
        </header>

        <div class="actions">
          <button class="primary" onclick="increment(event, ctx)">
            ⬆️ زد العداد
          </button>
          <button class="secondary" onclick="decrement(event, ctx)">
            ⬇️ أنقص العداد
          </button>
          <button class="secondary" onclick="reset(event, ctx)" data-m-once>
            🔄 إعادة الضبط
          </button>
        </div>

        <section>
          <h2 class="text-lg font-semibold mb-2">سجل العمليات</h2>
          <p x-if="!state.data.counter.history.length" class="opacity-70">
            لم تُسجل عمليات بعد.
          </p>
          <ul class="history">
            <li x-for="entry, idx in state.data.counter.history" key="entry.id" class="{ entry.hot ? 'is-hot' : '' }">
              <span>
                <strong>{entry.label}</strong>
                <span class="meta">{entry.time}</span>
              </span>
              <span>{entry.delta > 0 ? '+' + entry.delta : entry.delta}</span>
            </li>
          </ul>
        </section>
      </comp-card>

      <script>
        function pushHistory(ctx, delta) {
          var now = new Date();
          var entry = {
            id: 'h-' + now.getTime(),
            label: delta > 0 ? 'زيادة' : 'نقصان',
            delta: delta,
            time: now.toLocaleTimeString('ar-EG', { hour: '2-digit', minute: '2-digit' }),
            hot: Math.abs(delta) >= 5
          };
          var current = ctx.get('data.counter.history');
          ctx.set('data.counter.history', [entry].concat(current).slice(0, 6));
        }

        function increment(event, ctx) {
          var current = ctx.get('data.counter.value');
          ctx.set('data.counter.value', current + 1);
          pushHistory(ctx, +1);
        }

        function decrement(event, ctx) {
          var current = ctx.get('data.counter.value');
          ctx.set('data.counter.value', current - 1);
          pushHistory(ctx, -1);
        }

        function reset(event, ctx) {
          ctx.set('data.counter.value', 0);
          ctx.set('data.counter.history', []);
        }
      </script>
    </template>

    <!-- القالب الثاني: قائمة مهام متقدمة تستعرض x-if/x-else-if/x-for -->
    <template data-namespace="todos" data-mount="#todos-root">
      <style>
        :host {
          display: block;
          padding: 2rem;
          border-radius: 1.5rem;
          background: white;
          border: 1px solid rgba(226, 232, 240, 0.9);
          box-shadow: 0 25px 70px -45px rgba(15, 23, 42, 0.4);
        }

        form {
          display: flex;
          flex-wrap: wrap;
          gap: 0.75rem;
        }

        input[type="text"] {
          flex: 1 1 240px;
          padding: 0.6rem 1rem;
          border-radius: 0.85rem;
          border: 1px solid rgba(148, 163, 184, 0.45);
          font-size: 1rem;
        }

        .filters {
          display: flex;
          gap: 0.5rem;
          padding-top: 0.75rem;
        }

        .filters button {
          border-radius: 999px;
          padding: 0.4rem 1.1rem;
          border: 1px solid rgba(148, 163, 184, 0.25);
          background: transparent;
          cursor: pointer;
        }

        .filters button.active {
          background: rgba(59, 130, 246, 0.18);
          border-color: rgba(59, 130, 246, 0.35);
          color: #1d4ed8;
          font-weight: 600;
        }

        ul.todo-list {
          list-style: none;
          margin: 1.5rem 0 0;
          padding: 0;
          display: grid;
          gap: 0.65rem;
        }

        ul.todo-list li {
          display: grid;
          grid-template-columns: minmax(0, 1fr) auto;
          gap: 0.65rem;
          padding: 0.9rem 1rem;
          border-radius: 1rem;
          border: 1px solid rgba(226, 232, 240, 0.9);
          align-items: center;
        }

        ul.todo-list li.done {
          background: rgba(187, 247, 208, 0.55);
          border-color: rgba(22, 163, 74, 0.45);
        }
      </style>

      <section>
        <header class="space-y-1">
          <h2 class="text-xl font-semibold">قائمة المهام</h2>
          <p x-if="state.data.todos.items.length === 0" class="opacity-70">
            أضف مهمة جديدة لبدء التجربة ✨
          </p>
          <p x-else-if="state.data.todos.items.length < 3" class="opacity-70">
            ما زال لديك مساحة لإضافة المزيد.
          </p>
          <p x-else class="opacity-70">
            رائع! لديك مجموعة مهام نشطة.
          </p>
        </header>

        <form onsubmit="addTodo(event, ctx)">
          <input type="text" name="title" placeholder="أضف مهمة جديدة" />
          <button type="submit">حفظ</button>
        </form>

        <div class="filters">
          <button class="{ state.data.todos.filter === 'all' ? 'active' : '' }" onclick="setFilter('all', ctx)">
            الجميع
          </button>
          <button class="{ state.data.todos.filter === 'open' ? 'active' : '' }" onclick="setFilter('open', ctx)">
            المفتوحة
          </button>
          <button class="{ state.data.todos.filter === 'done' ? 'active' : '' }" onclick="setFilter('done', ctx)">
            المكتملة
          </button>
        </div>

        <ul class="todo-list">
          <li x-for="todo, idx in state.data.todos.items" key="todo.id" class="{ todo.done ? 'done' : '' }">
            <div>
              <strong>{todo.title}</strong>
              <p class="opacity-70 text-sm">أضيفت في {todo.createdAt}</p>
            </div>
            <div class="flex gap-2">
              <button onclick="toggleTodo(todo.id, ctx)">
                {todo.done ? '↩️ رجوع' : '✅ تم'}
              </button>
              <button onclick="removeTodo(todo.id, ctx)">
                🗑️ حذف
              </button>
            </div>
          </li>
        </ul>
      </section>

      <script>
        function nextId() {
          return 't-' + Math.random().toString(36).slice(2, 9);
        }

        function addTodo(event, ctx) {
          event.preventDefault();
          var form = event.target;
          var title = form.title.value.trim();
          if (!title) return;
          var now = new Date().toLocaleTimeString('ar-EG', { hour: '2-digit', minute: '2-digit' });
          var entry = { id: nextId(), title: title, done: false, createdAt: now };
          var items = ctx.get('data.todos.items');
          ctx.set('data.todos.items', [entry].concat(items));
          form.reset();
        }

        function toggleTodo(id, ctx) {
          var items = ctx.get('data.todos.items');
          var updated = items.map(function (todo) {
            if (todo.id === id) {
              return Object.assign({}, todo, { done: !todo.done });
            }
            return todo;
          });
          ctx.set('data.todos.items', updated);
        }

        function removeTodo(id, ctx) {
          var items = ctx.get('data.todos.items');
          ctx.set('data.todos.items', items.filter(function (todo) { return todo.id !== id; }));
        }

        function setFilter(name, ctx) {
          ctx.set('data.todos.filter', name);
        }
      </script>
    </template>

    <!-- المكتبة الأساسية + نواة مشكاة -->
    <script src="./mishkah-utils.js"></script>
    <script src="./mishkah.core.js"></script>
    <script src="./mishkah-ui.js"></script>
    <!-- ملاحظة: يجب أن يتم تجميع dist/htmlx.bundle.js من وحدة TypeScript الجديدة وإتاحته عالميًا باسم Mishkah.HTMLx -->
    <script src="./dist/htmlx.bundle.js"></script>

    <script>
      (function () {
        var M = window.Mishkah;
        if (!M) {
          console.error('Mishkah core is not available.');
          return;
        }
        if (!M.HTMLx || typeof M.HTMLx.compileAllTemplates !== 'function') {
          console.error('Mishkah HTMLx runtime is missing. تأكد من تحميل dist/htmlx.bundle.js.');
          return;
        }

        var db = {
          head: { title: 'Mishkah HTMLx — تجربة عملية' },
          env: { lang: 'ar', dir: 'rtl', theme: 'light' },
          data: {
            counter: {
              value: 3,
              subtitle: 'نستعرض أوامر الأحداث والتحديث التلقائي للحالة.',
              history: [
                { id: 'h-1', label: 'زيادة', delta: +2, time: '09:15', hot: true },
                { id: 'h-0', label: 'إطلاق', delta: +1, time: '09:10', hot: false }
              ]
            },
            todos: {
              filter: 'all',
              items: [
                { id: 't-1', title: 'مراجعة خطة الإطلاق', done: false, createdAt: '08:30' },
                { id: 't-2', title: 'ضبط تظليل Tailwind', done: true, createdAt: '08:10' }
              ]
            }
          }
        };

        function createExpressionEvaluator() {
          var cache = {};
          return function evaluate(code, scope) {
            if (!cache[code]) {
              cache[code] = new Function(
                'state',
                'ctx',
                'db',
                'M',
                'UI',
                'D',
                'locals',
                'with (locals || Object.create(null)) { return (' + code + '); }'
              );
            }
            try {
              return cache[code](scope.state, scope.ctx, scope.db, scope.M, scope.UI, scope.D, scope.locals);
            } catch (error) {
              console.error('HTMLx expression failed:', code, error);
              return undefined;
            }
          };
        }

        function toArray(value) {
          if (value == null) return [];
          if (Array.isArray(value)) return value;
          if (typeof value === 'string') return value ? [value] : [];
          return [value];
        }

        function extendScope(scope, additions) {
          var nextLocals = Object.assign({}, scope.locals || {}, additions || {});
          return {
            state: scope.state,
            db: scope.db,
            ctx: scope.ctx,
            M: scope.M,
            UI: scope.UI,
            D: scope.D,
            locals: nextLocals
          };
        }

        function normalizeIterable(collection) {
          if (!collection) return [];
          if (Array.isArray(collection)) return collection;
          if (typeof collection === 'number') {
            var length = Math.max(0, collection);
            var range = [];
            for (var i = 0; i < length; i += 1) range.push(i);
            return range;
          }
          if (typeof collection === 'object') return Object.values(collection);
          return [];
        }

        function compactChildren(children) {
          var flat = [];
          for (var i = 0; i < children.length; i += 1) {
            var value = children[i];
            if (value == null || value === false) continue;
            if (Array.isArray(value)) {
              for (var j = 0; j < value.length; j += 1) {
                if (value[j] != null && value[j] !== false) flat.push(value[j]);
              }
            } else {
              flat.push(value);
            }
          }
          return flat;
        }

        function adaptAttrs(raw, key) {
          var attrs = {};
          if (raw) {
            for (var name in raw) {
              var value = raw[name];
              if (value == null || value === false) continue;
              if (name === 'data-m-gkey') {
                attrs.gkey = value;
              } else {
                attrs[name] = value;
              }
            }
          }
          if (key) attrs.key = key;
          return attrs;
        }

        function createRenderer(result) {
          var tree = result.component();
          var evalExpr = createExpressionEvaluator();

          function compileAttrValue(value) {
            if (typeof value === 'string') {
              var literal = value;
              return function (scope) {
                return literal;
              };
            }
            if (Array.isArray(value)) {
              var parts = value.map(function (chunk) {
                if (chunk.type === 'text') {
                  var text = chunk.value;
                  return function () {
                    return text;
                  };
                }
                var code = chunk.code;
                return function (scope) {
                  return evalExpr(code, scope);
                };
              });
              return function (scope) {
                var buffer = '';
                for (var i = 0; i < parts.length; i += 1) {
                  var piece = parts[i](scope);
                  if (piece == null) continue;
                  buffer += piece;
                }
                return buffer;
              };
            }
            return function () {
              return value;
            };
          }

          function compileNode(node) {
            if (node == null) {
              return function () {
                return null;
              };
            }
            if (typeof node === 'string') {
              var str = node;
              return function () {
                return str;
              };
            }
            if (Array.isArray(node)) {
              var list = node.map(compileNode);
              return function (scope) {
                var out = [];
                for (var i = 0; i < list.length; i += 1) {
                  out.push(list[i](scope));
                }
                return compactChildren(out);
              };
            }
            if (node.expr) {
              var exprCode = node.expr;
              return function (scope) {
                var evaluated = evalExpr(exprCode, scope);
                if (evaluated == null) return '';
                return evaluated;
              };
            }
            if (node.kind === 'text') {
              var textValue = node.value;
              return function () {
                return textValue;
              };
            }
            if (node.kind === 'if') {
              var testFn = evalExpr.bind(null, node.test);
              var thenFn = node.consequent ? compileNode(node.consequent) : function () { return null; };
              var elseFn = node.alternate ? compileNode(node.alternate) : function () { return null; };
              return function (scope) {
                return testFn(scope) ? thenFn(scope) : elseFn(scope);
              };
            }
            if (node.kind === 'for') {
              var collectionFn = evalExpr.bind(null, node.collection);
              var bodyFn = compileNode(node.body);
              return function (scope) {
                var collection = normalizeIterable(collectionFn(scope));
                var rendered = [];
                for (var i = 0; i < collection.length; i += 1) {
                  var locals = {};
                  locals[node.item] = collection[i];
                  if (node.index) locals[node.index] = i;
                  rendered.push(bodyFn(extendScope(scope, locals)));
                }
                return compactChildren(rendered);
              };
            }
            if (node.kind === 'element') {
              var attrEntries = [];
              for (var name in node.attrs) {
                attrEntries.push({ name: name, fn: compileAttrValue(node.attrs[name]) });
              }
              var childFns = node.children.map(compileNode);
              var family = node.nodeType === 'atom' && node.atom ? node.atom.family : null;
              var atomName = node.nodeType === 'atom' && node.atom ? node.atom.name : null;
              var componentName = node.nodeType === 'component' ? node.componentRef : null;
              var key = node.key;
              var tagName = node.tagName;

              return function (scope) {
                var computedAttrs = {};
                for (var i = 0; i < attrEntries.length; i += 1) {
                  var entry = attrEntries[i];
                  computedAttrs[entry.name] = entry.fn(scope);
                }
                var children = [];
                for (var j = 0; j < childFns.length; j += 1) {
                  children.push(childFns[j](scope));
                }
                var normalizedChildren = compactChildren(children);
                var attrs = adaptAttrs(computedAttrs, key);

                if (family && atomName) {
                  var category = scope.D && scope.D[family];
                  var atom = category && category[atomName];
                  if (!atom) {
                    console.warn('Missing Mishkah atom for HTMLx element:', family + '.' + atomName);
                    return null;
                  }
                  return atom({ attrs: attrs }, normalizedChildren);
                }

                if (componentName) {
                  var ui = scope.UI || {};
                  var component = ui[componentName];
                  if (typeof component === 'function') {
                    var props = { attrs: attrs, children: normalizedChildren };
                    if (normalizedChildren.length === 1) {
                      props.content = normalizedChildren[0];
                    } else if (normalizedChildren.length > 1) {
                      props.content = normalizedChildren;
                    }
                    return component(props);
                  }
                  var fallback = scope.D && scope.D.Containers && scope.D.Containers.Div;
                  if (fallback) {
                    var fallbackAttrs = Object.assign({ 'data-m-component': componentName, 'data-m-origin-tag': tagName }, attrs);
                    return fallback({ attrs: fallbackAttrs }, normalizedChildren);
                  }
                  return null;
                }

                return null;
              };
            }

            return function () {
              return null;
            };
          }

          var renderNode = compileNode(tree);
          return {
            mount: result.mount,
            render: function (scope) {
              return renderNode(scope);
            }
          };
        }

        function wrapForMount(mount, D, children) {
          if (!children || !children.length) return null;
          if (!mount || mount === '#app') {
            return children.length === 1 ? children[0] : D.Containers.Div({ attrs: { class: 'grid gap-10' } }, children);
          }
          var attrs = {};
          if (mount.charAt(0) === '#') {
            attrs.id = mount.slice(1);
          } else if (mount.charAt(0) === '.') {
            attrs.class = mount.slice(1);
          } else {
            attrs['data-mount'] = mount;
          }
          return D.Containers.Div({ attrs: attrs }, children);
        }

        var compiled = M.HTMLx.compileAllTemplates(document);
        var renderers = compiled.map(createRenderer);

        var aggregatedOrders = {};
        for (var r = 0; r < compiled.length; r += 1) {
          var orderMap = compiled[r].orders || {};
          for (var gkey in orderMap) {
            aggregatedOrders[gkey] = orderMap[gkey];
          }
        }

        var styleAccumulator = db.head && Array.isArray(db.head.styles) ? db.head.styles.slice() : [];
        var styleIds = {};
        for (var s = 0; s < styleAccumulator.length; s += 1) {
          if (styleAccumulator[s] && styleAccumulator[s].id) {
            styleIds[styleAccumulator[s].id] = true;
          }
        }
        for (var c = 0; c < compiled.length; c += 1) {
          var styles = (((compiled[c] || {}).databasePatch || {}).head || {}).styles || [];
          for (var si = 0; si < styles.length; si += 1) {
            var styleEntry = styles[si];
            if (!styleEntry) continue;
            if (styleEntry.id && styleIds[styleEntry.id]) continue;
            if (styleEntry.id) styleIds[styleEntry.id] = true;
            styleAccumulator.push(styleEntry);
          }
        }
        db.head = db.head || {};
        db.head.styles = styleAccumulator;

        M.app.setBody(function (state, D) {
          var scope = { state: state, db: state, ctx: null, M: M, UI: M.UI || {}, D: D, locals: {} };
          var fragments = [];
          for (var i = 0; i < renderers.length; i += 1) {
            var piece = renderers[i].render(scope);
            var children = compactChildren([piece]);
            if (!children.length) continue;
            var wrapped = wrapForMount(renderers[i].mount, D, children);
            if (wrapped == null) continue;
            fragments.push(wrapped);
          }
          if (!fragments.length) {
            return D.Containers.Div({ attrs: { class: 'p-6 text-center text-slate-500' } }, ['HTMLx template لم تُنتج محتوى.']);
          }
          if (fragments.length === 1) return fragments[0];
          return D.Containers.Div({ attrs: { class: 'grid gap-10' } }, fragments);
        });

        var app = M.app.createApp(db, aggregatedOrders);
        var twx = M.utils && M.utils.twcss ? M.utils.twcss.auto(db, app) : { orders: {} };
        app.setOrders(Object.assign({}, aggregatedOrders, twx.orders || {}));
        app.mount('#app');
      })();
    </script>
  </body>
</html>
