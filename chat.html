<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>مشكاة — تجربة دردشة HTMLx</title>
    <script src="./mishkah-utils.js"></script>
    <script src="./mishkah.core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/acorn@8.15.0/dist/acorn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/acorn-walk@8.3.4/dist/walk.min.js"></script>
    <script>
      window.acornWalk = window.acornWalk || (window.acorn && window.acorn.walk);
    </script>
    <script src="./mishkah-htmlx.js"></script>
    <script src="./mishkah-ui.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Tajawal", "Cairo", system-ui;
        background: radial-gradient(circle at top, rgba(37, 99, 235, 0.12), transparent 65%),
          linear-gradient(180deg, rgba(30, 64, 175, 0.35), rgba(15, 23, 42, 0.92));
      }
    </style>
  </head>
  <body class="bg-slate-950 text-slate-100">
    <div id="app"></div>

    <template id="chat-app" data-namespace="chat.app">
      <script type="application/json" data-m-env>
        {
          "lang": "ar",
          "dir": "rtl",
          "theme": "dark",
          "twcss": { "auto": true }
        }
      </script>

      <script type="application/json" data-m-data data-m-path="head">
        {
          "title": "مشكاة — تجربة دردشة HTMLx"
        }
      </script>

      <script type="application/json" data-m-data data-m-path="data">
        {
          "joined": false,
          "username": "",
          "roomPin": "",
          "selectedRoom": "demo:lobby",
          "rooms": [],
          "pinError": "",
          "lockExpiresAt": null,
          "users": [],
          "messages": [],
          "newMessage": "",
          "conversationId": "demo:lobby",
          "topic": "chat:demo:lobby",
          "messageKeyId": "chat:demo:plaintext",
          "connection": {
            "status": "idle",
            "lastError": null,
            "user": null
          },
          "errors": [],
          "loadingState": "idle",
          "loadingMessage": "",
          "historyLoaded": false
        }
      </script>

      <section
        id="chat-shell"
        data-chat-root
        class="container mx-auto flex h-screen flex-col gap-6 px-4 py-6 lg:flex-row"
      >
        <div class="mx-auto w-full max-w-sm" x-if="!state.data.joined">
          <div class="rounded-2xl bg-slate-900/80 p-6 shadow-xl ring-1 ring-slate-800/50">
            <h1 class="mb-4 text-2xl font-bold text-slate-50">انضم إلى الدردشة</h1>
            <p class="mb-6 text-sm text-slate-400">
              اختر اسمًا مستعارًا للانضمام إلى قناة العرض التجريبية.
            </p>
            <div class="flex flex-col gap-4">
              <label class="text-sm text-slate-300">
                <span class="mb-2 inline-block text-xs text-slate-500">غرفة الدردشة</span>
                <select
                  class="w-full rounded-xl border border-slate-800 bg-slate-900/60 p-3 text-base text-slate-100 focus:border-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-500/40"
                  value="{state.data.selectedRoom}"
                  onchange="handleRoomSelect(event, ctx)"
                >
                  <option value="" x-if="!state.data.rooms.length">اختر غرفة</option>
                  <option
                    x-for="room, ridx in state.data.rooms"
                    data-m-key="{room.id || ridx}"
                    value="{room.id}"
                    selected="{room.id === state.data.selectedRoom ? 'selected' : ''}"
                  >
                    {room.name || room.id}
                  </option>
                </select>
              </label>
              <label class="text-sm text-slate-300">
                <span class="mb-2 inline-block text-xs text-slate-500">الاسم المستعار</span>
                <input
                  type="text"
                  class="w-full rounded-xl border border-slate-800 bg-slate-900/60 p-3 text-base focus:border-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-500/40"
                  placeholder="اكتب اسمك المستعار"
                  value="{state.data.username}"
                  oninput="handleUsernameInput(event, ctx)"
                />
              </label>
              <label class="text-sm text-slate-300">
                <span class="mb-2 inline-block text-xs text-slate-500">رمز PIN للغرفة</span>
                <input
                  type="password"
                  class="w-full rounded-xl border border-slate-800 bg-slate-900/60 p-3 text-base focus:border-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-500/40"
                  placeholder="أدخل رمز PIN للغرفة"
                  value="{state.data.roomPin}"
                  oninput="handlePinInput(event, ctx)"
                />
              </label>
              <p x-if="state.data.pinError" class="rounded-lg border border-rose-900/50 bg-rose-900/10 p-3 text-xs text-rose-200">
                {state.data.pinError}
              </p>
              <p x-if="state.data.lockExpiresAt" class="rounded-lg border border-amber-700/40 bg-amber-900/20 p-3 text-xs text-amber-200">
                تم حظر المحاولة مؤقتًا حتى {formatLockTime(state.data.lockExpiresAt, ctx)}.
              </p>
              <button
                type="button"
                class="rounded-xl bg-sky-600 p-3 text-center text-base font-semibold text-white shadow-lg shadow-sky-900/40 transition hover:bg-sky-500"
                onclick="joinChat(event, ctx)"
              >
                دخول الغرفة
              </button>
            </div>
          </div>
        </div>

        <div x-if="state.data.joined" class="flex h-full w-full flex-1 flex-col gap-4 lg:flex-row">
          <aside class="flex w-full flex-col gap-4 overflow-hidden rounded-2xl bg-slate-900/80 p-5 ring-1 ring-slate-800/60 lg:w-80">
            <header class="space-y-1">
              <h2 class="text-lg font-semibold text-slate-50">المحادثة الحالية</h2>
              <p class="text-xs text-slate-400">الموضوع: {state.data.topic}</p>
              <div class="text-xs text-slate-300">
                حالة الاتصال:
                <strong class="{connectionClass(state.data.connection)}">{state.data.connection.status}</strong>
              </div>
              <p x-if="state.data.connection.lastError" class="text-xs text-rose-300">
                آخر خطأ: {state.data.connection.lastError.message || state.data.connection.lastError.code}
              </p>
            </header>

            <section class="flex-1 overflow-y-auto">
              <h3 class="mb-2 text-sm font-semibold text-slate-200">المتصلون الآن</h3>
              <ul class="space-y-2 text-sm">
                <li
                  x-for="user, idx in state.data.users"
                  data-m-key="{user.id || idx}"
                  class="rounded-lg border border-slate-800/60 bg-slate-900/60 p-2 text-slate-200"
                >
                  {user.name || user}
                </li>
                <li
                  x-if="!state.data.users.length && state.data.loadingState !== 'ready'"
                  class="rounded-lg border border-slate-800/60 bg-slate-900/40 p-3 text-xs text-slate-400"
                >
                  جارٍ تحميل قائمة المتصلين...
                </li>
                <li x-if="!state.data.users.length && state.data.loadingState === 'ready'" class="rounded-lg border border-slate-800/60 bg-slate-900/40 p-3 text-xs text-slate-500">
                  لا توجد أسماء بعد — سيظهر المشاركون بعد إرسال الرسائل.
                </li>
              </ul>
            </section>

            <footer class="space-y-2 text-xs text-slate-400">
              <p>
                المستخدم الحالي:
                <strong class="text-slate-200">{state.data.connection.user ? state.data.connection.user.name : state.data.username || 'ضيف'}</strong>
              </p>
              <p x-if="state.data.connection.status !== 'connected'" class="text-slate-500">
                يجري الحفاظ على الاتصال تلقائيًا مع الخادم.
              </p>
              <button
                type="button"
                class="w-full rounded-xl border border-slate-800/60 bg-slate-900/40 px-4 py-2 text-xs font-semibold text-slate-200 transition hover:border-slate-700 hover:bg-slate-900/60"
                onclick="leaveChat(ctx)"
              >
                تسجيل الخروج من الغرفة
              </button>
            </footer>
          </aside>

          <main class="flex h-full flex-1 flex-col gap-4 overflow-hidden">
            <section class="relative flex-1 overflow-hidden rounded-2xl bg-slate-900/80 p-5 ring-1 ring-slate-800/60">
              <div
                x-if="state.data.joined && state.data.loadingState !== 'ready'"
                class="absolute inset-0 z-10 flex flex-col items-center justify-center gap-3 rounded-2xl bg-slate-950/80 backdrop-blur"
              >
                <div class="h-12 w-12 animate-spin rounded-full border-2 border-slate-800/60 border-t-sky-400"></div>
                <p class="px-6 text-center text-sm text-slate-300">{loadingHint(state)}</p>
                <button
                  x-if="state.data.loadingState === 'error'"
                  type="button"
                  class="rounded-lg border border-rose-500/50 bg-rose-900/50 px-4 py-2 text-xs font-semibold text-rose-100 transition hover:bg-rose-900/70"
                  onclick="retryChatConnection(ctx)"
                >
                  إعادة المحاولة
                </button>
              </div>
              <div class="mb-4 flex items-center justify-between text-xs text-slate-400">
                <span>القناة: {state.data.topic}</span>
                <span>{latestMessageTimestamp(state, ctx)}</span>
              </div>
              <div class="flex h-full flex-col gap-3 overflow-y-auto pr-1" data-chat-messages>
                <article
                  x-for="msg, msgIdx in state.data.messages"
                  data-m-key="{msg.clientMessageId || msg.id || msgIdx}"
                  class="rounded-xl border border-slate-800/60 bg-slate-900/60 p-3"
                >
                  <header class="mb-1 flex items-start justify-between gap-2 text-xs text-slate-400">
                    <strong class="text-sm font-semibold text-sky-300">{msg.user || 'مجهول'}</strong>
                    <span>{formatChatTime(msg.createdAt, false, ctx)}</span>
                  </header>
                  <p class="text-sm leading-relaxed text-slate-100">{msg.text}</p>
                  <p x-if="msg.pending" class="mt-2 text-xs text-amber-300">جاري الإرسال...</p>
                  <p x-if="msg.failed" class="mt-2 text-xs text-rose-400">تعذر تسليم الرسالة.</p>
                </article>
                <p x-if="!state.data.messages.length && state.data.loadingState === 'ready'" class="rounded-xl border border-slate-800/60 bg-slate-900/40 p-4 text-sm text-slate-500">
                  لا توجد رسائل حتى الآن. كن أول من يبدأ الحديث!
                </p>
              </div>
            </section>

            <form class="flex flex-col gap-3 rounded-2xl bg-slate-900/80 p-4 ring-1 ring-slate-800/60 lg:flex-row" onsubmit="sendMessage(event, ctx)">
              <label class="flex-1">
                <span class="mb-2 inline-block text-xs text-slate-500">نص الرسالة</span>
                <input
                  type="text"
                  class="w-full rounded-xl border border-slate-800/60 bg-slate-900/60 p-3 text-base text-slate-100 placeholder:text-slate-500 focus:border-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-500/40"
                  placeholder="اكتب رسالتك..."
                  value="{state.data.newMessage}"
                  oninput="handleMessageInput(event, ctx)"
                  data-chat-draft
                />
              </label>
              <div class="flex items-end justify-end gap-3">
                <button
                  type="button"
                  class="rounded-xl border border-rose-700/50 bg-rose-900/40 px-4 py-3 text-sm font-semibold text-rose-100 transition hover:border-rose-600/60 hover:bg-rose-900/60"
                  onclick="clearChatHistory(ctx)"
                >
                  مسح المحادثة
                </button>
                <button
                  type="button"
                  class="rounded-xl border border-slate-800/60 bg-slate-900/40 px-4 py-3 text-sm font-semibold text-slate-200 transition hover:border-slate-700"
                  onclick="generateGuestAlias(ctx)"
                >
                  اسم ضيف جديد
                </button>
                <button
                  type="submit"
                  class="rounded-xl bg-emerald-600 px-6 py-3 text-base font-semibold text-white shadow-lg shadow-emerald-900/40 transition hover:bg-emerald-500"
                >
                  إرسال
                </button>
              </div>
            </form>

            <section x-if="state.data.errors.length" class="rounded-2xl bg-rose-950/40 p-4 ring-1 ring-rose-900/30">
              <h3 class="mb-3 text-sm font-semibold text-rose-200">الأخطاء الأخيرة</h3>
              <ul class="space-y-3 text-sm">
                <li
                  x-for="err, idx in state.data.errors"
                  data-m-key="{err.id || idx}"
                  class="rounded-xl border border-rose-900/40 bg-rose-900/10 p-3"
                >
                  <div class="flex items-center justify-between text-xs text-rose-200">
                    <strong>{err.code}</strong>
                    <span>{formatChatTime(err.ts, true, ctx)}</span>
                  </div>
                  <p class="mt-1 text-sm text-rose-100">{err.message}</p>
                  <ul x-if="err.details && err.details.length" class="mt-2 list-disc space-y-1 pl-4 text-xs text-rose-200">
                    <li
                      x-for="detail, detailIdx in err.details"
                      data-m-key="{detailIdx + '-' + (detail || 'detail')}"
                    >
                      {detail}
                    </li>
                  </ul>
                </li>
              </ul>
            </section>
          </main>
        </div>

        <script data-for="chat-shell">
          function createRuntime() {
            return {
              app: null,
              socket: null,
              lastCtx: null,
              subscriptionRequested: false,
              historyRequested: false,
              authToken: null,
              authTokenMeta: null,
              authenticated: false,
              authenticating: false,
              authPromise: null,
              session: null,
              sessionRestored: false,
              cookieKeyPromise: null,
              roomsLoading: false,
              config: {
                url: 'wss://ws.mas.com.eg',
                conversationId: 'demo:lobby',
                topic: 'chat:demo:lobby',
                historyLimit: 50,
                maxErrors: 10,
                tokenEndpoint: null,
                roomsEndpoint: null,
                keyId: 'chat:demo:plaintext'
              }
            };
          }

          function runtime() {
            if (!runtime.__instance) {
              runtime.__instance = createRuntime();
            }
            return runtime.__instance;
          }

          function host() {
            return (typeof window !== 'undefined' && window.Mishkah) ? window.Mishkah : null;
          }

          function htmlxAgent() {
            var M = host();
            return M && M.HTMLx ? M.HTMLx.Agent : null;
          }

          function utilsHost() {
            var M = host();
            return (M && M.utils) ? M.utils : {};
          }

          var SESSION_PREF_KEY = 'mk.chat.preferences.v1';
          var COOKIE_NAME = 'mk_chat_token';
          var COOKIE_KEY_STORAGE = 'mk.chat.cookie-key.v1';
          var textEncoder = (typeof TextEncoder !== 'undefined') ? new TextEncoder() : null;
          var textDecoder = (typeof TextDecoder !== 'undefined') ? new TextDecoder() : null;
          var pendingScrollFrame = null;

          function storageHost() {
            try {
              if (typeof window !== 'undefined' && window.localStorage) {
                return window.localStorage;
              }
            } catch (_err) {}
            return null;
          }

          function loadPreferences() {
            var store = storageHost();
            if (!store) { return {}; }
            try {
              var raw = store.getItem(SESSION_PREF_KEY);
              if (!raw) { return {}; }
              var parsed = JSON.parse(raw);
              return (parsed && typeof parsed === 'object') ? parsed : {};
            } catch (_err) {
              return {};
            }
          }

          function savePreferences(prefs) {
            var store = storageHost();
            if (!store) { return; }
            try {
              store.setItem(SESSION_PREF_KEY, JSON.stringify(prefs || {}));
            } catch (_err) {}
          }

          function clearPreferences() {
            var store = storageHost();
            if (!store) { return; }
            try { store.removeItem(SESSION_PREF_KEY); } catch (_err) {}
          }

          function cryptoAvailable() {
            return typeof window !== 'undefined' && window.crypto && window.crypto.subtle && typeof window.crypto.subtle.importKey === 'function';
          }

          function bytesToBase64(bytes) {
            if (!bytes) { return ''; }
            var arr = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
            var chars = new Array(arr.length);
            for (var i = 0; i < arr.length; i++) {
              chars[i] = String.fromCharCode(arr[i]);
            }
            return btoa(chars.join(''));
          }

          function base64ToBytes(str) {
            if (!str) { return new Uint8Array(0); }
            try {
              var bin = atob(str);
              var out = new Uint8Array(bin.length);
              for (var i = 0; i < bin.length; i++) {
                out[i] = bin.charCodeAt(i);
              }
              return out;
            } catch (_err) {
              return new Uint8Array(0);
            }
          }

          async function ensureCookieCryptoKey() {
            var store = runtime();
            if (store.cookieKeyPromise) {
              return store.cookieKeyPromise;
            }
            if (!cryptoAvailable()) {
              store.cookieKeyPromise = Promise.resolve(null);
              return store.cookieKeyPromise;
            }
            var local = storageHost();
            var existing = null;
            if (local) {
              try { existing = local.getItem(COOKIE_KEY_STORAGE); } catch (_err) { existing = null; }
            }
            var promise = (async function () {
              var material = existing ? base64ToBytes(existing) : null;
              if (!material || !material.length) {
                material = new Uint8Array(32);
                window.crypto.getRandomValues(material);
                if (local) {
                  try { local.setItem(COOKIE_KEY_STORAGE, bytesToBase64(material)); } catch (_persistErr) {}
                }
              }
              return window.crypto.subtle.importKey('raw', material, { name: 'AES-GCM' }, false, ['encrypt', 'decrypt']);
            })();
            store.cookieKeyPromise = promise;
            return promise;
          }

          async function encryptSessionPayload(payload) {
            if (!payload || !cryptoAvailable()) {
              return null;
            }
            try {
              var key = await ensureCookieCryptoKey();
              if (!key) { return null; }
              var iv = new Uint8Array(12);
              window.crypto.getRandomValues(iv);
              var data = (textEncoder || new TextEncoder()).encode(JSON.stringify(payload));
              var cipher = await window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, data);
              var combined = new Uint8Array(iv.byteLength + cipher.byteLength);
              combined.set(iv, 0);
              combined.set(new Uint8Array(cipher), iv.byteLength);
              return bytesToBase64(combined);
            } catch (_err) {
              return null;
            }
          }

          async function decryptSessionPayload(serialized) {
            if (!serialized || !cryptoAvailable()) {
              return null;
            }
            try {
              var combined = base64ToBytes(serialized);
              if (!combined.length || combined.length <= 12) {
                return null;
              }
              var iv = combined.slice(0, 12);
              var cipher = combined.slice(12);
              var key = await ensureCookieCryptoKey();
              if (!key) { return null; }
              var plain = await window.crypto.subtle.decrypt({ name: 'AES-GCM', iv: iv }, key, cipher);
              var json = (textDecoder || new TextDecoder()).decode(plain);
              return JSON.parse(json);
            } catch (_err) {
              return null;
            }
          }

          function getCookieValue(name) {
            if (typeof document === 'undefined' || !name) { return null; }
            var source = document.cookie ? document.cookie.split(';') : [];
            for (var i = 0; i < source.length; i++) {
              var part = source[i] ? source[i].trim() : '';
              if (!part) { continue; }
              if (part.indexOf(name + '=') === 0) {
                return decodeURIComponent(part.slice(name.length + 1));
              }
            }
            return null;
          }

          function setCookieValue(name, value, options) {
            if (typeof document === 'undefined' || !name) { return; }
            var attrs = name + '=' + (value ? encodeURIComponent(value) : '');
            var opts = options || {};
            if (opts.maxAge != null) {
              attrs += '; Max-Age=' + Math.max(0, Math.floor(opts.maxAge));
            }
            if (opts.expires instanceof Date) {
              attrs += '; Expires=' + opts.expires.toUTCString();
            }
            attrs += '; Path=/';
            if (typeof window !== 'undefined' && window.location && window.location.protocol === 'https:') {
              attrs += '; Secure';
            }
            attrs += '; SameSite=Lax';
            document.cookie = attrs;
          }

          async function writeSessionCookie(session) {
            if (!session || !session.token || !session.pin) {
              await deleteSessionCookie();
              return;
            }
            var expiresAt = session.expiresAt || (Date.now() + 3600000);
            var payload = {
              token: session.token,
              pin: session.pin,
              conversationId: session.conversationId || '',
              expiresAt: expiresAt,
              user: session.user || null
            };
            var encoded = await encryptSessionPayload(payload);
            if (!encoded) {
              setCookieValue(COOKIE_NAME, '', { maxAge: 0 });
              return;
            }
            var maxAge = Math.max(0, Math.floor((expiresAt - Date.now()) / 1000));
            setCookieValue(COOKIE_NAME, encoded, { maxAge: maxAge });
          }

          async function readSessionCookie() {
            var value = getCookieValue(COOKIE_NAME);
            if (!value) { return null; }
            var payload = await decryptSessionPayload(value);
            if (!payload || typeof payload !== 'object') {
              return null;
            }
            return payload;
          }

          async function deleteSessionCookie() {
            setCookieValue(COOKIE_NAME, '', { maxAge: 0 });
          }

          async function persistSession(update, options) {
            var store = runtime();
            var previous = store.session || {};
            var session = Object.assign({}, previous);
            var patch = update || {};
            var hasUsername = Object.prototype.hasOwnProperty.call(patch, 'username');
            var hasConversation = Object.prototype.hasOwnProperty.call(patch, 'conversationId');
            if (Object.prototype.hasOwnProperty.call(patch, 'username')) {
              session.username = patch.username || '';
            }
            if (Object.prototype.hasOwnProperty.call(patch, 'conversationId')) {
              session.conversationId = patch.conversationId || '';
            }
            if (Object.prototype.hasOwnProperty.call(patch, 'pin')) {
              session.pin = patch.pin || '';
            }
            if (Object.prototype.hasOwnProperty.call(patch, 'token')) {
              session.token = patch.token || '';
            }
            if (Object.prototype.hasOwnProperty.call(patch, 'expiresAt')) {
              session.expiresAt = patch.expiresAt || null;
            }
            if (Object.prototype.hasOwnProperty.call(patch, 'user')) {
              session.user = patch.user || null;
            }
            store.session = session;
            var existingPrefs = loadPreferences();
            var prefsToSave = {
              username: hasUsername
                ? (session.username || '')
                : ((existingPrefs && existingPrefs.username) || session.username || ''),
              conversationId: hasConversation
                ? (session.conversationId || '')
                : ((existingPrefs && existingPrefs.conversationId) || session.conversationId || ''),
            };
            savePreferences(prefsToSave);
            var writeCookie = !(options && options.cookie === false);
            if (writeCookie) {
              if (session.token && session.pin && session.expiresAt) {
                await writeSessionCookie(session);
              } else {
                await deleteSessionCookie();
              }
            }
            return session;
          }

          async function restoreSession(context) {
            var store = runtime();
            if (store.sessionRestored) {
              return store.session || {};
            }
            var prefs = loadPreferences();
            var cookieData = await readSessionCookie();
            var session = Object.assign({}, prefs || {});
            if (cookieData && typeof cookieData === 'object') {
              session.token = cookieData.token || session.token || '';
              session.pin = cookieData.pin || session.pin || '';
              session.conversationId = cookieData.conversationId || session.conversationId || '';
              session.expiresAt = cookieData.expiresAt || session.expiresAt || null;
              session.user = cookieData.user || session.user || null;
            }
            if (!session.conversationId) {
              session.conversationId = config().conversationId || 'demo:lobby';
            }
            if (!session.username) {
              session.username = prefs && prefs.username ? prefs.username : '';
            }
            if (!session.token || !session.expiresAt || session.expiresAt <= Date.now()) {
              session.token = '';
              session.expiresAt = null;
            }
            store.session = session;
            store.sessionRestored = true;
            if (session.token && session.expiresAt) {
              store.authToken = session.token;
              store.authTokenMeta = {
                expiresAt: session.expiresAt,
                user: session.user || null,
                conversationId: session.conversationId || null
              };
            }
            var contextRef = ensureContext(context);
            if (contextRef) {
              if (session.username) {
                try { contextRef.set('data.username', session.username); } catch (_err) {}
              }
              if (session.conversationId) {
                try {
                  contextRef.set('data.selectedRoom', session.conversationId);
                  contextRef.set('data.conversationId', session.conversationId);
                  contextRef.set('data.topic', topicFromConversation(session.conversationId));
                } catch (_err) {}
              }
            }
            return session;
          }

          async function clearSessionToken(options) {
            var store = runtime();
            store.authToken = null;
            store.authTokenMeta = null;
            var keepPin = options && options.keepPin;
            var session = store.session || {};
            session.token = '';
            session.expiresAt = null;
            session.user = null;
            if (!keepPin) {
              session.pin = '';
            }
            store.session = session;
            await persistSession({
              token: '',
              expiresAt: null,
              user: null,
              pin: keepPin ? session.pin : ''
            });
          }

          function topicFromConversation(conversationId) {
            if (!conversationId) { return ''; }
            return conversationId.indexOf('chat:') === 0 ? conversationId : 'chat:' + conversationId;
          }

          function applyRoomsToState(rooms, preferredId) {
            var normalized = Array.isArray(rooms)
              ? rooms.map(function (room) {
                  if (!room || typeof room !== 'object') { return null; }
                  var id = room.id || room.conversationId || '';
                  if (!id) { return null; }
                  return {
                    id: id,
                    name: room.name || room.title || id,
                    description: room.description || '',
                    requiresPin: Object.prototype.hasOwnProperty.call(room, 'requiresPin') ? Boolean(room.requiresPin) : true
                  };
                }).filter(Boolean)
              : [];
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var desired = preferredId || data.selectedRoom || (normalized[0] && normalized[0].id) || data.conversationId || config().conversationId;
              if (desired && normalized.length && normalized.every(function (room) { return room.id !== desired; })) {
                desired = normalized[0].id;
              }
              var nextConversation = desired || data.conversationId || config().conversationId;
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  rooms: normalized,
                  selectedRoom: desired || '',
                  conversationId: nextConversation || '',
                  topic: topicFromConversation(nextConversation || '')
                })
              });
            });
          }

          async function loadChatRooms(ctx, preferredId) {
            var store = runtime();
            if (store.roomsLoading) { return; }
            var endpoint = resolveRoomsEndpoint();
            if (!endpoint) { return; }
            var utils = utilsHost();
            var fetcher = utils && utils.Net && typeof utils.Net.ajax === 'function' ? utils.Net.ajax : null;
            if (!fetcher) { return; }
            store.roomsLoading = true;
            try {
              var response = await fetcher(endpoint, { method: 'GET', responseType: 'json', timeout: 8000 });
              var rooms = [];
              if (response && Array.isArray(response.rooms)) {
                rooms = response.rooms;
              } else if (Array.isArray(response)) {
                rooms = response;
              }
              applyRoomsToState(rooms, preferredId);
            } catch (loadErr) {
              warn('تعذر تحميل قائمة الغرف من الخادم.', { error: loadErr });
              var fallbackId = config().conversationId || 'demo:lobby';
              applyRoomsToState([
                { id: fallbackId, name: fallbackId, topic: topicFromConversation(fallbackId), requiresPin: true },
              ], preferredId);
            } finally {
              store.roomsLoading = false;
            }
          }

          function handleRoomSelect(event, ctx) {
            var context = ensureContext(ctx, event);
            if (!context || !event || !event.target) { return; }
            var value = '';
            if (typeof event.target.value === 'string') {
              value = event.target.value;
            }
            context.set('data.selectedRoom', value);
            if (value) {
              context.set('data.conversationId', value);
              context.set('data.topic', topicFromConversation(value));
            }
            context.set('data.pinError', '');
            persistSession({ conversationId: value }, { cookie: false }).catch(function () {});
          }

          function handlePinInput(event, ctx) {
            var context = ensureContext(ctx, event);
            if (!context || !event || !event.target) { return; }
            var value = '';
            if (typeof event.target.value === 'string') {
              value = event.target.value;
            }
            context.set('data.roomPin', value);
          }

          function latestMessageTimestamp(state, ctx) {
            if (!state || !state.data || !Array.isArray(state.data.messages) || !state.data.messages.length) {
              return '—';
            }
            var messages = state.data.messages.slice(-1);
            var last = messages.length ? messages[0] : null;
            if (!last || !last.createdAt) { return '—'; }
            var formatted = formatChatTime(last.createdAt, false, ctx);
            return formatted || '—';
          }

          function findMessagesContainer() {
            if (typeof document === 'undefined') { return null; }
            try {
              return document.querySelector('[data-chat-messages]');
            } catch (_err) {
              return null;
            }
          }

          function scrollMessagesToBottom(immediate) {
            var container = findMessagesContainer();
            if (!container) { return; }
            var run = function () {
              try {
                container.scrollTop = container.scrollHeight;
              } catch (_err) {}
            };
            if (immediate) {
              run();
            } else if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
              window.requestAnimationFrame(run);
            } else {
              run();
            }
          }

          function scheduleScrollToBottom(immediate) {
            if (typeof window === 'undefined') { return; }
            if (immediate) {
              scrollMessagesToBottom(true);
              return;
            }
            if (pendingScrollFrame) {
              return;
            }
            pendingScrollFrame = window.requestAnimationFrame(function () {
              pendingScrollFrame = null;
              scrollMessagesToBottom(false);
            });
          }

          function formatLockTime(value, ctx) {
            if (!value) { return ''; }
            return formatChatTime(value, false, ctx) || '';
          }

          function handleTokenAcquisitionFailure(context, info) {
            var details = info || {};
            var message = typeof details.message === 'string' && details.message ? details.message : 'تعذر المصادقة على الغرفة. يرجى التحقق من رمز PIN.';
            var lockUntil = details.lockUntil || null;
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  joined: false,
                  pinError: message,
                  lockExpiresAt: lockUntil,
                  loadingState: 'idle',
                  loadingMessage: '',
                  historyLoaded: false,
                  connection: Object.assign({}, data.connection || {}, { status: 'idle', lastError: null, user: null })
                })
              });
            });
            var ctxRef = ensureContext(context);
            if (ctxRef) {
              try { ctxRef.set('data.joined', false); } catch (_err) {}
              try { ctxRef.set('data.pinError', message); } catch (_err) {}
              if (!details.keepPin) {
                try { ctxRef.set('data.roomPin', ''); } catch (_err) {}
              }
            }
            clearSessionToken({ keepPin: Boolean(details.keepPin) }).catch(function () {});
          }

          async function leaveChat(ctx) {
            var context = ensureContext(ctx);
            if (!context) { return; }
            var store = runtime();
            if (store.socket && typeof store.socket.close === 'function') {
              try { store.socket.close(1000, 'logout'); } catch (_err) {}
              store.socket = null;
            }
            resetAuthState({ clearToken: true });
            await clearSessionToken({ keepPin: false }).catch(function () {});
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  joined: false,
                  messages: [],
                  errors: [],
                  newMessage: '',
                  loadingState: 'idle',
                  loadingMessage: '',
                  historyLoaded: false,
                  pinError: '',
                  lockExpiresAt: null,
                  connection: Object.assign({}, data.connection || {}, { status: 'idle', lastError: null, user: null })
                })
              });
            });
            try { context.set('data.roomPin', ''); } catch (_err) {}
            try { context.set('data.pinError', ''); } catch (_err) {}
            persistSession({ token: '', expiresAt: null, user: null, pin: '' }).catch(function () {});
          }

          function log(level, message, payload) {
            if (typeof console === 'undefined') return;
            var logger = typeof console[level] === 'function' ? console[level] : console.log;
            var prefix = '%c[Chat Debug]%c ';
            var style = 'color:#38bdf8;font-weight:bold;';
            var reset = 'color:inherit;';
            try {
              if (payload !== undefined) {
                logger.call(console, prefix + message, style, reset, payload);
              } else {
                logger.call(console, prefix + message, style, reset);
              }
            } catch (error) {
              console.error(prefix + 'فشل تسجيل الحمولة debug payload', style, reset, error);
            }
          }

          function info(message, payload) { log('info', message, payload); }
          function warn(message, payload) { log('warn', message, payload); }
          function error(message, payload) { log('error', message, payload); }
          function debug(message, payload) { log('debug', message, payload); }

          function config() {
            var store = runtime();
            if (!store.config) {
              store.config = {
                url: 'wss://ws.mas.com.eg',
                conversationId: 'demo:lobby',
                topic: 'chat:demo:lobby',
                historyLimit: 50,
                maxErrors: 10,
                tokenEndpoint: null,
                roomsEndpoint: null,
                keyId: 'chat:demo:plaintext'
              };
            }
            return store.config;
          }

          function ensureContext(ctx, event) {
            var store = runtime();
            var input = ctx;
            if (!input && event) {
              if (event.detail && event.detail.ctx) {
                input = event.detail.ctx;
              } else if (event.target) {
                input = event.target;
              } else if (event.currentTarget) {
                input = event.currentTarget;
              }
            }
            if (!input && store.lastCtx) {
              return store.lastCtx;
            }
            if (!input && store.app) {
              input = store.app;
            }
            if (!input) {
              error('ensureContext لم يتمكن من تحديد سياق صالح.');
              return null;
            }
            if (typeof input.get === 'function' && typeof input.set === 'function') {
              store.lastCtx = input;
              return input;
            }
            var agent = htmlxAgent();
            if (!agent || typeof agent.ContextAdapter !== 'function') {
              error('ContextAdapter غير متاح.');
              return null;
            }
            var adapted = agent.ContextAdapter(input);
            if (!adapted && store.app && input !== store.app) {
              adapted = agent.ContextAdapter(store.app);
            }
            if (!adapted && event) {
              var fallbackTarget = event.currentTarget || event.target || null;
              if (fallbackTarget && fallbackTarget !== input) {
                adapted = agent.ContextAdapter(fallbackTarget);
              }
            }
            if (!adapted) {
              error('فشل ContextAdapter في إرجاع سياق صالح.');
              return null;
            }
            store.lastCtx = adapted;
            return adapted;
          }

          function mutateState(updater) {
            var store = runtime();
            var target = store.app || store.lastCtx;
            if (!target) return false;
            if (typeof target.setState === 'function') {
              target.setState(updater);
              return true;
            }
            if (typeof target.set === 'function') {
              try {
                var state = target.getState ? target.getState() : {};
                var next = updater(state);
                target.setState(function () { return next; });
                return true;
              } catch (_err) {}
            }
            return false;
          }

          function readState() {
            var store = runtime();
            var target = store.app || store.lastCtx;
            if (target && typeof target.getState === 'function') {
              return target.getState();
            }
            return {};
          }

          function deriveHttpUrl(url) {
            if (!url) return null;
            try {
              var parsed = new URL(url, window.location.href);
              if (parsed.protocol === 'wss:') parsed.protocol = 'https:';
              if (parsed.protocol === 'ws:') parsed.protocol = 'http:';
              parsed.hash = '';
              return parsed.toString().replace(/\/+$/, '');
            } catch (parseError) {
              warn('تعذر تحليل رابط WebSocket لتحويله إلى HTTP.', { url: url, error: parseError });
              return null;
            }
          }

          function resolveTokenEndpoint() {
            var cfg = config();
            if (cfg.tokenEndpoint) return cfg.tokenEndpoint;
            var base = deriveHttpUrl(cfg.url);
            if (!base) return null;
            return base.replace(/\/+$/, '') + '/api/demo/guest-token';
          }

          function resolveRoomsEndpoint() {
            var cfg = config();
            if (cfg.roomsEndpoint) return cfg.roomsEndpoint;
            var base = deriveHttpUrl(cfg.url);
            if (!base) return null;
            return base.replace(/\/+$/, '') + '/api/chat/rooms';
          }

          async function ensureAuthToken(context) {
            var store = runtime();
            var now = Date.now();
            if (store.authToken && store.authTokenMeta && store.authTokenMeta.expiresAt && store.authTokenMeta.expiresAt - now > 5000) {
              return store.authToken;
            }
            if (store.authenticating && store.authPromise) {
              return store.authPromise;
            }
            var session = await restoreSession(context);
            if (session && session.token && session.expiresAt && session.expiresAt - now > 5000) {
              store.authToken = session.token;
              store.authTokenMeta = {
                expiresAt: session.expiresAt,
                user: session.user || null,
                conversationId: session.conversationId || null
              };
              return session.token;
            }
            var ctxRef = ensureContext(context);
            var preferredName = session && session.username ? session.username : '';
            if (!preferredName && ctxRef && typeof ctxRef.get === 'function') {
              try { preferredName = ctxRef.get('data.username') || ''; } catch (_err) { preferredName = ''; }
            }
            if (!preferredName) {
              preferredName = generateGuestName();
              if (ctxRef && typeof ctxRef.set === 'function') {
                try { ctxRef.set('data.username', preferredName); } catch (_syncErr) {}
              }
            }
            var conversationId = session && session.conversationId ? session.conversationId : '';
            if (!conversationId && ctxRef && typeof ctxRef.get === 'function') {
              try { conversationId = ctxRef.get('data.conversationId') || ''; } catch (_convErr) { conversationId = ''; }
            }
            if (!conversationId) {
              conversationId = config().conversationId || 'demo:lobby';
            }
            var pin = session && session.pin ? session.pin : '';
            if (!pin && ctxRef && typeof ctxRef.get === 'function') {
              try { pin = ctxRef.get('data.roomPin') || ''; } catch (_pinErr) { pin = ''; }
            }
            pin = typeof pin === 'string' ? pin.trim() : '';
            if (!pin) {
              throw new Error('رمز PIN مطلوب للغرفة المختارة.');
            }
            persistSession({ username: preferredName, conversationId: conversationId, pin: pin }, { cookie: false }).catch(function () {});
            var cfg = config();
            cfg.conversationId = conversationId;
            cfg.topic = topicFromConversation(conversationId);
            var endpoint = resolveTokenEndpoint();
            if (!endpoint) {
              throw new Error('لم يتم تحديد نقطة نهاية للرمز.');
            }
            var fetcher = (utilsHost().Net && utilsHost().Net.ajax) ? utilsHost().Net.ajax : null;
            if (!fetcher) {
              throw new Error('أداة الشبكة غير متاحة للحصول على رمز الضيف.');
            }
            if (ctxRef) {
              try { ctxRef.set('data.pinError', ''); } catch (_err) {}
              try { ctxRef.set('data.lockExpiresAt', null); } catch (_err) {}
            }
            store.authenticating = true;
            var requestBody = {
              conversationId: conversationId,
              name: preferredName,
              pin: pin
            };
            store.authPromise = fetcher(endpoint, {
              method: 'POST',
              responseType: 'json',
              timeout: 8000,
              body: requestBody
            })
              .then(function (response) {
                if (!response || !response.token) {
                  throw new Error('استجابة الرمز غير صالحة.');
                }
                var expiresIn = Number(response.expiresIn || response.expires_in || 0);
                var expiresAt = Date.now() + (expiresIn > 0 ? expiresIn * 1000 : 3600000);
                var normalizedUser = response.user ? normalizeUserInfo(response.user) : null;
                store.authToken = response.token;
                store.authTokenMeta = {
                  expiresAt: expiresAt,
                  user: normalizedUser,
                  conversationId: conversationId
                };
                persistSession({
                  username: preferredName,
                  conversationId: conversationId,
                  pin: pin,
                  token: response.token,
                  expiresAt: expiresAt,
                  user: normalizedUser
                }).catch(function () {});
                mutateState(function (prev) {
                  var base = prev || {};
                  var data = base.data || {};
                  var users = Array.isArray(data.users) ? data.users.slice() : [];
                  if (normalizedUser && normalizedUser.name && users.indexOf(normalizedUser.name) === -1) {
                    users.push(normalizedUser.name);
                  }
                  return Object.assign({}, base, {
                    data: Object.assign({}, data, {
                      pinError: '',
                      lockExpiresAt: null,
                      users: users,
                      connection: Object.assign({}, data.connection || {}, { user: normalizedUser || data.connection && data.connection.user || null })
                    })
                  });
                });
                return response.token;
              })
              .catch(async function (fetchError) {
                store.authToken = null;
                store.authTokenMeta = null;
                store.authenticated = false;
                var message = 'تعذر المصادقة على الغرفة. يرجى التحقق من رمز PIN.';
                var lockUntil = null;
                var keepPin = false;
                var httpErrorClass = utilsHost().HttpError;
                if (httpErrorClass && fetchError instanceof httpErrorClass && fetchError.response) {
                  try {
                    var payload = await fetchError.response.json();
                    if (payload && typeof payload === 'object') {
                      if (payload.message) { message = payload.message; }
                      if (payload.code === 'pin_locked') {
                        keepPin = true;
                        lockUntil = payload.lockedUntil || payload.lockExpiresAt || payload.locked_until || null;
                        if (!payload.message) {
                          message = 'تم حظر المحاولات مؤقتًا بسبب محاولات عديدة فاشلة.';
                        }
                      } else if (payload.code === 'pin_invalid') {
                        message = payload.message || 'رمز PIN غير صحيح، حاول مرة أخرى.';
                      }
                    }
                  } catch (_parseErr) {}
                } else if (fetchError && fetchError.message) {
                  message = fetchError.message;
                }
                handleTokenAcquisitionFailure(context, { message: message, lockUntil: lockUntil, keepPin: keepPin });
                throw fetchError;
              })
              .finally(function () {
                store.authenticating = false;
                store.authPromise = null;
              });
            return store.authPromise;
          }

          function extractError(meta) {
            if (!meta) return null;
            if (meta instanceof Error) {
              return { code: meta.code || 'error', message: meta.message };
            }
            if (typeof meta === 'string') {
              return { code: 'error', message: meta };
            }
            if (meta.code || meta.message || meta.reason) {
              return {
                code: meta.code || meta.status || 'error',
                message: meta.message || meta.reason || String(meta.code || 'error')
              };
            }
            if (meta.error) {
              return extractError(meta.error);
            }
            if (meta.ts && meta.code && meta.message) {
              return { code: meta.code, message: meta.message, ts: meta.ts };
            }
            try {
              return { code: meta.code || 'error', message: JSON.stringify(meta) };
            } catch (_err) {
              return { code: 'error', message: String(meta) };
            }
          }

          function extractErrorDetails(meta) {
            if (!meta) return [];
            var candidates = [];
            if (Array.isArray(meta.details)) candidates = candidates.concat(meta.details);
            if (Array.isArray(meta.errors)) candidates = candidates.concat(meta.errors);
            if (Array.isArray(meta.issues)) candidates = candidates.concat(meta.issues);
            if (meta.meta) {
              if (Array.isArray(meta.meta.details)) candidates = candidates.concat(meta.meta.details);
              if (Array.isArray(meta.meta.errors)) candidates = candidates.concat(meta.meta.errors);
              if (Array.isArray(meta.meta.issues)) candidates = candidates.concat(meta.meta.issues);
            }
            if (meta.error) {
              var nested = extractErrorDetails(meta.error);
              if (nested.length) candidates = candidates.concat(nested);
            }
            return candidates
              .map(function (item) {
                if (!item) return null;
                if (typeof item === 'string') return item.trim();
                if (item instanceof Error) return (item.message || '').trim();
                var parts = [];
                if (Array.isArray(item.path) && item.path.length) parts.push(item.path.join('.'));
                if (item.message) {
                  parts.push(item.message);
                } else if (item.code) {
                  parts.push(item.code);
                }
                if (!parts.length && typeof item === 'object') {
                  try {
                    return JSON.stringify(item);
                  } catch (_err) {
                    return String(item);
                  }
                }
                return parts.join(': ').trim();
              })
              .filter(function (value, index, all) {
                if (!value) return false;
                return all.indexOf(value) === index;
              });
          }

          function recordError(code, message, meta, options) {
            var entry = {
              id: 'err-' + Date.now().toString(36) + '-' + Math.random().toString(16).slice(2, 8),
              code: code || 'unknown',
              message: (message || '').trim() || 'حدث خطأ غير معروف.',
              ts: new Date().toISOString(),
              meta: meta || null,
              details: extractErrorDetails(meta)
            };
            warn(entry.message, { code: entry.code, meta: meta });
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var errors = Array.isArray(data.errors) ? data.errors.slice() : [];
              errors.unshift(entry);
              var cfg = config();
              if (errors.length > cfg.maxErrors) {
                errors = errors.slice(0, cfg.maxErrors);
              }
              var connection = Object.assign({}, data.connection || {});
              if (options && options.connection) {
                connection.lastError = {
                  code: entry.code,
                  message: entry.message,
                  ts: entry.ts,
                  details: entry.details
                };
              }
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  errors: errors,
                  connection: connection
                })
              });
            });
            return entry;
          }

          function normalizeUserInfo(rawUser) {
            if (!rawUser) return null;
            var claims = rawUser.claims || {};
            var name = rawUser.name || claims.name || claims.username || claims.displayName || '';
            var identifier = rawUser.id || claims.sub || claims.id || null;
            if (!name && identifier) {
              name = identifier;
            }
            return {
              id: identifier,
              name: name || '',
              roles: Array.isArray(rawUser.roles) ? rawUser.roles.slice() : []
            };
          }

          function normalizeMessage(raw, hints) {
            var source = raw || {};
            var fallback = hints || {};
            var metadata = source.metadata || fallback.metadata || {};
            var username = metadata.username || metadata.user || fallback.username || source.user || '';
            var text = source.ciphertext || source.text || fallback.text || '';
            if (text != null && typeof text !== 'string') {
              try { text = String(text); } catch (_err) { text = ''; }
            }
            var createdAt = source.createdAt || source.ts || fallback.createdAt || new Date().toISOString();
            var clientMessageId = metadata.clientMessageId || fallback.clientMessageId || null;
            var id = source.id || fallback.id || null;
            var failed = Boolean(fallback.failed);
            var pending = Boolean(fallback.pending) && !source.id && !failed;
            if (!text && !pending && !failed) {
              return null;
            }
            return {
              id: id,
              clientMessageId: clientMessageId,
              user: username || 'مجهول',
              text: text,
              createdAt: createdAt,
              pending: pending,
              failed: failed
            };
          }

          function applyIncomingMessage(raw, hints) {
            var normalized = normalizeMessage(raw, hints || {});
            if (!normalized) {
              return;
            }
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var messages = Array.isArray(data.messages) ? data.messages.slice() : [];
              var idx = -1;
              if (normalized.clientMessageId) {
                idx = messages.findIndex(function (msg) {
                  return msg && msg.clientMessageId === normalized.clientMessageId;
                });
              }
              if (idx === -1 && normalized.id) {
                idx = messages.findIndex(function (msg) {
                  return msg && msg.id === normalized.id;
                });
              }
              if (idx !== -1) {
                messages[idx] = Object.assign({}, messages[idx], normalized, { pending: normalized.pending, failed: normalized.failed });
              } else {
                messages.push(normalized);
              }
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  messages: messages
                })
              });
            });
            setLoadingState('ready');
            scheduleScrollToBottom();
          }

          function setLoadingState(status, meta) {
            var next = typeof status === 'string' && status.trim() ? status.trim() : 'idle';
            var message = (meta && typeof meta.message === 'string') ? meta.message.trim() : null;
            var historyOverride = (meta && Object.prototype.hasOwnProperty.call(meta, 'historyLoaded')) ? Boolean(meta.historyLoaded) : null;
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var update = {
                loadingState: next
              };
              if (message !== null) {
                update.loadingMessage = message;
              } else if (next === 'ready') {
                update.loadingMessage = '';
              } else if (typeof data.loadingMessage === 'string') {
                update.loadingMessage = data.loadingMessage;
              } else {
                update.loadingMessage = '';
              }
              if (next === 'ready') {
                update.historyLoaded = true;
              } else if (historyOverride !== null) {
                update.historyLoaded = historyOverride;
              }
              return Object.assign({}, base, {
                data: Object.assign({}, data, update)
              });
            });
          }

          function setConnectionStatus(status, meta) {
            var normalizedError = status === 'error' ? extractError(meta) : extractError(meta && meta.error);
            var resetError = status === 'connected' || (meta && meta.resetError);
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var connection = Object.assign({}, data.connection || {});
              connection.status = status;
              if (resetError) {
                connection.lastError = null;
              } else if (normalizedError) {
                connection.lastError = normalizedError;
              }
              if (meta && Object.prototype.hasOwnProperty.call(meta, 'user')) {
                connection.user = meta.user;
              } else if (!Object.prototype.hasOwnProperty.call(connection, 'user')) {
                connection.user = (data.connection && data.connection.user) || null;
              }
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  connection: connection
                })
              });
            });
          }

          function resetAuthState(options) {
            var store = runtime();
            var settings = options || {};
            store.authenticated = false;
            store.subscriptionRequested = false;
            store.historyRequested = false;
            store.authenticating = false;
            store.authPromise = null;
            if (settings.clearToken) {
              store.authToken = null;
              store.authTokenMeta = null;
              if (store.socket && store.socket.auth) {
                store.socket.auth.token = null;
              }
              clearSessionToken({ keepPin: Boolean(settings.keepPin) }).catch(function () {});
              mutateState(function (prev) {
                var base = prev || {};
                var data = base.data || {};
                var connection = Object.assign({}, data.connection || {});
                connection.user = null;
                return Object.assign({}, base, {
                  data: Object.assign({}, data, { connection: connection })
                });
              });
            }
          }

          function handleAckMessage(message) {
            var store = runtime();
            if (!message) {
              return;
            }
            if (message.event === 'auth') {
              store.authenticated = true;
              store.subscriptionRequested = false;
              store.historyRequested = false;
              var normalizedUser = normalizeUserInfo(message.user);
              if (normalizedUser) {
                mutateState(function (prev) {
                  var base = prev || {};
                  var data = base.data || {};
                  var users = Array.isArray(data.users) ? data.users.slice() : [];
                  if (normalizedUser.name && users.indexOf(normalizedUser.name) === -1) {
                    users.push(normalizedUser.name);
                  }
                  return Object.assign({}, base, {
                    data: Object.assign({}, data, {
                      users: users,
                      connection: Object.assign({}, data.connection || {}, { user: normalizedUser })
                    })
                  });
                });
              }
              setConnectionStatus('connected', { resetError: true, user: normalizedUser || null });
              setLoadingState('connected', { message: 'جارٍ تحميل سجل الرسائل...', historyLoaded: false });
              subscribeToChat();
              requestHistory(true);
              return;
            }
            if (message.event === 'subscribe') {
              info('تم تأكيد الاشتراك في موضوع الدردشة.', { topic: message.topic });
              setLoadingState('connected', { message: 'تم الاشتراك بنجاح، نعرض المحادثة الآن...', historyLoaded: false });
              return;
            }
            if (message.event === 'chat:send') {
              if (message.ok === false || message.error) {
                var err = extractError(message.error || message.meta || { code: 'send_failed', message: 'تعذر إرسال الرسالة.' });
                recordError(err.code || 'send_failed', err.message || 'تعذر إرسال الرسالة.', message, { connection: message.error && message.error.code === 'unauthorized_pub' });
                applyIncomingMessage(null, {
                  clientMessageId: message.metadata && message.metadata.clientMessageId,
                  username: message.metadata && message.metadata.username,
                  text: message.data && (message.data.ciphertext || message.data.text),
                  pending: false,
                  failed: true,
                  createdAt: new Date().toISOString(),
                  metadata: message.metadata || {}
                });
                return;
              }
              if (message.message) {
                applyIncomingMessage(message.message, {});
              }
            }
          }

          function handlePublishMessage(message) {
            var cfg = config();
            if (!message || message.topic !== cfg.topic) {
              return;
            }
            applyIncomingMessage(message.data || {}, {});
            setLoadingState('ready');
          }

          function handleHistoryMessage(message) {
            var cfg = config();
            if (!message || message.conversationId !== cfg.conversationId) {
              return;
            }
            var list = Array.isArray(message.messages) ? message.messages : [];
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var users = Array.isArray(data.users) ? data.users.slice() : [];
              var normalizedMessages = list
                .map(function (item) { return normalizeMessage(item, {}); })
                .filter(Boolean)
                .sort(function (a, b) { return new Date(a.createdAt || 0) - new Date(b.createdAt || 0); });
              var userSet = new Set(users);
              normalizedMessages.forEach(function (msg) {
                if (msg.user) {
                  userSet.add(msg.user);
                }
              });
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  messages: normalizedMessages,
                  users: Array.from(userSet)
                })
              });
            });
            setLoadingState('ready');
            scheduleScrollToBottom(true);
          }

          function handleServerError(message) {
            var code = message && message.code ? message.code : 'server_error';
            var text = message && message.message ? message.message : 'أبلغ الخادم عن خطأ غير معروف.';
            recordError(code, text, message, { connection: true });
            setConnectionStatus('error', { code: code, message: text });
            setLoadingState('error', { message: 'أبلغ الخادم عن خطأ: ' + text, historyLoaded: false });
            var store = runtime();
            if (code === 'unauthorized_sub' || code === 'topic_not_allowed') {
              store.subscriptionRequested = false;
            }
            if (code === 'unauthorized_pub') {
              store.authenticated = false;
            }
            if (code === 'auth_failed' || code === 'unauthorized' || code === 'token_required' || code === 'unauthorized_pub') {
              resetAuthState({ clearToken: true });
              if (store.socket && typeof store.socket.close === 'function') {
                try { store.socket.close(4401, 'reauth'); } catch (_closeErr) {}
              }
            }
          }

          function handleSocketMessage(message) {
            var store = runtime();
            if (!message) {
              return;
            }
            if (typeof message === 'string') {
              try { message = JSON.parse(message); } catch (_err) { return; }
            }
            debug('رسالة WebSocket واردة', message);
            switch (message.type) {
              case 'hello':
                resetAuthState({ clearToken: true });
                if (store.socket && store.socket.auth) {
                  store.socket.auth.token = null;
                }
                setLoadingState('connecting', { message: 'جارٍ إعادة المصادقة على الاتصال...', historyLoaded: false });
                (async function () {
                  try {
                    var token = await ensureAuthToken(store.lastCtx);
                    if (store.socket && store.socket.state === 'open') {
                      var helloAuthResult = safeSend(store.socket, { type: 'auth', data: { token: token } });
                      if (!helloAuthResult.ok) {
                        reportSendFailure(helloAuthResult, { type: 'auth', data: { token: token } }, 'auth');
                        setLoadingState('error', { message: 'تعذر إعادة المصادقة على الاتصال.', historyLoaded: false });
                      }
                    }
                  } catch (reauthErr) {
                    recordError('auth_retry_failed', 'تعذر استكمال المصادقة التلقائية بعد رسالة hello.', reauthErr, { connection: true });
                    setLoadingState('error', { message: 'تعذر إعادة المصادقة على الاتصال.', historyLoaded: false });
                  }
                })();
                break;
              case 'ack':
                handleAckMessage(message);
                break;
              case 'publish':
                handlePublishMessage(message);
                break;
              case 'chat:history':
                handleHistoryMessage(message);
                break;
              case 'error':
                handleServerError(message);
                break;
              case 'pong':
                break;
              default:
                debug('رسالة غير معالجة من الخادم', message);
            }
          }

          function attachSocketHandlers(socket) {
            var store = runtime();
            if (!socket || socket.__chatHandlersAttached) {
              return;
            }
            socket.__chatHandlersAttached = true;
            socket.on('open', function () {
              var cfg = config();
              info('تم فتح اتصال WebSocket بنجاح.', { topic: cfg.topic });
              resetAuthState();
              setConnectionStatus('connected', { resetError: true });
              setLoadingState('connected', { message: 'جارٍ مزامنة المحادثة...', historyLoaded: false });
            });
            socket.on('close', function (evt) {
              warn('تم إغلاق اتصال WebSocket.', { code: evt && evt.code, reason: evt && evt.reason });
              resetAuthState();
              setConnectionStatus('disconnected', { error: evt && { code: evt.code || 'closed', message: evt.reason || '' } });
              setLoadingState('reconnecting', { message: 'جارٍ إعادة الاتصال بالخادم...', historyLoaded: false });
            });
            socket.on('error', function (err) {
              recordError('socket_error', 'حدث خطأ في قناة WebSocket.', err, { connection: true });
              setConnectionStatus('error', err);
              setLoadingState('error', { message: 'حدث خطأ في اتصال الدردشة. نحاول إعادة الاتصال...', historyLoaded: false });
            });
            socket.on('state', function (state) {
              debug('تغيرت حالة WebSocket', { state: state });
              if (!state || !state.state) return;
              switch (state.state) {
                case 'connecting':
                  setLoadingState('connecting', { message: 'جارٍ الاتصال بخادم الدردشة...', historyLoaded: false });
                  break;
                case 'open':
                  setLoadingState('connected', { message: 'جارٍ مزامنة المحادثة...', historyLoaded: false });
                  break;
                case 'closed':
                  setLoadingState('reconnecting', { message: 'جارٍ إعادة محاولة الاتصال...', historyLoaded: false });
                  break;
                case 'offline':
                  setLoadingState('error', { message: 'الاتصال غير متاح مؤقتًا. تأكد من الشبكة.', historyLoaded: false });
                  break;
              }
            });
            socket.on('message', function (msg) {
              handleSocketMessage(msg);
            });
          }

          function syncConfigWithState() {
            var state = readState();
            if (!state || !state.data) {
              return;
            }
            var data = state.data;
            var cfg = config();
            if (typeof data.conversationId === 'string' && data.conversationId) {
              cfg.conversationId = data.conversationId;
            }
            if (typeof data.topic === 'string' && data.topic) {
              cfg.topic = data.topic;
            } else if (cfg.conversationId) {
              cfg.topic = 'chat:' + cfg.conversationId;
            }
            if (typeof data.messageKeyId === 'string' && data.messageKeyId.trim()) {
              cfg.keyId = data.messageKeyId.trim();
            }
            mutateState(function (prev) {
              var base = prev || {};
              var prevData = base.data || {};
              if (prevData.topic === cfg.topic && prevData.conversationId === cfg.conversationId) {
                return base;
              }
              return Object.assign({}, base, {
                data: Object.assign({}, prevData, {
                  topic: cfg.topic,
                  conversationId: cfg.conversationId
                })
              });
            });
          }

          function safeSend(socket, payload) {
            if (!socket || typeof socket.send !== 'function') {
              return { ok: false, reason: 'socket' };
            }
            if (!payload || typeof payload !== 'object') {
              return { ok: false, reason: 'payload' };
            }
            var type = '';
            if (typeof payload.type === 'string') {
              type = payload.type.trim();
            }
            if (!type) {
              return { ok: false, reason: 'type' };
            }
            var normalized = Object.assign({}, payload, { type: type });
            try {
              socket.send(normalized);
              return { ok: true };
            } catch (err) {
              return { ok: false, reason: 'send', error: err };
            }
          }

          function reportSendFailure(result, payload, label) {
            if (!result || result.ok) {
              return;
            }
            var tag = label || (payload && payload.type) || 'message';
            switch (result.reason) {
              case 'socket':
                recordError('ws_missing', 'اتصال الدردشة غير جاهز لإرسال "' + tag + '".', payload, { connection: true });
                break;
              case 'payload':
                recordError('payload_invalid', 'تعذر إرسال "' + tag + '" لأن الحمولة غير صالحة.', payload);
                break;
              case 'type':
                recordError('type_required', 'تعذر إرسال "' + tag + '" لأن الحقل type مفقود.', payload, { connection: true });
                break;
              case 'send':
              default:
                recordError('send_failed', 'تعذر إرسال "' + tag + '" إلى الخادم.', result.error || payload, { connection: true });
                break;
            }
          }

          function requestHistory(force) {
            var store = runtime();
            if (!store.socket || store.socket.state !== 'open') {
              return;
            }
            if (store.historyRequested && !force) {
              return;
            }
            if (!store.authenticated) {
              debug('تم تجاهل طلب السجل قبل اكتمال المصادقة.');
              return;
            }
            var cfg = config();
            var requestPayload = {
              type: 'chat:history',
              conversationId: cfg.conversationId,
              limit: cfg.historyLimit
            };
            setLoadingState('connected', { message: 'جارٍ تحميل سجل الرسائل...', historyLoaded: false });
            var result = safeSend(store.socket, requestPayload);
            if (result.ok) {
              store.historyRequested = true;
              info('تم طلب سجل الرسائل.', { limit: cfg.historyLimit });
            } else {
              store.historyRequested = false;
              reportSendFailure(result, requestPayload, 'chat:history');
              setLoadingState('error', { message: 'تعذر طلب سجل الرسائل من الخادم.', historyLoaded: false });
            }
          }

          function subscribeToChat() {
            var store = runtime();
            if (!store.socket || store.socket.state !== 'open') {
              return;
            }
            if (!store.authenticated) {
              debug('تم تجاهل الاشتراك قبل اكتمال المصادقة.');
              return;
            }
            if (store.subscriptionRequested) {
              return;
            }
            var cfg = config();
            var subscribePayload = {
              type: 'subscribe',
              topic: cfg.topic,
              conversationId: cfg.conversationId
            };
            var result = safeSend(store.socket, subscribePayload);
            if (result.ok) {
              store.subscriptionRequested = true;
              setLoadingState('connected', { message: 'جارٍ الاستعداد لعرض المحادثة...', historyLoaded: false });
              info('تم إرسال طلب الاشتراك في موضوع الدردشة.', { topic: cfg.topic });
            } else {
              store.subscriptionRequested = false;
              reportSendFailure(result, subscribePayload, 'subscribe');
              if (result.reason !== 'type') {
                setConnectionStatus('error', { code: 'subscribe_failed', message: 'تعذر الاشتراك في الدردشة.' });
              }
              setLoadingState('error', { message: 'تعذر الاشتراك في الدردشة.', historyLoaded: false });
            }
          }

          function connectToChat(ctx) {
            var store = runtime();
            var context = ensureContext(ctx || store.lastCtx);
            if (!context) {
              error('connectToChat لم يتمكن من تهيئة سياق HTMLx صالح.');
              return null;
            }
            syncConfigWithState();
            var cfgSnapshot = config();
            persistSession({ conversationId: cfgSnapshot.conversationId }, { cookie: false }).catch(function () {});
            setLoadingState('connecting', { message: 'جارٍ الاتصال بخادم الدردشة...', historyLoaded: false });
            var utils = utilsHost();
            if (!utils || typeof utils.WebSocketX !== 'function') {
              recordError('wsx_unavailable', 'Mishkah.utils.WebSocketX غير متاح.', null, { connection: true });
              setLoadingState('error', { message: 'تعذر إنشاء اتصال WebSocket في المتصفح.', historyLoaded: false });
              return null;
            }
            if (!store.socket) {
              try {
                var cfg = config();
                store.socket = new utils.WebSocketX(cfg.url, {
                  autoReconnect: true,
                  backoff: { min: 1000, max: 10000, factor: 1.6 },
                  ping: { interval: 20000, send: { type: 'ping' }, expect: { type: 'pong' }, timeout: 8000 },
                  auth: {
                    param: 'token',
                    sendOnUrl: true,
                    getToken: async function () {
                      try {
                        return await ensureAuthToken(store.lastCtx || context);
                      } catch (tokenError) {
                        recordError('token_failed', 'تعذر الحصول على رمز الضيف من الخادم.', tokenError, { connection: true });
                        throw tokenError;
                      }
                    }
                  }
                });
              } catch (ctorError) {
                recordError('wsx_init_failed', 'تعذر إنشاء عميل WebSocket.', ctorError, { connection: true });
                setLoadingState('error', { message: 'تعذر إنشاء اتصال WebSocket.', historyLoaded: false });
                return null;
              }
              attachSocketHandlers(store.socket);
            }
            if (store.socket.state === 'open') {
              setConnectionStatus('connected', { resetError: true });
              setLoadingState('connected', { message: 'جارٍ مزامنة المحادثة...', historyLoaded: store.historyRequested && store.historyRequested });
              if (store.authenticated) {
                subscribeToChat();
                requestHistory(false);
              } else {
                (async function () {
                  try {
                    var token = await ensureAuthToken(store.lastCtx || context);
                    if (store.socket && store.socket.state === 'open') {
                      var authResult = safeSend(store.socket, { type: 'auth', data: { token: token } });
                      if (!authResult.ok) {
                        reportSendFailure(authResult, { type: 'auth', data: { token: token } }, 'auth');
                        setLoadingState('error', { message: 'تعذر إرسال بيانات المصادقة إلى الخادم.', historyLoaded: false });
                      }
                    }
                  } catch (tokenError) {
                    recordError('auth_failed', 'تعذر المصادقة مع خادم الدردشة.', tokenError, { connection: true });
                    setLoadingState('error', { message: 'تعذر المصادقة مع الخادم.', historyLoaded: false });
                  }
                })();
              }
            }
            return store.socket;
          }

          function retryChatConnection(ctx) {
            var context = ensureContext(ctx, null);
            if (!context) {
              error('retryChatConnection لم يتمكن من الحصول على سياق HTMLx.');
              return;
            }
            setLoadingState('connecting', { message: 'جارٍ إعادة محاولة الاتصال...', historyLoaded: false });
            setConnectionStatus('connecting');
            var socket = connectToChat(context);
            if (!socket) {
              recordError('ws_missing', 'تعذر إعادة إنشاء اتصال الدردشة.', null, { connection: true });
            }
          }

          function handleUsernameInput(event, ctx) {
            var context = ensureContext(ctx, event);
            if (!context || !event) {
              error('handleUsernameInput استقبل سياقًا أو حدثًا غير صالح.', { event: event });
              return;
            }
            var value = '';
            if (event.target && typeof event.target.value === 'string') {
              value = event.target.value;
            }
            context.set('data.username', value);
            persistSession({ username: value }, { cookie: false }).catch(function () {});
          }

          function joinChat(event, ctx) {
            var context = ensureContext(ctx, event);
            if (!context) {
              error('joinChat لم يتمكن من الحصول على سياق HTMLx.');
              return;
            }
            var roomId = '';
            try { roomId = context.get('data.selectedRoom') || context.get('data.conversationId') || ''; } catch (_roomErr) { roomId = ''; }
            roomId = typeof roomId === 'string' ? roomId.trim() : '';
            if (!roomId) {
              context.set('data.pinError', 'الرجاء اختيار غرفة دردشة قبل المتابعة.');
              return;
            }
            var pin = '';
            try { pin = context.get('data.roomPin') || ''; } catch (_pinErr) { pin = ''; }
            pin = typeof pin === 'string' ? pin.trim() : '';
            if (!pin || pin.length < 4) {
              context.set('data.pinError', 'رمز PIN يجب أن يتكون من 4 أرقام على الأقل.');
              return;
            }
            var username = context.get('data.username');
            if (!username) {
              username = generateGuestName();
              context.set('data.username', username);
            }
            context.set('data.roomPin', pin);
            context.set('data.pinError', '');
            context.set('data.lockExpiresAt', null);
            context.set('data.conversationId', roomId);
            context.set('data.topic', topicFromConversation(roomId));
            context.set('data.selectedRoom', roomId);
            context.set('data.joined', true);
            try { context.set('data.messages', []); } catch (_msgErr) {}
            try { context.set('data.errors', []); } catch (_err) {}
            try { context.set('data.historyLoaded', false); } catch (_histErr) {}
            persistSession({ username: username, conversationId: roomId, pin: pin }, { cookie: false }).catch(function () {});
            setConnectionStatus('connecting');
            setLoadingState('connecting', { message: 'جارٍ تهيئة اتصال الدردشة...', historyLoaded: false });
            connectToChat(context);
          }

          function handleMessageInput(event, ctx) {
            var context = ensureContext(ctx, event);
            if (!context || !event) {
              error('handleMessageInput استقبل سياقًا أو حدثًا غير صالح.', { event: event });
              return;
            }
            var value = '';
            if (event.target && typeof event.target.value === 'string') {
              value = event.target.value;
            }
            context.set('data.newMessage', value);
          }

          function hasDraftAttribute(node) {
            return !!(node && typeof node.hasAttribute === 'function' && node.hasAttribute('data-chat-draft'));
          }

          function findDraftInput(source) {
            if (hasDraftAttribute(source)) {
              return source;
            }
            if (source && typeof source.closest === 'function') {
              var direct = source.closest('[data-chat-draft]');
              if (direct) {
                return direct;
              }
              var form = source.closest('form');
              if (form && typeof form.querySelector === 'function') {
                var fromForm = form.querySelector('[data-chat-draft]');
                if (fromForm) {
                  return fromForm;
                }
              }
            }
            if (typeof document !== 'undefined' && document) {
              var active = document.activeElement;
              if (hasDraftAttribute(active)) {
                return active;
              }
              if (typeof document.querySelector === 'function') {
                var fallback = document.querySelector('[data-chat-draft]');
                if (fallback) {
                  return fallback;
                }
              }
            }
            return null;
          }

          function readDraftFromEvent(event) {
            var source = null;
            if (event && event.target) {
              source = event.target;
            } else if (event && event.currentTarget) {
              source = event.currentTarget;
            }
            var input = findDraftInput(source);
            if (input && typeof input.value === 'string') {
              return input.value;
            }
            return '';
          }

          function generateGuestName() {
            var random = Math.floor(Math.random() * 9000) + 1000;
            return 'ضيف-' + random;
          }

          function generateGuestAlias(ctx) {
            var context = ensureContext(ctx);
            if (!context) return;
            var alias = generateGuestName();
            context.set('data.username', alias);
          }

          function clearChatHistory(ctx) {
            var context = ensureContext(ctx);
            if (!context) {
              error('clearChatHistory لم يتمكن من الحصول على سياق HTMLx.');
              return;
            }
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var connection = Object.assign({}, data.connection || {});
              connection.lastError = null;
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  messages: [],
                  errors: [],
                  historyLoaded: true,
                  connection: connection
                })
              });
            });
            var store = runtime();
            store.historyRequested = false;
            try { context.set('data.newMessage', ''); } catch (_clearErr) {}
            setLoadingState('ready', { message: 'تم مسح الرسائل المعروضة.', historyLoaded: true });
            info('تم مسح الرسائل من الواجهة بناءً على طلب المستخدم.');
            scheduleScrollToBottom(true);
          }

          function messagePayload(ctx, event) {
            var context = ensureContext(ctx, event);
            if (!context) {
              error('messagePayload فشل في الحصول على سياق صالح.');
              return null;
            }
            var text = '';
            if (context.get) {
              try { text = context.get('data.newMessage') || ''; } catch (getError) { text = ''; }
            }
            if (typeof text !== 'string') {
              text = '';
            }
            var draftFromEvent = readDraftFromEvent(event);
            if (!text.trim() && typeof draftFromEvent === 'string' && draftFromEvent) {
              text = draftFromEvent;
              if (context.set) {
                try { context.set('data.newMessage', draftFromEvent); } catch (syncError) { debug('تعذر مزامنة قيمة الرسالة من الحدث مع الحالة.', { error: syncError }); }
              }
            }
            var value = text.trim();
            if (!value) {
              warn('محاولة إرسال رسالة فارغة تم تجاهلها.');
              return null;
            }
            var username = context.get ? context.get('data.username') : '';
            if (!username) {
              username = generateGuestName();
              context.set('data.username', username);
            }
            var clientMessageId = 'msg-' + Date.now().toString(36) + '-' + Math.random().toString(16).slice(2, 8);
            var keyId = '';
            if (context.get) {
              try { keyId = context.get('data.messageKeyId') || ''; } catch (_keyErr) { keyId = ''; }
            }
            if (typeof keyId !== 'string' || !keyId.trim()) {
              var cfg = config();
              keyId = cfg.keyId || 'chat:demo:plaintext';
            } else {
              keyId = keyId.trim();
            }
            if (context.set) {
              try { context.set('data.messageKeyId', keyId); } catch (_persistErr) {}
            }
            var payload = {
              user: username,
              text: value,
              clientMessageId: clientMessageId,
              keyId: keyId
            };
            debug('تم تحضير الحمولة الخاصة بإرسال الرسالة.', payload);
            return payload;
          }

          function sendMessage(event, ctx) {
            if (event && typeof event.preventDefault === 'function') {
              event.preventDefault();
            }
            var context = ensureContext(ctx, event);
            if (!context) {
              error('sendMessage لم يتمكن من الحصول على سياق HTMLx.');
              return;
            }
            var payload = messagePayload(context, event);
            if (!payload) {
              warn('sendMessage لم يحصل على حمولة صالحة، لن يتم الإرسال.');
              return;
            }
            var socket = connectToChat(context);
            if (!socket) {
              recordError('ws_missing', 'تعذر الوصول إلى اتصال WebSocket لإرسال الرسالة.', null, { connection: true });
              return;
            }
            applyIncomingMessage(null, {
              clientMessageId: payload.clientMessageId,
              username: payload.user,
              text: payload.text,
              pending: true,
              createdAt: new Date().toISOString(),
              metadata: { clientMessageId: payload.clientMessageId, username: payload.user }
            });
            try {
              var messageData = {
                ciphertext: payload.text,
                keyId: payload.keyId,
                metadata: {
                  username: payload.user,
                  clientMessageId: payload.clientMessageId,
                  via: 'htmlx-demo'
                }
              };
              var cfg = config();
              var sendPayload = {
                type: 'chat:send',
                conversationId: cfg.conversationId,
                data: messageData
              };
              var sendResult = safeSend(socket, sendPayload);
              if (sendResult.ok) {
                info('تم إرسال الرسالة إلى الخادم.', { clientMessageId: payload.clientMessageId });
              } else {
                reportSendFailure(sendResult, sendPayload, 'chat:send');
                applyIncomingMessage(null, {
                  clientMessageId: payload.clientMessageId,
                  username: payload.user,
                  text: payload.text,
                  pending: false,
                  failed: true,
                  createdAt: new Date().toISOString(),
                  metadata: { clientMessageId: payload.clientMessageId, username: payload.user }
                });
              }
            } catch (sendError) {
              recordError('send_failed', 'تعذر إرسال الرسالة إلى الخادم.', sendError);
              applyIncomingMessage(null, {
                clientMessageId: payload.clientMessageId,
                username: payload.user,
                text: payload.text,
                pending: false,
                failed: true,
                createdAt: new Date().toISOString(),
                metadata: { clientMessageId: payload.clientMessageId, username: payload.user }
              });
            }
            context.set('data.newMessage', '');
          }

          function connectionClass(connection) {
            if (!connection) return 'text-slate-300';
            switch (connection.status) {
              case 'connected':
                return 'text-emerald-400';
              case 'error':
                return 'text-rose-400';
              case 'disconnected':
                return 'text-amber-300';
              default:
                return 'text-sky-300';
            }
          }

          function formatChatTime(value, includeSeconds, ctx) {
            if (!value) { return ''; }
            var date = value instanceof Date ? value : new Date(value);
            if (!date || isNaN(date.getTime())) { return ''; }
            var options = { hour: '2-digit', minute: '2-digit' };
            if (includeSeconds) { options.second = '2-digit'; }
            try {
              return date.toLocaleTimeString('ar-EG', options);
            } catch (formatError) {
              warn('تعذر تنسيق الطابع الزمني لواجهة الدردشة.', { value: value, includeSeconds: includeSeconds, error: formatError });
              return '';
            }
          }

          function loadingHint(state) {
            var data = state && state.data ? state.data : {};
            var message = data.loadingMessage;
            if (typeof message === 'string' && message.trim()) {
              return message.trim();
            }
            var status = typeof data.loadingState === 'string' ? data.loadingState.trim() : 'idle';
            switch (status) {
              case 'connecting':
                return 'جارٍ الاتصال بخادم الدردشة...';
              case 'connected':
                return 'جارٍ تحميل المحادثة...';
              case 'reconnecting':
                return 'جارٍ إعادة الاتصال واسترجاع البيانات...';
              case 'error':
                return 'تعذر الاتصال مؤقتًا. سنحاول مجددًا حالًا.';
              default:
                return 'جارٍ تهيئة المحادثة...';
            }
          }

          function __init__(app, helpers) {
            var store = runtime();
            store.app = helpers && helpers.app ? helpers.app : app;
            if (store.app) {
              var agent = htmlxAgent();
              if (agent && typeof agent.ContextAdapter === 'function') {
                store.lastCtx = agent.ContextAdapter(store.app);
              }
            }
            Promise.resolve()
              .then(async function () {
                var session = await restoreSession(store.lastCtx);
                var preferredRoom = session && session.conversationId ? session.conversationId : null;
                await loadChatRooms(store.lastCtx, preferredRoom);
                var ctxRef = store.lastCtx || ensureContext(store.lastCtx);
                var hasValidToken = session && session.token && session.expiresAt && session.expiresAt - Date.now() > 5000;
                if (hasValidToken) {
                  if (ctxRef) {
                    try { ctxRef.set('data.joined', true); } catch (_err) {}
                    try { ctxRef.set('data.pinError', ''); } catch (_err) {}
                    try { ctxRef.set('data.lockExpiresAt', null); } catch (_err) {}
                  }
                  setConnectionStatus('connecting');
                  setLoadingState('connecting', { message: 'جارٍ تهيئة اتصال الدردشة...', historyLoaded: false });
                  connectToChat(ctxRef || store.lastCtx);
                } else if (ctxRef) {
                  try { ctxRef.set('data.joined', false); } catch (_err) {}
                }
              })
              .catch(function (initError) {
                error('فشل التهيئة الأولية للدردشة.', initError);
              });
          }
        </script>
      </section>
    </template>

    <script>
      (function (window) {
        'use strict';
        var M = window.Mishkah;
        if (!M || !M.HTMLxAgent) {
          console.error('Mishkah HTMLx agent is required.');
          return;
        }
        var start = M.HTMLxAgent.make({ templateId: 'chat-app' });
        Promise.resolve(start).catch(function (error) {
          console.error('فشل تشغيل واجهة الدردشة HTMLx:', error);
        });
      })(window);
    </script>
  </body>
</html>
