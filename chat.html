<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>مشكاة — تجربة دردشة HTMLx</title>
    <script src="./mishkah-utils.js"></script>
    <script src="./mishkah.core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/acorn@8.15.0/dist/acorn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/acorn-walk@8.3.4/dist/walk.min.js"></script>
    <script>
      window.acornWalk = window.acornWalk || (window.acorn && window.acorn.walk);
    </script>
    <script src="./mishkah-htmlx.js"></script>
    <script src="./mishkah-ui.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Tajawal", "Cairo", system-ui;
        background: radial-gradient(circle at top, rgba(37, 99, 235, 0.12), transparent 65%),
          linear-gradient(180deg, rgba(30, 64, 175, 0.35), rgba(15, 23, 42, 0.92));
      }
    </style>
  </head>
  <body class="bg-slate-950 text-slate-100">
    <div id="app"></div>

    <template id="chat-app" data-namespace="chat.app">
      <script type="application/json" data-m-env>
        {
          "lang": "ar",
          "dir": "rtl",
          "theme": "dark",
          "twcss": { "auto": true }
        }
      </script>

      <script type="application/json" data-m-data data-m-path="head">
        {
          "title": "مشكاة — تجربة دردشة HTMLx"
        }
      </script>

      <script type="application/json" data-m-data data-m-path="data">
        {
          "joined": false,
          "username": "",
          "users": [],
          "messages": [],
          "newMessage": "",
          "conversationId": "demo:lobby",
          "topic": "chat:demo:lobby",
          "messageKeyId": "chat:demo:plaintext",
          "connection": {
            "status": "idle",
            "lastError": null,
            "user": null
          },
          "errors": []
        }
      </script>

      <section
        id="chat-shell"
        data-chat-root
        class="container mx-auto flex h-screen flex-col gap-6 px-4 py-6 lg:flex-row"
      >
        <div class="mx-auto w-full max-w-sm" x-if="!state.data.joined">
          <div class="rounded-2xl bg-slate-900/80 p-6 shadow-xl ring-1 ring-slate-800/50">
            <h1 class="mb-4 text-2xl font-bold text-slate-50">انضم إلى الدردشة</h1>
            <p class="mb-6 text-sm text-slate-400">
              اختر اسمًا مستعارًا للانضمام إلى قناة العرض التجريبية.
            </p>
            <div class="flex flex-col gap-4">
              <label class="text-sm text-slate-300">
                <span class="mb-2 inline-block text-xs text-slate-500">الاسم المستعار</span>
                <input
                  type="text"
                  class="w-full rounded-xl border border-slate-800 bg-slate-900/60 p-3 text-base focus:border-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-500/40"
                  placeholder="اكتب اسمك المستعار"
                  value="{state.data.username}"
                  oninput="handleUsernameInput(event, ctx)"
                />
              </label>
              <button
                type="button"
                class="rounded-xl bg-sky-600 p-3 text-center text-base font-semibold text-white shadow-lg shadow-sky-900/40 transition hover:bg-sky-500"
                onclick="joinChat(event, ctx)"
              >
                دخول الغرفة
              </button>
            </div>
          </div>
        </div>

        <div x-if="state.data.joined" class="flex h-full w-full flex-1 flex-col gap-4 lg:flex-row">
          <aside class="flex w-full flex-col gap-4 overflow-hidden rounded-2xl bg-slate-900/80 p-5 ring-1 ring-slate-800/60 lg:w-80">
            <header class="space-y-1">
              <h2 class="text-lg font-semibold text-slate-50">المحادثة الحالية</h2>
              <p class="text-xs text-slate-400">الموضوع: {state.data.topic}</p>
              <div class="text-xs text-slate-300">
                حالة الاتصال:
                <strong class="{connectionClass(state.data.connection)}">{state.data.connection.status}</strong>
              </div>
              <p x-if="state.data.connection.lastError" class="text-xs text-rose-300">
                آخر خطأ: {state.data.connection.lastError.message || state.data.connection.lastError.code}
              </p>
            </header>

            <section class="flex-1 overflow-y-auto">
              <h3 class="mb-2 text-sm font-semibold text-slate-200">المتصلون الآن</h3>
              <ul class="space-y-2 text-sm">
                <li
                  x-for="user, idx in state.data.users"
                  data-m-key="{user.id || idx}"
                  class="rounded-lg border border-slate-800/60 bg-slate-900/60 p-2 text-slate-200"
                >
                  {user.name || user}
                </li>
                <li x-if="!state.data.users.length" class="rounded-lg border border-slate-800/60 bg-slate-900/40 p-3 text-xs text-slate-500">
                  لا توجد أسماء بعد — سيظهر المشاركون بعد إرسال الرسائل.
                </li>
              </ul>
            </section>

            <footer class="space-y-2 text-xs text-slate-400">
              <p>
                المستخدم الحالي:
                <strong class="text-slate-200">{state.data.connection.user ? state.data.connection.user.name : state.data.username || 'ضيف'}</strong>
              </p>
              <p x-if="state.data.connection.status !== 'connected'" class="text-slate-500">
                يجري الحفاظ على الاتصال تلقائيًا مع الخادم.
              </p>
            </footer>
          </aside>

          <main class="flex h-full flex-1 flex-col gap-4 overflow-hidden">
            <section class="flex-1 overflow-hidden rounded-2xl bg-slate-900/80 p-5 ring-1 ring-slate-800/60">
              <div class="mb-4 flex items-center justify-between text-xs text-slate-400">
                <span>القناة: {state.data.topic}</span>
                <span>{formatChatTime(state.data.messages.length ? state.data.messages[state.data.messages.length - 1].createdAt : null, false, ctx) || '—'}</span>
              </div>
              <div class="flex h-full flex-col gap-3 overflow-y-auto pr-1">
                <article
                  x-for="msg, msgIdx in state.data.messages"
                  data-m-key="{msg.clientMessageId || msg.id || msgIdx}"
                  class="rounded-xl border border-slate-800/60 bg-slate-900/60 p-3"
                >
                  <header class="mb-1 flex items-start justify-between gap-2 text-xs text-slate-400">
                    <strong class="text-sm font-semibold text-sky-300">{msg.user || 'مجهول'}</strong>
                    <span>{formatChatTime(msg.createdAt, false, ctx)}</span>
                  </header>
                  <p class="text-sm leading-relaxed text-slate-100">{msg.text}</p>
                  <p x-if="msg.pending" class="mt-2 text-xs text-amber-300">جاري الإرسال...</p>
                  <p x-if="msg.failed" class="mt-2 text-xs text-rose-400">تعذر تسليم الرسالة.</p>
                </article>
                <p x-if="!state.data.messages.length" class="rounded-xl border border-slate-800/60 bg-slate-900/40 p-4 text-sm text-slate-500">
                  لا توجد رسائل حتى الآن. كن أول من يبدأ الحديث!
                </p>
              </div>
            </section>

            <form class="flex flex-col gap-3 rounded-2xl bg-slate-900/80 p-4 ring-1 ring-slate-800/60 lg:flex-row" onsubmit="sendMessage(event, ctx)">
              <label class="flex-1">
                <span class="mb-2 inline-block text-xs text-slate-500">نص الرسالة</span>
                <input
                  type="text"
                  class="w-full rounded-xl border border-slate-800/60 bg-slate-900/60 p-3 text-base text-slate-100 placeholder:text-slate-500 focus:border-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-500/40"
                  placeholder="اكتب رسالتك..."
                  value="{state.data.newMessage}"
                  oninput="handleMessageInput(event, ctx)"
                  data-chat-draft
                />
              </label>
              <div class="flex items-end justify-end gap-3">
                <button
                  type="button"
                  class="rounded-xl border border-slate-800/60 bg-slate-900/40 px-4 py-3 text-sm font-semibold text-slate-200 transition hover:border-slate-700"
                  onclick="generateGuestAlias(ctx)"
                >
                  اسم ضيف جديد
                </button>
                <button
                  type="submit"
                  class="rounded-xl bg-emerald-600 px-6 py-3 text-base font-semibold text-white shadow-lg shadow-emerald-900/40 transition hover:bg-emerald-500"
                >
                  إرسال
                </button>
              </div>
            </form>

            <section x-if="state.data.errors.length" class="rounded-2xl bg-rose-950/40 p-4 ring-1 ring-rose-900/30">
              <h3 class="mb-3 text-sm font-semibold text-rose-200">الأخطاء الأخيرة</h3>
              <ul class="space-y-3 text-sm">
                <li
                  x-for="err, idx in state.data.errors"
                  data-m-key="{err.id || idx}"
                  class="rounded-xl border border-rose-900/40 bg-rose-900/10 p-3"
                >
                  <div class="flex items-center justify-between text-xs text-rose-200">
                    <strong>{err.code}</strong>
                    <span>{formatChatTime(err.ts, true, ctx)}</span>
                  </div>
                  <p class="mt-1 text-sm text-rose-100">{err.message}</p>
                  <ul x-if="err.details && err.details.length" class="mt-2 list-disc space-y-1 pl-4 text-xs text-rose-200">
                    <li
                      x-for="detail, detailIdx in err.details"
                      data-m-key="{detailIdx + '-' + (detail || 'detail')}"
                    >
                      {detail}
                    </li>
                  </ul>
                </li>
              </ul>
            </section>
          </main>
        </div>

        <script data-for="chat-shell">
          function createRuntime() {
            return {
              app: null,
              socket: null,
              lastCtx: null,
              subscriptionRequested: false,
              historyRequested: false,
              authToken: null,
              authTokenMeta: null,
              authenticated: false,
              authenticating: false,
              authPromise: null,
              config: {
                url: 'wss://ws.mas.com.eg',
                conversationId: 'demo:lobby',
                topic: 'chat:demo:lobby',
                historyLimit: 50,
                maxErrors: 10,
                tokenEndpoint: null,
                keyId: 'chat:demo:plaintext'
              }
            };
          }

          function runtime() {
            if (!runtime.__instance) {
              runtime.__instance = createRuntime();
            }
            return runtime.__instance;
          }

          function host() {
            return (typeof window !== 'undefined' && window.Mishkah) ? window.Mishkah : null;
          }

          function htmlxAgent() {
            var M = host();
            return M && M.HTMLx ? M.HTMLx.Agent : null;
          }

          function utilsHost() {
            var M = host();
            return (M && M.utils) ? M.utils : {};
          }

          function log(level, message, payload) {
            if (typeof console === 'undefined') return;
            var logger = typeof console[level] === 'function' ? console[level] : console.log;
            var prefix = '%c[Chat Debug]%c ';
            var style = 'color:#38bdf8;font-weight:bold;';
            var reset = 'color:inherit;';
            try {
              if (payload !== undefined) {
                logger.call(console, prefix + message, style, reset, payload);
              } else {
                logger.call(console, prefix + message, style, reset);
              }
            } catch (error) {
              console.error(prefix + 'فشل تسجيل الحمولة debug payload', style, reset, error);
            }
          }

          function info(message, payload) { log('info', message, payload); }
          function warn(message, payload) { log('warn', message, payload); }
          function error(message, payload) { log('error', message, payload); }
          function debug(message, payload) { log('debug', message, payload); }

          function config() {
            var store = runtime();
            if (!store.config) {
              store.config = {
                url: 'wss://ws.mas.com.eg',
                conversationId: 'demo:lobby',
                topic: 'chat:demo:lobby',
                historyLimit: 50,
                maxErrors: 10,
                tokenEndpoint: null,
                keyId: 'chat:demo:plaintext'
              };
            }
            return store.config;
          }

          function ensureContext(ctx, event) {
            var store = runtime();
            var input = ctx;
            if (!input && event) {
              if (event.detail && event.detail.ctx) {
                input = event.detail.ctx;
              } else if (event.target) {
                input = event.target;
              } else if (event.currentTarget) {
                input = event.currentTarget;
              }
            }
            if (!input && store.lastCtx) {
              return store.lastCtx;
            }
            if (!input && store.app) {
              input = store.app;
            }
            if (!input) {
              error('ensureContext لم يتمكن من تحديد سياق صالح.');
              return null;
            }
            if (typeof input.get === 'function' && typeof input.set === 'function') {
              store.lastCtx = input;
              return input;
            }
            var agent = htmlxAgent();
            if (!agent || typeof agent.ContextAdapter !== 'function') {
              error('ContextAdapter غير متاح.');
              return null;
            }
            var adapted = agent.ContextAdapter(input);
            if (!adapted && store.app && input !== store.app) {
              adapted = agent.ContextAdapter(store.app);
            }
            if (!adapted && event) {
              var fallbackTarget = event.currentTarget || event.target || null;
              if (fallbackTarget && fallbackTarget !== input) {
                adapted = agent.ContextAdapter(fallbackTarget);
              }
            }
            if (!adapted) {
              error('فشل ContextAdapter في إرجاع سياق صالح.');
              return null;
            }
            store.lastCtx = adapted;
            return adapted;
          }

          function mutateState(updater) {
            var store = runtime();
            var target = store.app || store.lastCtx;
            if (!target) return false;
            if (typeof target.setState === 'function') {
              target.setState(updater);
              return true;
            }
            if (typeof target.set === 'function') {
              try {
                var state = target.getState ? target.getState() : {};
                var next = updater(state);
                target.setState(function () { return next; });
                return true;
              } catch (_err) {}
            }
            return false;
          }

          function readState() {
            var store = runtime();
            var target = store.app || store.lastCtx;
            if (target && typeof target.getState === 'function') {
              return target.getState();
            }
            return {};
          }

          function deriveHttpUrl(url) {
            if (!url) return null;
            try {
              var parsed = new URL(url, window.location.href);
              if (parsed.protocol === 'wss:') parsed.protocol = 'https:';
              if (parsed.protocol === 'ws:') parsed.protocol = 'http:';
              parsed.hash = '';
              return parsed.toString().replace(/\/+$/, '');
            } catch (parseError) {
              warn('تعذر تحليل رابط WebSocket لتحويله إلى HTTP.', { url: url, error: parseError });
              return null;
            }
          }

          function resolveTokenEndpoint() {
            var cfg = config();
            if (cfg.tokenEndpoint) return cfg.tokenEndpoint;
            var base = deriveHttpUrl(cfg.url);
            if (!base) return null;
            return base.replace(/\/+$/, '') + '/api/demo/guest-token';
          }

          async function ensureAuthToken(context) {
            var store = runtime();
            if (store.authenticated && store.authToken) {
              return store.authToken;
            }
            if (store.authenticating && store.authPromise) {
              return store.authPromise;
            }
            var cfg = config();
            var endpoint = resolveTokenEndpoint();
            if (!endpoint) {
              store.authenticated = false;
              throw new Error('لم يتم تحديد نقطة نهاية للرمز.');
            }
            ensureContext(context);
            var fetcher = (utilsHost().Net && utilsHost().Net.ajax) ? utilsHost().Net.ajax : null;
            if (!fetcher) {
              store.authenticated = false;
              throw new Error('أداة الشبكة غير متاحة للحصول على رمز الضيف.');
            }
            var contextRef = ensureContext(context);
            var preferredName = '';
            if (contextRef && typeof contextRef.get === 'function') {
              try { preferredName = contextRef.get('data.username') || ''; } catch (_err) { preferredName = ''; }
            }
            if (!preferredName) {
              preferredName = generateGuestName();
              if (contextRef && typeof contextRef.set === 'function') {
                try { contextRef.set('data.username', preferredName); } catch (_syncErr) {}
              }
            }
            var tokenBody = {
              conversationId: cfg.conversationId || 'demo:lobby'
            };
            if (preferredName) {
              tokenBody.name = preferredName;
            }
            store.authenticating = true;
            store.authPromise = fetcher(endpoint, {
              method: 'POST',
              responseType: 'json',
              timeout: 8000,
              body: tokenBody
            })
              .then(function (response) {
                if (!response || !response.token) {
                  throw new Error('استجابة الرمز غير صالحة.');
                }
                store.authToken = response.token;
                store.authTokenMeta = response;
                store.authenticated = true;
                var normalizedUser = normalizeUserInfo(response.user);
                if (normalizedUser) {
                  mutateState(function (prev) {
                    var base = prev || {};
                    var data = base.data || {};
                    var users = Array.isArray(data.users) ? data.users.slice() : [];
                    if (normalizedUser.name && users.indexOf(normalizedUser.name) === -1) {
                      users.push(normalizedUser.name);
                    }
                    return Object.assign({}, base, {
                      data: Object.assign({}, data, {
                        users: users,
                        connection: Object.assign({}, data.connection || {}, { user: normalizedUser })
                      })
                    });
                  });
                }
                return response.token;
              })
              .catch(function (fetchError) {
                store.authenticated = false;
                store.authToken = null;
                store.authTokenMeta = null;
                throw fetchError;
              })
              .finally(function () {
                store.authenticating = false;
                store.authPromise = null;
              });
            return store.authPromise;
          }

          function extractError(meta) {
            if (!meta) return null;
            if (meta instanceof Error) {
              return { code: meta.code || 'error', message: meta.message };
            }
            if (typeof meta === 'string') {
              return { code: 'error', message: meta };
            }
            if (meta.code || meta.message || meta.reason) {
              return {
                code: meta.code || meta.status || 'error',
                message: meta.message || meta.reason || String(meta.code || 'error')
              };
            }
            if (meta.error) {
              return extractError(meta.error);
            }
            if (meta.ts && meta.code && meta.message) {
              return { code: meta.code, message: meta.message, ts: meta.ts };
            }
            try {
              return { code: meta.code || 'error', message: JSON.stringify(meta) };
            } catch (_err) {
              return { code: 'error', message: String(meta) };
            }
          }

          function extractErrorDetails(meta) {
            if (!meta) return [];
            var candidates = [];
            if (Array.isArray(meta.details)) candidates = candidates.concat(meta.details);
            if (Array.isArray(meta.errors)) candidates = candidates.concat(meta.errors);
            if (Array.isArray(meta.issues)) candidates = candidates.concat(meta.issues);
            if (meta.meta) {
              if (Array.isArray(meta.meta.details)) candidates = candidates.concat(meta.meta.details);
              if (Array.isArray(meta.meta.errors)) candidates = candidates.concat(meta.meta.errors);
              if (Array.isArray(meta.meta.issues)) candidates = candidates.concat(meta.meta.issues);
            }
            if (meta.error) {
              var nested = extractErrorDetails(meta.error);
              if (nested.length) candidates = candidates.concat(nested);
            }
            return candidates
              .map(function (item) {
                if (!item) return null;
                if (typeof item === 'string') return item.trim();
                if (item instanceof Error) return (item.message || '').trim();
                var parts = [];
                if (Array.isArray(item.path) && item.path.length) parts.push(item.path.join('.'));
                if (item.message) {
                  parts.push(item.message);
                } else if (item.code) {
                  parts.push(item.code);
                }
                if (!parts.length && typeof item === 'object') {
                  try {
                    return JSON.stringify(item);
                  } catch (_err) {
                    return String(item);
                  }
                }
                return parts.join(': ').trim();
              })
              .filter(function (value, index, all) {
                if (!value) return false;
                return all.indexOf(value) === index;
              });
          }

          function recordError(code, message, meta, options) {
            var entry = {
              id: 'err-' + Date.now().toString(36) + '-' + Math.random().toString(16).slice(2, 8),
              code: code || 'unknown',
              message: (message || '').trim() || 'حدث خطأ غير معروف.',
              ts: new Date().toISOString(),
              meta: meta || null,
              details: extractErrorDetails(meta)
            };
            warn(entry.message, { code: entry.code, meta: meta });
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var errors = Array.isArray(data.errors) ? data.errors.slice() : [];
              errors.unshift(entry);
              var cfg = config();
              if (errors.length > cfg.maxErrors) {
                errors = errors.slice(0, cfg.maxErrors);
              }
              var connection = Object.assign({}, data.connection || {});
              if (options && options.connection) {
                connection.lastError = {
                  code: entry.code,
                  message: entry.message,
                  ts: entry.ts,
                  details: entry.details
                };
              }
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  errors: errors,
                  connection: connection
                })
              });
            });
            return entry;
          }

          function normalizeUserInfo(rawUser) {
            if (!rawUser) return null;
            var claims = rawUser.claims || {};
            var name = rawUser.name || claims.name || claims.username || claims.displayName || '';
            var identifier = rawUser.id || claims.sub || claims.id || null;
            if (!name && identifier) {
              name = identifier;
            }
            return {
              id: identifier,
              name: name || '',
              roles: Array.isArray(rawUser.roles) ? rawUser.roles.slice() : []
            };
          }

          function normalizeMessage(raw, hints) {
            var source = raw || {};
            var fallback = hints || {};
            var metadata = source.metadata || fallback.metadata || {};
            var username = metadata.username || metadata.user || fallback.username || source.user || '';
            var text = source.ciphertext || source.text || fallback.text || '';
            if (text != null && typeof text !== 'string') {
              try { text = String(text); } catch (_err) { text = ''; }
            }
            var createdAt = source.createdAt || source.ts || fallback.createdAt || new Date().toISOString();
            var clientMessageId = metadata.clientMessageId || fallback.clientMessageId || null;
            var id = source.id || fallback.id || null;
            var failed = Boolean(fallback.failed);
            var pending = Boolean(fallback.pending) && !source.id && !failed;
            if (!text && !pending && !failed) {
              return null;
            }
            return {
              id: id,
              clientMessageId: clientMessageId,
              user: username || 'مجهول',
              text: text,
              createdAt: createdAt,
              pending: pending,
              failed: failed
            };
          }

          function applyIncomingMessage(raw, hints) {
            var normalized = normalizeMessage(raw, hints || {});
            if (!normalized) {
              return;
            }
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var messages = Array.isArray(data.messages) ? data.messages.slice() : [];
              var idx = -1;
              if (normalized.clientMessageId) {
                idx = messages.findIndex(function (msg) {
                  return msg && msg.clientMessageId === normalized.clientMessageId;
                });
              }
              if (idx === -1 && normalized.id) {
                idx = messages.findIndex(function (msg) {
                  return msg && msg.id === normalized.id;
                });
              }
              if (idx !== -1) {
                messages[idx] = Object.assign({}, messages[idx], normalized, { pending: normalized.pending, failed: normalized.failed });
              } else {
                messages.push(normalized);
              }
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  messages: messages
                })
              });
            });
          }

          function setConnectionStatus(status, meta) {
            var normalizedError = status === 'error' ? extractError(meta) : extractError(meta && meta.error);
            var resetError = status === 'connected' || (meta && meta.resetError);
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var connection = Object.assign({}, data.connection || {});
              connection.status = status;
              if (resetError) {
                connection.lastError = null;
              } else if (normalizedError) {
                connection.lastError = normalizedError;
              }
              if (meta && Object.prototype.hasOwnProperty.call(meta, 'user')) {
                connection.user = meta.user;
              } else if (!Object.prototype.hasOwnProperty.call(connection, 'user')) {
                connection.user = (data.connection && data.connection.user) || null;
              }
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  connection: connection
                })
              });
            });
          }

          function resetAuthState(options) {
            var store = runtime();
            var settings = options || {};
            store.authenticated = false;
            store.subscriptionRequested = false;
            store.historyRequested = false;
            store.authenticating = false;
            store.authPromise = null;
            if (settings.clearToken) {
              store.authToken = null;
              store.authTokenMeta = null;
              if (store.socket && store.socket.auth) {
                store.socket.auth.token = null;
              }
              mutateState(function (prev) {
                var base = prev || {};
                var data = base.data || {};
                var connection = Object.assign({}, data.connection || {});
                connection.user = null;
                return Object.assign({}, base, {
                  data: Object.assign({}, data, { connection: connection })
                });
              });
            }
          }

          function handleAckMessage(message) {
            var store = runtime();
            if (!message) {
              return;
            }
            if (message.event === 'auth') {
              store.authenticated = true;
              store.subscriptionRequested = false;
              store.historyRequested = false;
              var normalizedUser = normalizeUserInfo(message.user);
              if (normalizedUser) {
                mutateState(function (prev) {
                  var base = prev || {};
                  var data = base.data || {};
                  var users = Array.isArray(data.users) ? data.users.slice() : [];
                  if (normalizedUser.name && users.indexOf(normalizedUser.name) === -1) {
                    users.push(normalizedUser.name);
                  }
                  return Object.assign({}, base, {
                    data: Object.assign({}, data, {
                      users: users,
                      connection: Object.assign({}, data.connection || {}, { user: normalizedUser })
                    })
                  });
                });
              }
              setConnectionStatus('connected', { resetError: true, user: normalizedUser || null });
              subscribeToChat();
              requestHistory(true);
              return;
            }
            if (message.event === 'subscribe') {
              info('تم تأكيد الاشتراك في موضوع الدردشة.', { topic: message.topic });
              return;
            }
            if (message.event === 'chat:send') {
              if (message.ok === false || message.error) {
                var err = extractError(message.error || message.meta || { code: 'send_failed', message: 'تعذر إرسال الرسالة.' });
                recordError(err.code || 'send_failed', err.message || 'تعذر إرسال الرسالة.', message, { connection: message.error && message.error.code === 'unauthorized_pub' });
                applyIncomingMessage(null, {
                  clientMessageId: message.metadata && message.metadata.clientMessageId,
                  username: message.metadata && message.metadata.username,
                  text: message.data && (message.data.ciphertext || message.data.text),
                  pending: false,
                  failed: true,
                  createdAt: new Date().toISOString(),
                  metadata: message.metadata || {}
                });
                return;
              }
              if (message.message) {
                applyIncomingMessage(message.message, {});
              }
            }
          }

          function handlePublishMessage(message) {
            var cfg = config();
            if (!message || message.topic !== cfg.topic) {
              return;
            }
            applyIncomingMessage(message.data || {}, {});
          }

          function handleHistoryMessage(message) {
            var cfg = config();
            if (!message || message.conversationId !== cfg.conversationId) {
              return;
            }
            var list = Array.isArray(message.messages) ? message.messages : [];
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var users = Array.isArray(data.users) ? data.users.slice() : [];
              var normalizedMessages = list
                .map(function (item) { return normalizeMessage(item, {}); })
                .filter(Boolean)
                .sort(function (a, b) { return new Date(a.createdAt || 0) - new Date(b.createdAt || 0); });
              var userSet = new Set(users);
              normalizedMessages.forEach(function (msg) {
                if (msg.user) {
                  userSet.add(msg.user);
                }
              });
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  messages: normalizedMessages,
                  users: Array.from(userSet)
                })
              });
            });
          }

          function handleServerError(message) {
            var code = message && message.code ? message.code : 'server_error';
            var text = message && message.message ? message.message : 'أبلغ الخادم عن خطأ غير معروف.';
            recordError(code, text, message, { connection: true });
            setConnectionStatus('error', { code: code, message: text });
            var store = runtime();
            if (code === 'unauthorized_sub' || code === 'topic_not_allowed') {
              store.subscriptionRequested = false;
            }
            if (code === 'unauthorized_pub') {
              store.authenticated = false;
            }
            if (code === 'auth_failed' || code === 'unauthorized' || code === 'token_required' || code === 'unauthorized_pub') {
              resetAuthState({ clearToken: true });
              if (store.socket && typeof store.socket.close === 'function') {
                try { store.socket.close(4401, 'reauth'); } catch (_closeErr) {}
              }
            }
          }

          function handleSocketMessage(message) {
            var store = runtime();
            if (!message) {
              return;
            }
            if (typeof message === 'string') {
              try { message = JSON.parse(message); } catch (_err) { return; }
            }
            debug('رسالة WebSocket واردة', message);
            switch (message.type) {
              case 'hello':
                resetAuthState({ clearToken: true });
                if (store.socket && store.socket.auth) {
                  store.socket.auth.token = null;
                }
                (async function () {
                  try {
                    var token = await ensureAuthToken(store.lastCtx);
                    if (store.socket && store.socket.state === 'open') {
                      store.socket.send({ type: 'auth', data: { token: token } });
                    }
                  } catch (reauthErr) {
                    recordError('auth_retry_failed', 'تعذر استكمال المصادقة التلقائية بعد رسالة hello.', reauthErr, { connection: true });
                  }
                })();
                break;
              case 'ack':
                handleAckMessage(message);
                break;
              case 'publish':
                handlePublishMessage(message);
                break;
              case 'chat:history':
                handleHistoryMessage(message);
                break;
              case 'error':
                handleServerError(message);
                break;
              case 'pong':
                break;
              default:
                debug('رسالة غير معالجة من الخادم', message);
            }
          }

          function attachSocketHandlers(socket) {
            var store = runtime();
            if (!socket || socket.__chatHandlersAttached) {
              return;
            }
            socket.__chatHandlersAttached = true;
            socket.on('open', function () {
              var cfg = config();
              info('تم فتح اتصال WebSocket بنجاح.', { topic: cfg.topic });
              resetAuthState();
              setConnectionStatus('connected', { resetError: true });
            });
            socket.on('close', function (evt) {
              warn('تم إغلاق اتصال WebSocket.', { code: evt && evt.code, reason: evt && evt.reason });
              resetAuthState();
              setConnectionStatus('disconnected', { error: evt && { code: evt.code || 'closed', message: evt.reason || '' } });
            });
            socket.on('error', function (err) {
              recordError('socket_error', 'حدث خطأ في قناة WebSocket.', err, { connection: true });
              setConnectionStatus('error', err);
            });
            socket.on('state', function (state) {
              debug('تغيرت حالة WebSocket', { state: state });
            });
            socket.on('message', function (msg) {
              handleSocketMessage(msg);
            });
          }

          function syncConfigWithState() {
            var state = readState();
            if (!state || !state.data) {
              return;
            }
            var data = state.data;
            var cfg = config();
            if (typeof data.conversationId === 'string' && data.conversationId) {
              cfg.conversationId = data.conversationId;
            }
            if (typeof data.topic === 'string' && data.topic) {
              cfg.topic = data.topic;
            } else if (cfg.conversationId) {
              cfg.topic = 'chat:' + cfg.conversationId;
            }
            if (typeof data.messageKeyId === 'string' && data.messageKeyId.trim()) {
              cfg.keyId = data.messageKeyId.trim();
            }
            mutateState(function (prev) {
              var base = prev || {};
              var prevData = base.data || {};
              if (prevData.topic === cfg.topic && prevData.conversationId === cfg.conversationId) {
                return base;
              }
              return Object.assign({}, base, {
                data: Object.assign({}, prevData, {
                  topic: cfg.topic,
                  conversationId: cfg.conversationId
                })
              });
            });
          }

          function requestHistory(force) {
            var store = runtime();
            if (!store.socket || store.socket.state !== 'open') {
              return;
            }
            if (store.historyRequested && !force) {
              return;
            }
            if (!store.authenticated) {
              debug('تم تجاهل طلب السجل قبل اكتمال المصادقة.');
              return;
            }
            var cfg = config();
            try {
              store.socket.send({
                type: 'chat:history',
                conversationId: cfg.conversationId,
                limit: cfg.historyLimit
              });
              store.historyRequested = true;
              info('تم طلب سجل الرسائل.', { limit: cfg.historyLimit });
            } catch (historyError) {
              store.historyRequested = false;
              recordError('history_failed', 'تعذر طلب سجل الرسائل من الخادم.', historyError);
            }
          }

          function subscribeToChat() {
            var store = runtime();
            if (!store.socket || store.socket.state !== 'open') {
              return;
            }
            if (!store.authenticated) {
              debug('تم تجاهل الاشتراك قبل اكتمال المصادقة.');
              return;
            }
            if (store.subscriptionRequested) {
              return;
            }
            try {
              var cfg = config();
              store.socket.send({
                type: 'subscribe',
                topic: cfg.topic,
                conversationId: cfg.conversationId
              });
              store.subscriptionRequested = true;
              info('تم إرسال طلب الاشتراك في موضوع الدردشة.', { topic: cfg.topic });
            } catch (sendError) {
              store.subscriptionRequested = false;
              recordError('subscribe_failed', 'تعذر إرسال طلب الاشتراك في الدردشة.', sendError, { connection: true });
              setConnectionStatus('error', sendError);
            }
          }

          function connectToChat(ctx) {
            var store = runtime();
            var context = ensureContext(ctx || store.lastCtx);
            if (!context) {
              error('connectToChat لم يتمكن من تهيئة سياق HTMLx صالح.');
              return null;
            }
            syncConfigWithState();
            var utils = utilsHost();
            if (!utils || typeof utils.WebSocketX !== 'function') {
              recordError('wsx_unavailable', 'Mishkah.utils.WebSocketX غير متاح.', null, { connection: true });
              return null;
            }
            if (!store.socket) {
              try {
                var cfg = config();
                store.socket = new utils.WebSocketX(cfg.url, {
                  autoReconnect: true,
                  backoff: { min: 1000, max: 10000, factor: 1.6 },
                  ping: { interval: 20000, send: { type: 'ping' }, expect: { type: 'pong' }, timeout: 8000 },
                  auth: {
                    param: 'token',
                    sendOnUrl: true,
                    getToken: async function () {
                      try {
                        return await ensureAuthToken(store.lastCtx || context);
                      } catch (tokenError) {
                        recordError('token_failed', 'تعذر الحصول على رمز الضيف من الخادم.', tokenError, { connection: true });
                        throw tokenError;
                      }
                    }
                  }
                });
              } catch (ctorError) {
                recordError('wsx_init_failed', 'تعذر إنشاء عميل WebSocket.', ctorError, { connection: true });
                return null;
              }
              attachSocketHandlers(store.socket);
            }
            if (store.socket.state === 'open') {
              setConnectionStatus('connected', { resetError: true });
              if (store.authenticated) {
                subscribeToChat();
                requestHistory(false);
              } else {
                (async function () {
                  try {
                    var token = await ensureAuthToken(store.lastCtx || context);
                    if (store.socket && store.socket.state === 'open') {
                      store.socket.send({ type: 'auth', data: { token: token } });
                    }
                  } catch (tokenError) {
                    recordError('auth_failed', 'تعذر المصادقة مع خادم الدردشة.', tokenError, { connection: true });
                  }
                })();
              }
            }
            return store.socket;
          }

          function handleUsernameInput(event, ctx) {
            var context = ensureContext(ctx, event);
            if (!context || !event) {
              error('handleUsernameInput استقبل سياقًا أو حدثًا غير صالح.', { event: event });
              return;
            }
            var value = '';
            if (event.target && typeof event.target.value === 'string') {
              value = event.target.value;
            }
            context.set('data.username', value);
          }

          function joinChat(event, ctx) {
            var context = ensureContext(ctx, event);
            if (!context) {
              error('joinChat لم يتمكن من الحصول على سياق HTMLx.');
              return;
            }
            var username = context.get('data.username');
            if (!username) {
              username = generateGuestName();
              context.set('data.username', username);
            }
            context.set('data.joined', true);
            connectToChat(context);
          }

          function handleMessageInput(event, ctx) {
            var context = ensureContext(ctx, event);
            if (!context || !event) {
              error('handleMessageInput استقبل سياقًا أو حدثًا غير صالح.', { event: event });
              return;
            }
            var value = '';
            if (event.target && typeof event.target.value === 'string') {
              value = event.target.value;
            }
            context.set('data.newMessage', value);
          }

          function hasDraftAttribute(node) {
            return !!(node && typeof node.hasAttribute === 'function' && node.hasAttribute('data-chat-draft'));
          }

          function findDraftInput(source) {
            if (hasDraftAttribute(source)) {
              return source;
            }
            if (source && typeof source.closest === 'function') {
              var direct = source.closest('[data-chat-draft]');
              if (direct) {
                return direct;
              }
              var form = source.closest('form');
              if (form && typeof form.querySelector === 'function') {
                var fromForm = form.querySelector('[data-chat-draft]');
                if (fromForm) {
                  return fromForm;
                }
              }
            }
            if (typeof document !== 'undefined' && document) {
              var active = document.activeElement;
              if (hasDraftAttribute(active)) {
                return active;
              }
              if (typeof document.querySelector === 'function') {
                var fallback = document.querySelector('[data-chat-draft]');
                if (fallback) {
                  return fallback;
                }
              }
            }
            return null;
          }

          function readDraftFromEvent(event) {
            var source = null;
            if (event && event.target) {
              source = event.target;
            } else if (event && event.currentTarget) {
              source = event.currentTarget;
            }
            var input = findDraftInput(source);
            if (input && typeof input.value === 'string') {
              return input.value;
            }
            return '';
          }

          function generateGuestName() {
            var random = Math.floor(Math.random() * 9000) + 1000;
            return 'ضيف-' + random;
          }

          function generateGuestAlias(ctx) {
            var context = ensureContext(ctx);
            if (!context) return;
            var alias = generateGuestName();
            context.set('data.username', alias);
          }

          function messagePayload(ctx, event) {
            var context = ensureContext(ctx, event);
            if (!context) {
              error('messagePayload فشل في الحصول على سياق صالح.');
              return null;
            }
            var text = '';
            if (context.get) {
              try { text = context.get('data.newMessage') || ''; } catch (getError) { text = ''; }
            }
            if (typeof text !== 'string') {
              text = '';
            }
            var draftFromEvent = readDraftFromEvent(event);
            if (!text.trim() && typeof draftFromEvent === 'string' && draftFromEvent) {
              text = draftFromEvent;
              if (context.set) {
                try { context.set('data.newMessage', draftFromEvent); } catch (syncError) { debug('تعذر مزامنة قيمة الرسالة من الحدث مع الحالة.', { error: syncError }); }
              }
            }
            var value = text.trim();
            if (!value) {
              warn('محاولة إرسال رسالة فارغة تم تجاهلها.');
              return null;
            }
            var username = context.get ? context.get('data.username') : '';
            if (!username) {
              username = generateGuestName();
              context.set('data.username', username);
            }
            var clientMessageId = 'msg-' + Date.now().toString(36) + '-' + Math.random().toString(16).slice(2, 8);
            var keyId = '';
            if (context.get) {
              try { keyId = context.get('data.messageKeyId') || ''; } catch (_keyErr) { keyId = ''; }
            }
            if (typeof keyId !== 'string' || !keyId.trim()) {
              var cfg = config();
              keyId = cfg.keyId || 'chat:demo:plaintext';
            } else {
              keyId = keyId.trim();
            }
            if (context.set) {
              try { context.set('data.messageKeyId', keyId); } catch (_persistErr) {}
            }
            var payload = {
              user: username,
              text: value,
              clientMessageId: clientMessageId,
              keyId: keyId
            };
            debug('تم تحضير الحمولة الخاصة بإرسال الرسالة.', payload);
            return payload;
          }

          function sendMessage(event, ctx) {
            if (event && typeof event.preventDefault === 'function') {
              event.preventDefault();
            }
            var context = ensureContext(ctx, event);
            if (!context) {
              error('sendMessage لم يتمكن من الحصول على سياق HTMLx.');
              return;
            }
            var payload = messagePayload(context, event);
            if (!payload) {
              warn('sendMessage لم يحصل على حمولة صالحة، لن يتم الإرسال.');
              return;
            }
            var socket = connectToChat(context);
            if (!socket) {
              recordError('ws_missing', 'تعذر الوصول إلى اتصال WebSocket لإرسال الرسالة.', null, { connection: true });
              return;
            }
            applyIncomingMessage(null, {
              clientMessageId: payload.clientMessageId,
              username: payload.user,
              text: payload.text,
              pending: true,
              createdAt: new Date().toISOString(),
              metadata: { clientMessageId: payload.clientMessageId, username: payload.user }
            });
            try {
              var messageData = {
                ciphertext: payload.text,
                keyId: payload.keyId,
                metadata: {
                  username: payload.user,
                  clientMessageId: payload.clientMessageId,
                  via: 'htmlx-demo'
                }
              };
              var cfg = config();
              socket.send({
                type: 'chat:send',
                conversationId: cfg.conversationId,
                data: messageData
              });
              info('تم إرسال الرسالة إلى الخادم.', { clientMessageId: payload.clientMessageId });
            } catch (sendError) {
              recordError('send_failed', 'تعذر إرسال الرسالة إلى الخادم.', sendError);
              applyIncomingMessage(null, {
                clientMessageId: payload.clientMessageId,
                username: payload.user,
                text: payload.text,
                pending: false,
                failed: true,
                createdAt: new Date().toISOString(),
                metadata: { clientMessageId: payload.clientMessageId, username: payload.user }
              });
            }
            context.set('data.newMessage', '');
          }

          function connectionClass(connection) {
            if (!connection) return 'text-slate-300';
            switch (connection.status) {
              case 'connected':
                return 'text-emerald-400';
              case 'error':
                return 'text-rose-400';
              case 'disconnected':
                return 'text-amber-300';
              default:
                return 'text-sky-300';
            }
          }

          function formatChatTime(value, includeSeconds, ctx) {
            if (!value) { return ''; }
            var date = value instanceof Date ? value : new Date(value);
            if (!date || isNaN(date.getTime())) { return ''; }
            var options = { hour: '2-digit', minute: '2-digit' };
            if (includeSeconds) { options.second = '2-digit'; }
            try {
              return date.toLocaleTimeString('ar-EG', options);
            } catch (formatError) {
              warn('تعذر تنسيق الطابع الزمني لواجهة الدردشة.', { value: value, includeSeconds: includeSeconds, error: formatError });
              return '';
            }
          }

          function __init__(app, helpers) {
            var store = runtime();
            store.app = helpers && helpers.app ? helpers.app : app;
            if (store.app) {
              var agent = htmlxAgent();
              if (agent && typeof agent.ContextAdapter === 'function') {
                store.lastCtx = agent.ContextAdapter(store.app);
              }
            }
            connectToChat(store.lastCtx);
          }
        </script>
      </section>
    </template>

    <script>
      (function (window) {
        'use strict';
        var M = window.Mishkah;
        if (!M || !M.HTMLxAgent) {
          console.error('Mishkah HTMLx agent is required.');
          return;
        }
        var start = M.HTMLxAgent.make({ templateId: 'chat-app' });
        Promise.resolve(start).catch(function (error) {
          console.error('فشل تشغيل واجهة الدردشة HTMLx:', error);
        });
      })(window);
    </script>
  </body>
</html>
