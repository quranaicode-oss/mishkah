<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>Mishkah WebSocket Demo</title>
  <script src="./mishkah-utils.js"></script>
  <script src="./mishkah.core.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/acorn@8.15.0/dist/acorn.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/acorn-walk@8.3.4/dist/walk.min.js"></script>
  <script>
    window.acornWalk = window.acornWalk || (window.acorn && window.acorn.walk);
  </script>
  <script src="./mishkah-htmlx.js"></script>
  <script src="mishkah-ui.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white">

  <div id="app"></div>

  <template data-namespace="chatApp">

    <div class="container mx-auto p-8 max-w-md" x-if="!state.data.joined">
      <h1 class="text-2xl font-bold mb-4">انضم إلى الدردشة</h1>
      <div class="flex flex-col gap-4">
        <input
          type="text"
          class="p-2 rounded bg-gray-800 border border-gray-700"
          placeholder="اكتب اسمك المستعار"
          value="{state.data.username}"
          oninput="handleUsernameInput(event, ctx)"
        />
        <button
          type="button"
          class="bg-blue-600 p-2 rounded hover:bg-blue-700"
          data-m-gkey="chat:join"
        >
          دخول
        </button>
      </div>
    </div>

    <div
      class="container mx-auto p-4 flex flex-col lg:flex-row gap-4 h-screen"
      x-if="state.data.joined"
    >

      <aside class="w-full lg:w-1/4 bg-gray-800 p-4 rounded-lg flex flex-col gap-4 overflow-y-auto">
        <div class="space-y-2">
          <h2 class="font-bold text-lg">المحادثة الحالية</h2>
          <p class="text-sm text-gray-400">الموضوع: {state.data.topic}</p>
          <p class="text-sm text-gray-300">
            حالة الاتصال:
            <strong
              class="{state.data.connection.status === 'connected' ? 'text-emerald-400' : state.data.connection.status === 'error' ? 'text-rose-400' : 'text-sky-300'}"
            >
              {state.data.connection.status}
            </strong>
          </p>
          <p x-if="state.data.connection.lastError" class="text-sm text-rose-300">
            آخر خطأ: {state.data.connection.lastError.message || state.data.connection.lastError.code}
          </p>
        </div>

        <div class="flex-1">
          <h3 class="font-semibold mb-2 text-sm text-gray-200">المتصلون الآن</h3>
          <ul>
            <li
              x-for="user, idx in state.data.users"
              data-m-key="{user.id || idx}"
              class="py-1 border-b border-gray-700 last:border-0"
            >
              {user.name || user}
            </li>
            <li x-if="!state.data.users.length" class="py-1 text-sm text-gray-500">
              لا توجد أسماء بعد — سيظهر المشاركون بعد إرسال الرسائل.
            </li>
          </ul>
        </div>
      </aside>

      <main class="flex-1 flex flex-col gap-4 overflow-hidden">
        <div class="flex-1 bg-gray-800 p-4 rounded-lg overflow-y-auto">
          <div
            x-for="msg, msgIdx in state.data.messages"
            data-m-key="{msg.clientMessageId || msg.id || msgIdx}"
            class="mb-3"
          >
            <div class="flex items-start justify-between gap-2">
              <strong class="text-blue-300">{msg.user || 'مجهول'}</strong>
              <span class="text-xs text-gray-400">{formatChatTime(msg.createdAt)}</span>
            </div>
            <p class="ml-2 text-sm text-gray-100">{msg.text}</p>
            <p x-if="msg.pending" class="text-xs text-amber-300 mt-1">جاري الإرسال...</p>
            <p x-if="msg.failed" class="text-xs text-rose-400 mt-1">تعذر تسليم الرسالة.</p>
			<script>
			    function formatChatTime(value, includeSeconds) {
        if (!value) {
          return '';
        }
        var date = value instanceof Date ? value : new Date(value);
        if (!date || isNaN(date.getTime())) {
          return '';
        }
        var options = { hour: '2-digit', minute: '2-digit' };
        if (includeSeconds) {
          options.second = '2-digit';
        }
        try {
          return date.toLocaleTimeString('ar-EG', options);
        } catch (formatError) {
          warn('تعذر تنسيق الطابع الزمني لواجهة الدردشة.', {
            value: value,
            includeSeconds: includeSeconds,
            error: formatError
          });
          return '';
        }
      }

			</script>
          
		  
		  </div>
          <p x-if="!state.data.messages.length" class="text-sm text-gray-500">
            لا توجد رسائل حتى الآن. كن أول من يبدأ الحديث!
          </p>
        </div>

        <form class="flex gap-2" onsubmit="sendMessage(event, ctx)">
          <input
            type="text"
            class="flex-1 p-2 rounded bg-gray-700 border border-gray-600"
            placeholder="اكتب رسالتك..."
            value="{state.data.newMessage}"
            oninput="handleMessageInput(event, ctx)"
            data-chat-draft
          />
          <button
            type="submit"
            class="bg-green-600 p-2 rounded hover:bg-green-700"
            data-m-gkey="chat:send"
          >
            إرسال
          </button>
        </form>

        <section x-if="state.data.errors.length" class="bg-rose-950/40 border border-rose-800/40 rounded-lg p-4">
          <h3 class="font-semibold text-rose-200 mb-2">الأخطاء الأخيرة</h3>
          <ul class="space-y-2 text-sm">
            <li
              x-for="err, idx in state.data.errors"
              data-m-key="{err.id || idx}"
              class="border-b border-rose-900/40 pb-2 last:border-0 last:pb-0"
            >
              <strong class="text-rose-300">{err.code}</strong>
              <span class="ml-2 text-gray-200">{err.message}</span>
              <ul
                x-if="err.details && err.details.length"
                class="mt-2 space-y-1 text-xs text-rose-200 list-disc list-inside"
              >
                <li
                  x-for="detail, detailIdx in err.details"
                  data-m-key="{detailIdx + '-' + (detail || 'detail')}"
                >
                  {detail}
                </li>
              </ul>
              <span class="block text-xs text-gray-500 mt-1">{formatChatTime(err.ts, true)}</span>
            </li>
          </ul>
        </section>
      </main>
    </div>

    <script type="application/json" data-m-data data-m-path="data">
      {
        "joined": false,
        "username": "",
        "users": [],
        "messages": [],
        "newMessage": "",
        "conversationId": "demo:lobby",
        "topic": "chat:demo:lobby",
        "connection": {
          "status": "idle",
          "lastError": null,
          "user": null
        },
        "errors": []
      }
    </script>

  </template>

  <script>
    (function (global) {
      var LOG_PREFIX = '%c[Chat Debug]%c ';
      var LOG_STYLE = 'color:#38bdf8;font-weight:bold;';
      var LOG_RESET = 'color:inherit;';

      function log(level, message, payload) {
        if (typeof console === 'undefined') {
          return;
        }
        var logger = typeof console[level] === 'function' ? console[level] : console.log;
        if (payload !== undefined) {
          try {
            logger.call(console, LOG_PREFIX + message, LOG_STYLE, LOG_RESET, payload);
          } catch (error) {
            console.error(LOG_PREFIX + 'فشل تسجيل الحمولة debug payload', LOG_STYLE, LOG_RESET, error);
          }
        } else {
          logger.call(console, LOG_PREFIX + message, LOG_STYLE, LOG_RESET);
        }
      }

      function info(message, payload) {
        log('info', message, payload);
      }

      function warn(message, payload) {
        log('warn', message, payload);
      }

      function error(message, payload) {
        log('error', message, payload);
      }

      function debug(message, payload) {
        log('debug', message, payload);
      }

      var utils = global.Mishkah && global.Mishkah.utils;
      var OriginalWebSocketX = utils && utils.WebSocketX;

      if (OriginalWebSocketX && !OriginalWebSocketX.__chatDebugWrapped) {
        var ChatDebugWebSocketX = /*#__PURE__*/ (function (Parent) {
          function Wrapper(url, options) {
            info('تهيئة اتصال WebSocket جديد', { url: url, options: options || {} });
            var instance = new Parent(url, options);
            try {
              instance.on('open', function () {
                info('تم فتح اتصال WebSocket', { url: url });
              });
              instance.on('close', function (evt) {
                warn('تم إغلاق اتصال WebSocket', { url: url, event: evt });
              });
              instance.on('error', function (err) {
                error('خطأ من WebSocket', { url: url, error: err });
              });
              instance.on('state', function (state) {
                debug('تغيرت حالة WebSocket', { url: url, state: state });
              });
              instance.on('message', function (message) {
                debug('رسالة WebSocket واردة', { url: url, message: message });
              });
            } catch (hookError) {
              warn('تعذر ربط مراقب لأحداث WebSocket', hookError);
            }
            return instance;
          }

          Wrapper.prototype = Parent.prototype;
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(Wrapper, Parent);
          } else if (Wrapper.__proto__) {
            Wrapper.__proto__ = Parent;
          }
          Wrapper.__chatDebugWrapped = true;
          return Wrapper;
        })(OriginalWebSocketX);

        if (utils) {
          utils.WebSocketX = ChatDebugWebSocketX;
          utils.WebSocket = ChatDebugWebSocketX;
        }
        global.__ChatOriginalWebSocketX = OriginalWebSocketX;
        info('تم تفعيل طبقة مراقبة WebSocketX للصفحة الحالية.');
      } else if (!OriginalWebSocketX) {
        warn('تعذر العثور على Mishkah.utils.WebSocketX — لن يتم تسجيل أحداث WebSocket.');
      }

      var agent =
        global.Mishkah &&
        global.Mishkah.HTMLx &&
        global.Mishkah.HTMLx.Agent;

      var utils = global.Mishkah && global.Mishkah.utils;

      var CHAT_CONFIG = {
        url: 'wss://ws.mas.com.eg',
        conversationId: 'demo:lobby',
        topic: 'chat:demo:lobby',
        historyLimit: 50,
        maxErrors: 10,
        tokenEndpoint: null
      };

      var runtime = {
        app: null,
        socket: null,
        lastCtx: null,
        subscriptionRequested: false,
        historyRequested: false,
        authToken: null,
        authTokenMeta: null,
        authenticated: false,
        authenticating: false,
        authPromise: null
      };

      function ensureContext(ctx, event) {
        var input = ctx;
        if (!input && event) {
          if (event.detail && event.detail.ctx) {
            input = event.detail.ctx;
          } else {
            var original = unwrapEvent(event);
            if (original && original.detail && original.detail.ctx) {
              input = original.detail.ctx;
            } else if (original && original.target) {
              input = original.target;
            } else if (original && original.currentTarget) {
              input = original.currentTarget;
            } else if (event.target) {
              input = event.target;
            } else if (event.currentTarget) {
              input = event.currentTarget;
            }
          }
        }
        if (!input && runtime.lastCtx) {
          return runtime.lastCtx;
        }
        if (!input && runtime.app) {
          input = runtime.app;
        }
        if (!input) {
          error('تم تمرير سياق فارغ إلى ensureContext وفشل تحديد سياق بديل.');
          return null;
        }
        if (typeof input.get === 'function' && typeof input.set === 'function') {
          runtime.lastCtx = input;
          return input;
        }
        if (!agent || typeof agent.ContextAdapter !== 'function') {
          error('تعذر تكيف سياق HTMLx، ContextAdapter غير متاح.');
          return null;
        }
        var adapted = agent.ContextAdapter(input);
        if (!adapted && runtime.app && input !== runtime.app) {
          adapted = agent.ContextAdapter(runtime.app);
        }
        if (!adapted && event) {
          var fallbackTarget = event.currentTarget || event.target || null;
          if (fallbackTarget && fallbackTarget !== input) {
            adapted = agent.ContextAdapter(fallbackTarget);
          }
        }
        if (!adapted) {
          error('فشل ContextAdapter في إرجاع سياق صالح.');
          return null;
        }
        runtime.lastCtx = adapted;
        return adapted;
      }

      function unwrapEvent(event) {
        var current = event;
        var guard = 0;
        while (
          current &&
          current.detail &&
          (current.detail.event || current.detail.originalEvent || current.detail.nativeEvent) &&
          guard < 10
        ) {
          current =
            current.detail.event || current.detail.originalEvent || current.detail.nativeEvent || current.detail;
          guard += 1;
        }
        return current || event;
      }

      function resolveDraftValue(event) {
        if (!event) {
          return '';
        }
        var detail = event.detail || {};
        if (typeof detail.value === 'string' && detail.value.trim()) {
          return detail.value;
        }
        if (detail.payload && typeof detail.payload.value === 'string' && detail.payload.value.trim()) {
          return detail.payload.value;
        }
        if (detail.data && typeof detail.data.value === 'string' && detail.data.value.trim()) {
          return detail.data.value;
        }
        if (detail.event) {
          return resolveDraftValue(detail.event);
        }
        if (detail.originalEvent) {
          return resolveDraftValue(detail.originalEvent);
        }
        if (detail.nativeEvent) {
          return resolveDraftValue(detail.nativeEvent);
        }
        return '';
      }

      function readState() {
        if (runtime.app && typeof runtime.app.getState === 'function') {
          return runtime.app.getState();
        }
        if (runtime.lastCtx && typeof runtime.lastCtx.getState === 'function') {
          return runtime.lastCtx.getState();
        }
        var adapted = agent.ContextAdapter(ctx);
        if (!adapted) {
          error('فشل ContextAdapter في إرجاع سياق صالح.');
        }
        return adapted;
      }

      function mutateState(updater) {
        var applied = false;
        if (runtime.app && typeof runtime.app.setState === 'function') {
          runtime.app.setState(updater);
          applied = true;
        }
        if (!applied && runtime.lastCtx && typeof runtime.lastCtx.setState === 'function') {
          runtime.lastCtx.setState(updater);
          applied = true;
        }
        return applied;
      }

      function resetAuthState(options) {
        var settings = options || {};
        runtime.authenticated = false;
        runtime.subscriptionRequested = false;
        runtime.historyRequested = false;
        runtime.authenticating = false;
        runtime.authPromise = null;
        if (settings.clearToken) {
          runtime.authToken = null;
          runtime.authTokenMeta = null;
          if (runtime.socket && runtime.socket.auth) {
            runtime.socket.auth.token = null;
          }
          mutateState(function (prev) {
            var base = prev || {};
            var data = base.data || {};
            var connection = Object.assign({}, data.connection || {});
            connection.user = null;
            return Object.assign({}, base, {
              data: Object.assign({}, data, { connection: connection })
            });
          });
        }
      }

      function deriveHttpUrl(url) {
        if (!url) {
          return null;
        }
        try {
          var parsed = new URL(url, window.location.href);
          if (parsed.protocol === 'wss:') {
            parsed.protocol = 'https:';
          } else if (parsed.protocol === 'ws:') {
            parsed.protocol = 'http:';
          }
          parsed.hash = '';
          return parsed.toString().replace(/\/+$/, '');
        } catch (parseError) {
          warn('تعذر تحليل رابط WebSocket لتحويله إلى HTTP.', { url: url, error: parseError });
          return null;
        }
      }

      function resolveTokenEndpoint() {
        if (CHAT_CONFIG.tokenEndpoint) {
          return CHAT_CONFIG.tokenEndpoint;
        }
        var base = deriveHttpUrl(CHAT_CONFIG.url);
        if (!base) {
          return null;
        }
        return base.replace(/\/+$/, '') + '/api/demo/guest-token';
      }

      async function ensureAuthToken(context) {
        if (runtime.authToken) {
          return runtime.authToken;
        }
        if (runtime.authPromise) {
          return runtime.authPromise;
        }
        var activeContext = ensureContext(context || runtime.lastCtx);
        var username = '';
        if (activeContext && typeof activeContext.get === 'function') {
          try {
            username = activeContext.get('data.username') || '';
          } catch (_getErr) {
            username = '';
          }
        }
        if (!username || typeof username !== 'string') {
          username = generateGuestName();
          if (activeContext && typeof activeContext.set === 'function') {
            activeContext.set('data.username', username);
          }
        } else {
          username = username.trim();
          if (!username) {
            username = generateGuestName();
            if (activeContext && typeof activeContext.set === 'function') {
              activeContext.set('data.username', username);
            }
          }
        }
        var endpoint = resolveTokenEndpoint();
        if (!endpoint) {
          throw new Error('تعذر تحديد عنوان خدمة الرموز.');
        }
        info('جارٍ طلب رمز ضيف للدردشة.', { endpoint: endpoint, username: username });
        runtime.authenticating = true;
        runtime.authPromise = (async function () {
          var response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ conversationId: CHAT_CONFIG.conversationId, name: username })
          });
          if (!response.ok) {
            var errorText = '';
            try {
              errorText = await response.text();
            } catch (_textErr) {
              errorText = '';
            }
            throw new Error('فشل طلب رمز الضيف: ' + (errorText || response.statusText || response.status));
          }
          var data;
          try {
            data = await response.json();
          } catch (parseErr) {
            throw new Error('تعذر قراءة استجابة رمز الضيف: ' + parseErr.message);
          }
          if (!data || !data.token) {
            throw new Error('الرد من خدمة الرموز لا يحتوي على رمز صالح.');
          }
          runtime.authToken = data.token;
          runtime.authTokenMeta = {
            endpoint: endpoint,
            obtainedAt: Date.now(),
            expiresIn: data.expiresIn || null,
            user: data.user || null
          };
          return runtime.authToken;
        })();
        try {
          return await runtime.authPromise;
        } finally {
          runtime.authenticating = false;
          runtime.authPromise = null;
        }
      }

      function extractError(meta) {
        if (!meta) {
          return null;
        }
        if (meta instanceof Error) {
          return { code: meta.code || 'error', message: meta.message };
        }
        if (typeof meta === 'string') {
          return { code: 'error', message: meta };
        }
        if (meta.code || meta.message || meta.reason) {
          return {
            code: meta.code || meta.status || 'error',
            message: meta.message || meta.reason || String(meta.code || 'error')
          };
        }
        if (meta.error) {
          return extractError(meta.error);
        }
        if (meta.ts && meta.code && meta.message) {
          return { code: meta.code, message: meta.message, ts: meta.ts };
        }
        try {
          return { code: meta.code || 'error', message: JSON.stringify(meta) };
        } catch (_err) {
          return { code: 'error', message: String(meta) };
        }
      }

  
      function setConnectionStatus(status, meta) {
        var normalizedError = status === 'error' ? extractError(meta) : extractError(meta && meta.error);
        var resetError = status === 'connected' || (meta && meta.resetError);
        mutateState(function (prev) {
          var base = prev || {};
          var data = base.data || {};
          var connection = Object.assign({}, data.connection || {});
          connection.status = status;
          if (resetError) {
            connection.lastError = null;
          } else if (normalizedError) {
            connection.lastError = normalizedError;
          }
          if (meta && Object.prototype.hasOwnProperty.call(meta, 'user')) {
            connection.user = meta.user;
          } else if (!Object.prototype.hasOwnProperty.call(connection, 'user')) {
            connection.user = (data.connection && data.connection.user) || null;
          }
          return Object.assign({}, base, {
            data: Object.assign({}, data, {
              connection: connection
            })
          });
        });
      }

      function extractErrorDetails(meta) {
        if (!meta) {
          return [];
        }
        var candidates = [];
        if (Array.isArray(meta.details)) {
          candidates = candidates.concat(meta.details);
        }
        if (Array.isArray(meta.errors)) {
          candidates = candidates.concat(meta.errors);
        }
        if (Array.isArray(meta.issues)) {
          candidates = candidates.concat(meta.issues);
        }
        if (meta.meta) {
          if (Array.isArray(meta.meta.details)) {
            candidates = candidates.concat(meta.meta.details);
          }
          if (Array.isArray(meta.meta.errors)) {
            candidates = candidates.concat(meta.meta.errors);
          }
          if (Array.isArray(meta.meta.issues)) {
            candidates = candidates.concat(meta.meta.issues);
          }
        }
        if (meta.error) {
          var nested = extractErrorDetails(meta.error);
          if (nested.length) {
            candidates = candidates.concat(nested);
          }
        }
        return candidates
          .map(function (item) {
            if (!item) {
              return null;
            }
            if (typeof item === 'string') {
              return item.trim();
            }
            if (item instanceof Error) {
              return (item.message || '').trim();
            }
            var parts = [];
            if (Array.isArray(item.path) && item.path.length) {
              parts.push(item.path.join('.'));
            }
            if (item.message) {
              parts.push(item.message);
            } else if (item.code) {
              parts.push(item.code);
            }
            if (!parts.length && typeof item === 'object') {
              try {
                return JSON.stringify(item);
              } catch (_err) {
                return String(item);
              }
            }
            return parts.join(': ').trim();
          })
          .filter(function (value, index, all) {
            if (!value) {
              return false;
            }
            return all.indexOf(value) === index;
          });
      }

      function recordError(code, message, meta, options) {
        var normalizedMessage = '';
        if (message != null) {
          normalizedMessage = String(message).trim();
        }
        if (!normalizedMessage && meta && meta.message != null) {
          try {
            normalizedMessage = String(meta.message).trim();
          } catch (_coerceErr) {
            normalizedMessage = '';
          }
        }
        if (!normalizedMessage) {
          normalizedMessage = 'حدث خطأ غير معروف.';
        }
        var entry = {
          id: 'err-' + Date.now().toString(36) + '-' + Math.random().toString(16).slice(2, 8),
          code: code || 'unknown',
          message: normalizedMessage,
          ts: new Date().toISOString(),
          meta: meta || null,
          details: extractErrorDetails(meta)
        };
        warn(entry.message, { code: entry.code, meta: meta });
        mutateState(function (prev) {
          var base = prev || {};
          var data = base.data || {};
          var errors = Array.isArray(data.errors) ? data.errors.slice() : [];
          errors.unshift(entry);
          if (errors.length > CHAT_CONFIG.maxErrors) {
            errors = errors.slice(0, CHAT_CONFIG.maxErrors);
          }
          var connection = Object.assign({}, data.connection || {});
          if (options && options.connection) {
            connection.lastError = {
              code: entry.code,
              message: entry.message,
              ts: entry.ts,
              details: entry.details
            };
          }
          return Object.assign({}, base, {
            data: Object.assign({}, data, {
              errors: errors,
              connection: connection
            })
          });
        });
        return entry;
      }

      function normalizeUserInfo(rawUser) {
        if (!rawUser) {
          return null;
        }
        var claims = rawUser.claims || {};
        var name = rawUser.name || claims.name || claims.username || claims.displayName || '';
        var identifier = rawUser.id || claims.sub || claims.id || null;
        if (!name && identifier) {
          name = identifier;
        }
        return {
          id: identifier,
          name: name || '',
          roles: Array.isArray(rawUser.roles) ? rawUser.roles.slice() : []
        };
      }

      function normalizeMessage(raw, hints) {
        var source = raw || {};
        var fallback = hints || {};
        var metadata = source.metadata || fallback.metadata || {};
        var username = metadata.username || metadata.user || fallback.username || source.user || '';
        var text = source.ciphertext || source.text || fallback.text || '';
        if (text != null && typeof text !== 'string') {
          try {
            text = String(text);
          } catch (_err) {
            text = '';
          }
        }
        var createdAt = source.createdAt || source.ts || fallback.createdAt || new Date().toISOString();
        var clientMessageId = metadata.clientMessageId || fallback.clientMessageId || null;
        var id = source.id || fallback.id || null;
        var failed = Boolean(fallback.failed);
        var pending = Boolean(fallback.pending) && !source.id && !failed;
        if (!text && !pending && !failed) {
          return null;
        }
        return {
          id: id,
          clientMessageId: clientMessageId,
          user: username || 'مجهول',
          text: text,
          createdAt: createdAt,
          pending: pending,
          failed: failed
        };
      }

      function applyIncomingMessage(raw, hints) {
        var normalized = normalizeMessage(raw, hints || {});
        if (!normalized) {
          return;
        }
        mutateState(function (prev) {
          var base = prev || {};
          var data = base.data || {};
          var messages = Array.isArray(data.messages) ? data.messages.slice() : [];
          var idx = -1;
          if (normalized.clientMessageId) {
            idx = messages.findIndex(function (msg) {
              return msg && msg.clientMessageId === normalized.clientMessageId;
            });
          }
          if (idx === -1 && normalized.id) {
            idx = messages.findIndex(function (msg) {
              return msg && msg.id === normalized.id;
            });
          }
          if (idx !== -1) {
            messages[idx] = Object.assign({}, messages[idx], normalized);
          } else {
            messages.push(normalized);
          }
          if (messages.length > 200) {
            messages = messages.slice(messages.length - 200);
          }
          var users = Array.isArray(data.users) ? data.users.slice() : [];
          if (normalized.user && users.indexOf(normalized.user) === -1) {
            users.push(normalized.user);
          }
          return Object.assign({}, base, {
            data: Object.assign({}, data, {
              messages: messages,
              users: users
            })
          });
        });
      }

      function subscribeToChat() {
        if (!runtime.socket || runtime.socket.state !== 'open') {
          return;
        }
        if (runtime.subscriptionRequested) {
          return;
        }
        if (!runtime.authenticated) {
          debug('تم تجاهل طلب الاشتراك قبل اكتمال المصادقة.');
          return;
        }
        try {
          runtime.socket.send({ type: 'subscribe', topic: CHAT_CONFIG.topic });
          runtime.subscriptionRequested = true;
          info('تم إرسال طلب الاشتراك في الدردشة.', { topic: CHAT_CONFIG.topic });
        } catch (sendError) {
          runtime.subscriptionRequested = false;
          recordError('subscribe_failed', 'تعذر إرسال طلب الاشتراك في الدردشة.', sendError, { connection: true });
          setConnectionStatus('error', sendError);
        }
      }

      function requestHistory(force) {
        if (!runtime.socket || runtime.socket.state !== 'open') {
          return;
        }
        if (runtime.historyRequested && !force) {
          return;
        }
        if (!runtime.authenticated) {
          debug('تم تجاهل طلب السجل قبل اكتمال المصادقة.');
          return;
        }
        try {
          runtime.socket.send({
            type: 'chat:history',
            conversationId: CHAT_CONFIG.conversationId,
            limit: CHAT_CONFIG.historyLimit
          });
          runtime.historyRequested = true;
          info('تم طلب سجل الرسائل.', { limit: CHAT_CONFIG.historyLimit });
        } catch (historyError) {
          runtime.historyRequested = false;
          recordError('history_failed', 'تعذر طلب سجل الرسائل من الخادم.', historyError);
        }
      }

      function handleAckMessage(message) {
        if (!message) {
          return;
        }
        if (message.event === 'auth') {
          runtime.authenticated = true;
          runtime.subscriptionRequested = false;
          runtime.historyRequested = false;
          var normalizedUser = normalizeUserInfo(message.user);
          if (normalizedUser) {
            mutateState(function (prev) {
              var base = prev || {};
              var data = base.data || {};
              var users = Array.isArray(data.users) ? data.users.slice() : [];
              if (normalizedUser.name && users.indexOf(normalizedUser.name) === -1) {
                users.push(normalizedUser.name);
              }
              return Object.assign({}, base, {
                data: Object.assign({}, data, {
                  users: users,
                  connection: Object.assign({}, data.connection || {}, { user: normalizedUser })
                })
              });
            });
          }
          setConnectionStatus('connected', { resetError: true, user: normalizedUser || null });
          subscribeToChat();
          requestHistory(true);
          return;
        }
        if (message.event === 'subscribe') {
          info('تم تأكيد الاشتراك في موضوع الدردشة.', { topic: message.topic });
        } else if (message.event === 'chat:send' && message.message) {
          applyIncomingMessage(message.message, {});
        }
      }

      function handlePublishMessage(message) {
        if (!message || message.topic !== CHAT_CONFIG.topic) {
          return;
        }
        applyIncomingMessage(message.data || {}, {});
      }

      function handleHistoryMessage(message) {
        if (!message || message.conversationId !== CHAT_CONFIG.conversationId) {
          return;
        }
        var list = Array.isArray(message.messages) ? message.messages : [];
        mutateState(function (prev) {
          var base = prev || {};
          var data = base.data || {};
          var users = Array.isArray(data.users) ? data.users.slice() : [];
          var normalizedMessages = list
            .map(function (item) {
              return normalizeMessage(item, {});
            })
            .filter(Boolean)
            .sort(function (a, b) {
              return new Date(a.createdAt || 0) - new Date(b.createdAt || 0);
            });
          var userSet = new Set(users);
          normalizedMessages.forEach(function (msg) {
            if (msg.user) {
              userSet.add(msg.user);
            }
          });
          return Object.assign({}, base, {
            data: Object.assign({}, data, {
              messages: normalizedMessages,
              users: Array.from(userSet)
            })
          });
        });
      }

      function handleServerError(message) {
        var code = message && message.code ? message.code : 'server_error';
        var text = message && message.message ? message.message : 'أبلغ الخادم عن خطأ غير معروف.';
        recordError(code, text, message, { connection: true });
        setConnectionStatus('error', { code: code, message: text });
        if (code === 'unauthorized_sub' || code === 'topic_not_allowed') {
          runtime.subscriptionRequested = false;
        }
        if (code === 'unauthorized_pub') {
          runtime.authenticated = false;
        }
        if (code === 'auth_failed' || code === 'unauthorized' || code === 'token_required' || code === 'unauthorized_pub') {
          resetAuthState({ clearToken: true });
          if (runtime.socket && typeof runtime.socket.close === 'function') {
            try {
              runtime.socket.close(4401, 'reauth');
            } catch (_closeErr) {}
          }
        }
      }

      function handleSocketMessage(message) {
        if (!message) {
          return;
        }
        if (typeof message === 'string') {
          try {
            message = JSON.parse(message);
          } catch (_err) {
            return;
          }
        }
        debug('رسالة WebSocket واردة', message);
        switch (message.type) {
          case 'hello':
            resetAuthState({ clearToken: true });
            if (runtime.socket && runtime.socket.auth) {
              runtime.socket.auth.token = null;
            }
            (async function () {
              try {
                var token = await ensureAuthToken(runtime.lastCtx);
                if (runtime.socket && runtime.socket.state === 'open') {
                  runtime.socket.send({ type: 'auth', data: { token: token } });
                }
              } catch (reauthErr) {
                recordError('auth_retry_failed', 'تعذر استكمال المصادقة التلقائية بعد رسالة hello.', reauthErr, {
                  connection: true
                });
              }
            })();
            break;
          case 'ack':
            handleAckMessage(message);
            break;
          case 'publish':
            handlePublishMessage(message);
            break;
          case 'chat:history':
            handleHistoryMessage(message);
            break;
          case 'error':
            handleServerError(message);
            break;
          case 'pong':
            break;
          default:
            debug('رسالة غير معالجة من الخادم', message);
        }
      }

      function attachSocketHandlers(socket) {
        if (!socket || socket.__chatHandlersAttached) {
          return;
        }
        socket.__chatHandlersAttached = true;
        socket.on('open', function () {
          info('تم فتح اتصال WebSocket بنجاح.', { topic: CHAT_CONFIG.topic });
          resetAuthState();
          setConnectionStatus('connected', { resetError: true });
        });
        socket.on('close', function (evt) {
          warn('تم إغلاق اتصال WebSocket.', { code: evt && evt.code, reason: evt && evt.reason });
          resetAuthState();
          setConnectionStatus('disconnected', { error: evt && { code: evt.code || 'closed', message: evt.reason || '' } });
        });
        socket.on('error', function (err) {
          recordError('socket_error', 'حدث خطأ في قناة WebSocket.', err, { connection: true });
          setConnectionStatus('error', err);
        });
        socket.on('state', function (state) {
          debug('تغيرت حالة WebSocket', { state: state });
        });
        socket.on('message', function (msg) {
          handleSocketMessage(msg);
        });
      }

      function syncConfigWithState() {
        var state = readState();
        if (!state || !state.data) {
          return;
        }
        var data = state.data;
        if (typeof data.conversationId === 'string' && data.conversationId) {
          CHAT_CONFIG.conversationId = data.conversationId;
        }
        if (typeof data.topic === 'string' && data.topic) {
          CHAT_CONFIG.topic = data.topic;
        } else if (CHAT_CONFIG.conversationId) {
          CHAT_CONFIG.topic = 'chat:' + CHAT_CONFIG.conversationId;
        }
        mutateState(function (prev) {
          var base = prev || {};
          var prevData = base.data || {};
          if (
            prevData.topic === CHAT_CONFIG.topic &&
            prevData.conversationId === CHAT_CONFIG.conversationId
          ) {
            return base;
          }
          return Object.assign({}, base, {
            data: Object.assign({}, prevData, {
              topic: CHAT_CONFIG.topic,
              conversationId: CHAT_CONFIG.conversationId
            })
          });
        });
      }

      function connectToChat(ctx) {
        var context = ensureContext(ctx || runtime.lastCtx);
        if (!context) {
          error('connectToChat لم يتمكن من تهيئة سياق HTMLx صالح.');
          return null;
        }
        syncConfigWithState();
        if (!utils || typeof utils.WebSocketX !== 'function') {
          recordError('wsx_unavailable', 'Mishkah.utils.WebSocketX غير متاح.', null, { connection: true });
          return null;
        }
        if (!runtime.socket) {
          try {
            runtime.socket = new utils.WebSocketX(CHAT_CONFIG.url, {
              autoReconnect: true,
              backoff: { min: 1000, max: 10000, factor: 1.6 },
              ping: { interval: 20000, send: { type: 'ping' }, expect: { type: 'pong' }, timeout: 8000 },
              auth: {
                param: 'token',
                sendOnUrl: true,
                getToken: async function () {
                  try {
                    return await ensureAuthToken(runtime.lastCtx || context);
                  } catch (tokenError) {
                    recordError('token_failed', 'تعذر الحصول على رمز الضيف من الخادم.', tokenError, { connection: true });
                    throw tokenError;
                  }
                }
              }
            });
          } catch (ctorError) {
            recordError('wsx_init_failed', 'تعذر إنشاء عميل WebSocket.', ctorError, { connection: true });
            return null;
          }
          attachSocketHandlers(runtime.socket);
        }
        if (runtime.socket.state === 'open') {
          setConnectionStatus('connected', { resetError: true });
          if (runtime.authenticated) {
            subscribeToChat();
            requestHistory(false);
          } else {
            (async function () {
              try {
                var token = await ensureAuthToken(runtime.lastCtx || context);
                if (runtime.socket && runtime.socket.state === 'open') {
                  if (runtime.socket.auth) {
                    runtime.socket.auth.token = token;
                  }
                  runtime.socket.send({ type: 'auth', data: { token: token } });
                }
              } catch (initAuthErr) {
                recordError('auth_failed_init', 'تعذر تهيئة المصادقة على قناة الدردشة.', initAuthErr, {
                  connection: true
                });
              }
            })();
          }
        } else if (runtime.socket.state !== 'connecting') {
          setConnectionStatus('connecting');
          try {
            runtime.socket.connect({ waitOpen: false });
          } catch (connectError) {
            recordError('ws_connect_failed', 'تعذر بدء اتصال WebSocket.', connectError, { connection: true });
            setConnectionStatus('error', connectError);
          }
        }
        return runtime.socket;
      }

      function handleUsernameInput(event, ctx) {
        var context = ensureContext(ctx, event);
        if (!context || !event) {
          error('handleUsernameInput استقبل سياقًا أو حدثًا غير صالح.', { event: event, ctx: ctx });
          return;
        }
        var value = '';
        var original = unwrapEvent(event);
        var source = (original && original.target) || event.target;
        if (source && typeof source.value === 'string') {
          value = source.value;
        } else if (event.detail && typeof event.detail.value === 'string') {
          value = event.detail.value;
        }
        debug('تحديث اسم المستخدم من حقل الإدخال.', { value: value });
        context.set('data.username', value);
      }

      function joinChat(event, ctx) {
        if (event && typeof event.preventDefault === 'function') {
          event.preventDefault();
        }
        var context = ensureContext(ctx, event);
        if (!context) {
          error('لم يتم العثور على سياق صالح عند محاولة الانضمام للدردشة.');
          return;
        }
        var current = context.get ? context.get('data.username') : '';
        var name = typeof current === 'string' ? current.trim() : '';
        if (!name) {
          name = generateGuestName();
          context.set('data.username', name);
        } else if (name !== current) {
          context.set('data.username', name);
        }
        resetAuthState({ clearToken: true });
        context.set('data.joined', true);
        mutateState(function (prev) {
          var base = prev || {};
          var data = base.data || {};
          var users = Array.isArray(data.users) ? data.users.slice() : [];
          if (users.indexOf(name) === -1) {
            users.push(name);
          }
          return Object.assign({}, base, {
            data: Object.assign({}, data, {
              users: users
            })
          });
        });
        info('تم تنفيذ joinChat وتحديث الحالة.', { username: name });
        connectToChat(context);
      }

      function handleMessageInput(event, ctx) {
        var context = ensureContext(ctx, event);
        if (!context || !event) {
          error('handleMessageInput استقبل سياقًا أو حدثًا غير صالح.', { event: event });
          return;
        }
        var value = '';
        var original = unwrapEvent(event);
        var source = (original && original.target) || event.target;
        if (source && typeof source.value === 'string') {
          value = source.value;
        } else if (event.detail && typeof event.detail.value === 'string') {
          value = event.detail.value;
        }
        debug('تحديث قيمة الرسالة المؤقتة.', { value: value });
        context.set('data.newMessage', value);
      }

      function hasDraftAttribute(node) {
        return !!(node && typeof node.hasAttribute === 'function' && node.hasAttribute('data-chat-draft'));
      }

      function findDraftInput(source) {
        if (hasDraftAttribute(source)) {
          return source;
        }
        if (source && typeof source.closest === 'function') {
          var direct = source.closest('[data-chat-draft]');
          if (direct) {
            return direct;
          }
          var form = source.closest('form');
          if (form && typeof form.querySelector === 'function') {
            var fromForm = form.querySelector('[data-chat-draft]');
            if (fromForm) {
              return fromForm;
            }
          }
        }
        if (typeof document !== 'undefined' && document) {
          var active = document.activeElement;
          if (hasDraftAttribute(active)) {
            return active;
          }
          if (typeof document.querySelector === 'function') {
            var fallback = document.querySelector('[data-chat-draft]');
            if (fallback) {
              return fallback;
            }
          }
        }
        return null;
      }

      function readDraftFromEvent(event) {
        var original = unwrapEvent(event);
        var source = null;
        if (original && original.target) {
          source = original.target;
        } else if (original && original.currentTarget) {
          source = original.currentTarget;
        } else if (event && event.target) {
          source = event.target;
        } else if (event && event.currentTarget) {
          source = event.currentTarget;
        }
        var input = findDraftInput(source);
        if (input && typeof input.value === 'string') {
          return input.value;
        }
        var detailValue = resolveDraftValue(event);
        if (detailValue) {
          return detailValue;
        }
        return '';
      }

      function messagePayload(ctx, event) {
        var context = ensureContext(ctx, event);
        var effectiveContext = context || runtime.lastCtx || runtime.app || null;
        if (!effectiveContext) {
          warn('messagePayload يعمل دون سياق HTMLx مباشر وسيعتمد على قيم الحدث فقط.');
        }
        var text = '';
        if (effectiveContext && typeof effectiveContext.get === 'function') {
          try {
            text = effectiveContext.get('data.newMessage') || '';
          } catch (getError) {
            debug('فشل الحصول على قيمة الرسالة من الحالة، سيتم الاعتماد على الحدث.', { error: getError });
            text = '';
          }
        }
        if (typeof text !== 'string') {
          text = '';
        }
        var draftFromEvent = readDraftFromEvent(event);
        if (!text.trim() && typeof draftFromEvent === 'string' && draftFromEvent) {
          text = draftFromEvent;
          if (effectiveContext && typeof effectiveContext.set === 'function') {
            try {
              effectiveContext.set('data.newMessage', draftFromEvent);
            } catch (syncError) {
              debug('تعذر مزامنة قيمة الرسالة من الحدث مع الحالة.', { error: syncError });
            }
          }
        }
        var value = text.trim();
        if (!value) {
          warn('محاولة إرسال رسالة فارغة تم تجاهلها.');
          return null;
        }
        var username =
          effectiveContext && typeof effectiveContext.get === 'function'
            ? effectiveContext.get('data.username')
            : runtime.app && typeof runtime.app.get === 'function'
              ? runtime.app.get('data.username')
              : '';
        if (!username) {
          username = generateGuestName();
          warn('لم يتم تعيين اسم مستخدم، تم إنشاء اسم ضيف تلقائي.', { username: username });
          if (effectiveContext && typeof effectiveContext.set === 'function') {
            effectiveContext.set('data.username', username);
          }
        }
        var clientMessageId = 'msg-' + Date.now().toString(36) + '-' + Math.random().toString(16).slice(2, 8);
        var payload = {
          user: username,
          text: value,
          clientMessageId: clientMessageId
        };
        debug('تم تحضير الحمولة الخاصة بإرسال الرسالة.', payload);
        return payload;
      }

      function sendMessage(event, ctx) {
        if (event && typeof event.preventDefault === 'function') {
          event.preventDefault();
        }
        var context = ensureContext(ctx, event);
        var payload = messagePayload(context, event);
        if (!payload) {
          warn('sendMessage لم يحصل على حمولة صالحة، لن يتم الإرسال.');
          return;
        }
        var socket = connectToChat(context || runtime.lastCtx || runtime.app);
        if (!socket) {
          recordError('ws_missing', 'تعذر الوصول إلى اتصال WebSocket لإرسال الرسالة.', null, { connection: true });
          return;
        }
        applyIncomingMessage(null, {
          clientMessageId: payload.clientMessageId,
          username: payload.user,
          text: payload.text,
          pending: true,
          createdAt: new Date().toISOString(),
          metadata: { clientMessageId: payload.clientMessageId, username: payload.user }
        });
        try {
          socket.send({
            type: 'chat:send',
            conversationId: CHAT_CONFIG.conversationId,
            data: {
              ciphertext: payload.text,
              keyId: null,
              metadata: {
                username: payload.user,
                clientMessageId: payload.clientMessageId,
                via: 'htmlx-demo'
              }
            }
          });
          info('تم إرسال الرسالة إلى الخادم.', { clientMessageId: payload.clientMessageId });
        } catch (sendError) {
          recordError('send_failed', 'تعذر إرسال الرسالة إلى الخادم.', sendError);
          applyIncomingMessage(null, {
            clientMessageId: payload.clientMessageId,
            username: payload.user,
            text: payload.text,
            pending: false,
            failed: true,
            createdAt: new Date().toISOString(),
            metadata: { clientMessageId: payload.clientMessageId, username: payload.user }
          });
        }
        if (context && typeof context.set === 'function') {
          context.set('data.newMessage', '');
        } else if (runtime.lastCtx && typeof runtime.lastCtx.set === 'function') {
          runtime.lastCtx.set('data.newMessage', '');
        } else if (runtime.app && typeof runtime.app.set === 'function') {
          runtime.app.set('data.newMessage', '');
        }
        info('تم تصفير حقل الرسالة بعد الإرسال المبدئي.', { payload: payload });
      }

      function generateGuestName() {
        var random = Math.floor(Math.random() * 9000) + 1000;
        return 'ضيف-' + random;
      }

      var chatOrders = {
        'chat.join': {
          on: ['click'],
          gkeys: ['chat:join'],
          handler: function (event, context) {
            joinChat(event, context);
          }
        },
        'chat.send': {
          on: ['click'],
          gkeys: ['chat:send'],
          handler: function (event, context) {
            sendMessage(event, context);
          }
        }
      };
    function formatChatTime(value, includeSeconds) {
        if (!value) {
          return '';
        }
        var date = value instanceof Date ? value : new Date(value);
        if (!date || isNaN(date.getTime())) {
          return '';
        }
        var options = { hour: '2-digit', minute: '2-digit' };
        if (includeSeconds) {
          options.second = '2-digit';
        }
        try {
          return date.toLocaleTimeString('ar-EG', options);
        } catch (formatError) {
          warn('تعذر تنسيق الطابع الزمني لواجهة الدردشة.', {
            value: value,
            includeSeconds: includeSeconds,
            error: formatError
          });
          return '';
        }
      }

      global.handleUsernameInput = handleUsernameInput;
      global.joinChat = joinChat;
      global.handleMessageInput = handleMessageInput;
      global.messagePayload = messagePayload;
      global.sendMessage = sendMessage;
      global.generateGuestName = generateGuestName;
      global.connectToChat = connectToChat;
      global.formatChatTime = formatChatTime;
      global.chatRuntime = runtime;
      global.chatOrders = chatOrders;
    })(window);
  </script>

  <script>
    const chatDatabase = {
      head: { title: 'Mishkah WebSocket Demo' },
      env: { lang: 'ar', dir: 'rtl', theme: 'dark' }
    };

    Mishkah.app.make(chatDatabase, { orders: window.chatOrders || {} }).then(app => {
      window.__chatApp = app;
      if (window.chatRuntime) {
        window.chatRuntime.app = app;
      }
      console.log('Mishkah HTMLx WebSocket App Initialized!');
    });
  </script>

</body>
</html>
