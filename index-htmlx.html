<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ŸÖÿ¥ŸÉÿßÿ© ‚Äî ÿ™ÿ¨ÿ±ÿ®ÿ© HTMLx</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&family=Tajawal:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light dark;
        --page-gradient: linear-gradient(160deg, #f8f9ff 0%, #e8ecff 100%);
        --page-overlay-1: radial-gradient(circle at 20% 25%, rgba(79, 70, 229, 0.18), transparent 55%);
        --page-overlay-2: radial-gradient(circle at 80% 70%, rgba(14, 165, 233, 0.18), transparent 50%);
        --panel-glass: rgba(255, 255, 255, 0.78);
        --panel-border: rgba(99, 102, 241, 0.12);
        --panel-shadow: 0 25px 50px -20px rgba(15, 23, 42, 0.18);
        --surface-1: rgba(255, 255, 255, 0.72);
        --surface-2: rgba(241, 245, 249, 0.82);
        --border: rgba(99, 102, 241, 0.18);
        --foreground: #111827;
        --muted-foreground: rgba(55, 65, 81, 0.72);
        --primary: #4f46e5;
        --primary-foreground: #f9fafb;
        --accent-ring: rgba(79, 70, 229, 0.18);
        --tile-bg: linear-gradient(160deg, rgba(255, 255, 255, 0.95), rgba(241, 245, 249, 0.85));
        --tile-bg-revealed: linear-gradient(160deg, rgba(129, 140, 248, 0.75), rgba(79, 70, 229, 0.65));
        --tile-border: rgba(99, 102, 241, 0.25);
        --letters-shadow: 0 18px 45px -24px rgba(15, 23, 42, 0.35);
        --letters-hover: 0 25px 50px -20px rgba(99, 102, 241, 0.45);
        --font-body: 'Cairo', 'Tajawal', system-ui;
        --font-size: 1rem;
      }

      :root.dark {
        --page-gradient: linear-gradient(160deg, #0d1224 0%, #111c3d 100%);
        --page-overlay-1: radial-gradient(circle at 80% 30%, rgba(168, 85, 247, 0.22), transparent 55%);
        --page-overlay-2: radial-gradient(circle at 15% 80%, rgba(56, 189, 248, 0.18), transparent 55%);
        --panel-glass: rgba(17, 25, 40, 0.75);
        --panel-border: rgba(148, 163, 184, 0.32);
        --panel-shadow: 0 25px 50px -18px rgba(15, 23, 42, 0.55);
        --surface-1: rgba(17, 25, 40, 0.76);
        --surface-2: rgba(30, 41, 59, 0.78);
        --border: rgba(148, 163, 184, 0.35);
        --foreground: #f8fafc;
        --muted-foreground: rgba(203, 213, 225, 0.75);
        --primary: #818cf8;
        --primary-foreground: #0f172a;
        --accent-ring: rgba(129, 140, 248, 0.35);
        --tile-bg: linear-gradient(160deg, rgba(30, 41, 59, 0.78), rgba(15, 23, 42, 0.92));
        --tile-bg-revealed: linear-gradient(160deg, rgba(99, 102, 241, 0.55), rgba(79, 70, 229, 0.38));
        --tile-border: rgba(148, 163, 184, 0.35);
        --letters-shadow: 0 20px 40px -18px rgba(148, 163, 184, 0.35);
        --letters-hover: 0 28px 60px -20px rgba(99, 102, 241, 0.6);
      }

      *, *::before, *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: var(--font-body);
        background: var(--page-gradient);
        color: var(--foreground);
      }

      .page-shell {
        position: relative;
        min-height: 100vh;
        padding: 2rem 1.5rem 3.5rem;
      }

      .page-shell::before,
      .page-shell::after {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: -1;
      }

      .page-shell::before {
        background: var(--page-overlay-1);
      }

      .page-shell::after {
        background: var(--page-overlay-2);
      }

      .app-card {
        background: var(--panel-glass);
        backdrop-filter: blur(22px);
        border: 1px solid var(--panel-border);
        border-radius: 2rem;
        box-shadow: var(--panel-shadow);
        overflow: hidden;
      }

      header.header {
        margin: 0 auto 2rem;
        max-width: 1500px;
      }

      header.header .header-inner {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        align-items: center;
        padding: 1.5rem;
      }

      header.header h1 {
        margin: 0;
        font-size: clamp(1.8rem, 2.8vw, 2.6rem);
      }

      header.header p {
        margin: 0.4rem 0 0;
        font-size: 0.95rem;
        color: var(--muted-foreground);
      }

      .status-strip {
        display: flex;
        flex-wrap: wrap;
        gap: 1.25rem;
        padding: 0.75rem 1.25rem;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface-1);
        box-shadow: 0 18px 40px -28px rgba(79, 70, 229, 0.45);
      }

      .status-block {
        display: inline-flex;
        align-items: center;
        gap: 0.6rem;
        font-size: 0.95rem;
      }

      .status-block strong {
        font-size: 1.05rem;
      }

      .hearts-row {
        display: inline-flex;
        gap: 0.4rem;
        font-size: 1.1rem;
      }

      .controls {
        margin-inline-start: auto;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .segmented {
        display: inline-flex;
        align-items: center;
        background: var(--surface-1);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0.25rem;
        gap: 0.25rem;
      }

      .segmented button {
        border: none;
        background: transparent;
        color: var(--muted-foreground);
        padding: 0.45rem 1.15rem;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: color 0.2s ease, background 0.2s ease;
      }

      .segmented button.active {
        background: var(--primary);
        color: var(--primary-foreground);
        box-shadow: 0 18px 38px -22px rgba(79, 70, 229, 0.55);
      }

      .layout {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        margin: 0 auto;
        max-width: 1500px;
      }

      @media (min-width: 1024px) {
        .layout {
          flex-direction: row;
        }
      }

      aside.sidebar {
        flex: 0 0 280px;
      }

      .sidebar-card {
        position: sticky;
        top: 1.5rem;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .sidebar-card h2 {
        margin: 0;
        font-size: 1rem;
        letter-spacing: 0.35em;
        text-transform: uppercase;
        color: var(--muted-foreground);
      }

      .nav-list {
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }

      .nav-button {
        width: 100%;
        border: 1px solid transparent;
        border-radius: 1.1rem;
        background: transparent;
        padding: 0.85rem 1rem;
        text-align: start;
        font-weight: 600;
        font-size: 1rem;
        color: var(--muted-foreground);
        cursor: pointer;
        transition: border 0.25s ease, background 0.25s ease, color 0.25s ease;
      }

      .nav-button .hint {
        display: block;
        margin-top: 0.35rem;
        font-size: 0.82rem;
        color: var(--muted-foreground);
        font-weight: 400;
      }

      .nav-button.active {
        border-color: var(--primary);
        background: color-mix(in oklab, var(--primary) 16%, transparent);
        color: var(--foreground);
      }

      .main-column {
        flex: 1 1 auto;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .panel {
        padding: 2rem;
        border-radius: 2rem;
        background: var(--panel-glass);
        border: 1px solid var(--panel-border);
        box-shadow: var(--panel-shadow);
        backdrop-filter: blur(18px);
      }

      .panel header {
        margin-bottom: 1.5rem;
      }

      .panel header h2 {
        margin: 0;
        font-size: 1.4rem;
      }

      .panel header p {
        margin: 0.4rem 0 0;
        color: var(--muted-foreground);
        font-size: 0.95rem;
      }

      .md-prose {
        line-height: 1.7;
        display: grid;
        gap: 1.1rem;
        color: var(--foreground);
      }

      .md-prose h3,
      .md-prose h2,
      .md-prose h4 {
        margin: 0;
      }

      .md-prose h2 {
        font-size: 1.4rem;
      }

      .md-prose h3 {
        font-size: 1.2rem;
      }

      .md-prose ul {
        margin: 0;
        padding-inline-start: 1.4rem;
        display: grid;
        gap: 0.35rem;
      }

      .md-prose blockquote {
        margin: 0;
        padding: 1rem 1.25rem;
        border-inline-start: 4px solid var(--primary);
        background: color-mix(in oklab, var(--primary) 12%, transparent);
        border-radius: 1rem;
      }

      .counter-view {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1.25rem;
      }

      .counter-display {
        font-size: 2.2rem;
        font-weight: 700;
      }

      .button {
        border: none;
        background: var(--primary);
        color: var(--primary-foreground);
        font-weight: 600;
        padding: 0.65rem 1.5rem;
        border-radius: 999px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease;
      }

      .button:hover {
        transform: translateY(-1px);
        box-shadow: 0 16px 40px -22px rgba(79, 70, 229, 0.6);
      }

      .button.secondary {
        background: transparent;
        color: var(--foreground);
        border: 1px solid var(--border);
      }

      .logic-sequence {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.75rem;
      }

      .logic-sequence .term,
      .logic-options button {
        width: 4rem;
        height: 4rem;
        display: grid;
        place-items: center;
        border-radius: 1.4rem;
        border: 1px solid var(--panel-border);
        background: var(--surface-1);
        font-weight: 600;
        font-size: 1.1rem;
        box-shadow: var(--panel-shadow);
      }

      .logic-options {
        display: grid;
        gap: 0.75rem;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      }

      .logic-options button {
        cursor: pointer;
        border: none;
        transition: transform 0.15s ease;
      }

      .logic-options button:hover {
        transform: translateY(-2px);
      }

      .logic-options button.correct {
        border-color: rgba(34, 197, 94, 0.45);
        background: rgba(34, 197, 94, 0.2);
      }

      .logic-options button.wrong {
        border-color: rgba(239, 68, 68, 0.45);
        background: rgba(239, 68, 68, 0.2);
      }

      .game-board {
        display: grid;
        gap: 1.5rem;
      }
      .puzzle-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.75rem;
      }

      .puzzle-tile {
        width: var(--tile-size, 3rem);
        height: var(--tile-size, 3rem);
        border-radius: 1.4rem;
        display: grid;
        place-items: center;
        background: var(--tile-bg);
        border: 1px solid var(--tile-border);
        font-weight: 600;
        font-size: 1.2rem;
        box-shadow: 0 18px 38px -28px rgba(15, 23, 42, 0.45);
      }

      .puzzle-tile.revealed {
        background: var(--tile-bg-revealed);
        color: #fff;
      }

      .puzzle-tile.space {
        width: 2rem;
        border: none;
        background: transparent;
        box-shadow: none;
      }

      .letters-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(46px, 1fr));
        gap: 0.55rem;
      }

      .letters-grid button {
        border: none;
        border-radius: 0.95rem;
        padding: 0.5rem 0;
        font-weight: 600;
        background: var(--surface-1);
        cursor: pointer;
        box-shadow: var(--panel-shadow);
        transition: transform 0.15s ease, box-shadow 0.2s ease;
      }

      .letters-grid button:hover {
        transform: translateY(-1px);
        box-shadow: var(--letters-hover);
      }

      .letters-grid button.used {
        opacity: 0.45;
        box-shadow: none;
        cursor: default;
      }

      .game-controls {
        display: grid;
        gap: 1rem;
      }

      .game-controls .control-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.4rem 0.85rem;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface-1);
      }

      .game-feedback {
        display: grid;
        gap: 1rem;
      }

      .game-feedback .card {
        border-radius: 1.5rem;
        border: 1px solid var(--panel-border);
        background: var(--surface-2);
        padding: 1.25rem;
        box-shadow: var(--panel-shadow);
      }

      .game-feedback .card strong {
        font-size: 1rem;
      }

      .settings-modal {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(12px);
        display: grid;
        place-items: center;
        padding: 2rem;
        z-index: 40;
      }

      .settings-body {
        max-width: 720px;
        width: 100%;
        background: var(--panel-glass);
        border: 1px solid var(--panel-border);
        border-radius: 1.75rem;
        padding: 2rem;
        box-shadow: var(--panel-shadow);
        display: grid;
        gap: 1.25rem;
      }

      .settings-body h3 {
        margin: 0;
        font-size: 1.2rem;
      }

      .settings-grid {
        display: grid;
        gap: 1rem;
      }

      .settings-grid label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font-size: 0.95rem;
      }

      .settings-grid input[type="range"],
      .settings-grid input[type="number"],
      .settings-grid select {
        width: 100%;
      }

      .settings-grid input,
      .settings-grid select {
        border-radius: 0.85rem;
        border: 1px solid var(--border);
        background: var(--surface-1);
        padding: 0.45rem 0.75rem;
        color: inherit;
        font: inherit;
      }

      .settings-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <template id="mishkah-index">
      <style>
        :host {
          display: block;
        }
      </style>

      <div class="page-shell">
        <header class="header app-card">
          <div class="header-inner">
            <div class="intro">
              <h1>{translate(state, 'app.title')}</h1>
              <p>{translate(state, 'header.subtitle')}</p>
            </div>

            <div class="status-strip" x-if="state.data.activeTab === 'game'">
              <div class="status-block">
                <span>‚è≥ {translate(state, 'game.timeLabel')}</span>
                <strong>{formatTimeLeft(state.data.game)}</strong>
              </div>
              <div class="status-block">
                <span>‚ù§Ô∏è {translate(state, 'game.tries')}</span>
                <div class="hearts-row">
                  <span
                    x-for="i in range(state.data.game.triesMax)"
                    key="i"
                    class="{ i < state.data.game.triesLeft ? '' : 'opacity-45' }"
                    >{i < state.data.game.triesLeft ? '‚ù§Ô∏è' : 'üíî'}</span
                  >
                </div>
              </div>
              <div class="status-block">
                <span>üéØ {translate(state, 'game.statusLabel')}</span>
                <strong>{translate(state, 'game.status.' + state.data.game.status)}</strong>
              </div>
            </div>

            <div class="controls">
              <div class="segmented">
                <button class="{state.env.theme === 'light' ? 'active' : ''}" onclick="setTheme('light', ctx)">
                  üåû {translate(state, 'header.theme.light')}
                </button>
                <button class="{state.env.theme === 'dark' ? 'active' : ''}" onclick="setTheme('dark', ctx)">
                  üåô {translate(state, 'header.theme.dark')}
                </button>
              </div>
              <div class="segmented">
                <button class="{state.env.lang === 'ar' ? 'active' : ''}" onclick="setLanguage('ar', ctx)">
                  ÿπ {translate(state, 'header.lang.ar')}
                </button>
                <button class="{state.env.lang === 'en' ? 'active' : ''}" onclick="setLanguage('en', ctx)">
                  EN {translate(state, 'header.lang.en')}
                </button>
              </div>
              <button class="button secondary" onclick="toggleSettings(ctx)">
                ‚öôÔ∏è {translate(state, 'settings.open')}
              </button>
              <button class="button" x-if="state.data.activeTab === 'game'" onclick="startGame(ctx)">
                {state.data.game.status === 'running'
                  ? translate(state, 'game.new')
                  : translate(state, 'game.start')}
              </button>
            </div>
          </div>
        </header>

        <div class="layout">
          <aside class="sidebar">
            <div class="app-card sidebar-card">
              <h2>{translate(state, 'nav.menu')}</h2>
              <div class="nav-list">
                <button class="nav-button {state.data.activeTab === 'readmeBase' ? 'active' : ''}" onclick="switchTab('readmeBase', ctx)">
                  {translate(state, 'nav.readmeBase')}
                  <span class="hint">{translate(state, 'doc.base.lead')}</span>
                </button>
                <button class="nav-button {state.data.activeTab === 'readmeTec' ? 'active' : ''}" onclick="switchTab('readmeTec', ctx)">
                  {translate(state, 'nav.readmeTec')}
                  <span class="hint">{translate(state, 'doc.tec.lead')}</span>
                </button>
                <button class="nav-button {state.data.activeTab === 'counter' ? 'active' : ''}" onclick="switchTab('counter', ctx)">
                  {translate(state, 'nav.counter')}
                  <span class="hint">{translate(state, 'counter.lead')}</span>
                </button>
                <button class="nav-button {state.data.activeTab === 'logic' ? 'active' : ''}" onclick="switchTab('logic', ctx)">
                  {translate(state, 'nav.logic')}
                  <span class="hint">{translate(state, 'logic.lead')}</span>
                </button>
                <button class="nav-button {state.data.activeTab === 'game' ? 'active' : ''}" onclick="switchTab('game', ctx)">
                  {translate(state, 'nav.game')}
                  <span class="hint">{translate(state, 'game.lead')}</span>
                </button>
              </div>
            </div>
          </aside>

          <div class="main-column">
            <section class="panel" x-if="state.data.activeTab === 'readmeBase'">
              <header>
                <h2>{translate(state, 'nav.readmeBase')}</h2>
                <p>{translate(state, 'doc.language.hint')}</p>
              </header>
              <article class="md-prose" x-html="state.data.docs.base[state.env.lang]"></article>
            </section>

            <section class="panel" x-if="state.data.activeTab === 'readmeTec'">
              <header>
                <h2>{translate(state, 'nav.readmeTec')}</h2>
                <p>{translate(state, 'doc.language.hint')}</p>
              </header>
              <article class="md-prose" x-html="state.data.docs.tec[state.env.lang]"></article>
            </section>

            <section class="panel" x-if="state.data.activeTab === 'counter'">
              <header>
                <h2>{translate(state, 'counter.title')}</h2>
                <p>{translate(state, 'counter.lead')}</p>
              </header>
              <div class="counter-view">
                <button class="button secondary" onclick="updateCounter(-1, ctx)">‚àí</button>
                <div class="counter-display">{state.data.counter}</div>
                <button class="button" onclick="updateCounter(+1, ctx)">+</button>
                <button class="button secondary" onclick="resetCounter(ctx)" data-m-once>
                  {translate(state, 'counter.reset')}
                </button>
              </div>
            </section>

            <section class="panel" x-if="state.data.activeTab === 'logic'">
              <header>
                <h2>{translate(state, 'logic.title')}</h2>
                <p>{translate(state, 'logic.subtitle')}</p>
              </header>
              <div class="logic-sequence">
                <div class="term" x-for="term, idx in state.data.logicGame.sequence" key="idx">{term}</div>
                <div class="term">?</div>
              </div>
              <div class="logic-options">
                <button
                  x-for="option in state.data.logicGame.options"
                  key="option"
                  class="{logicOptionClass(option, state.data.logicGame)}"
                  onclick="chooseLogic(option, ctx)"
                >
                  {option}
                </button>
              </div>
              <div class="game-feedback" x-if="state.data.logicGame.feedback">
                <div class="card">
                  <strong>{logicFeedbackTitle(state)}</strong>
                  <p>{logicFeedbackMessage(state)}</p>
                </div>
              </div>
              <div class="controls" style="margin-top: 1.5rem;">
                <button class="button" onclick="startLogic(ctx)">
                  {translate(state, state.data.logicGame.sequence.length ? 'logic.newChallenge' : 'logic.start')}
                </button>
              </div>
            </section>

            <section class="panel" x-if="state.data.activeTab === 'game'">
              <header>
                <h2>{translate(state, 'game.title')}</h2>
                <p>{translate(state, 'game.subtitle')}</p>
              </header>
              <div class="game-board">
                <div class="puzzle-row">
                  <div
                    class="{tileClass(ch, state.data.game)}"
                    x-for="ch, idx in state.data.game.proverb ? state.data.game.proverb.t.split('') : []"
                    key="idx"
                  >
                    {tileContent(ch, state.data.game)}
                  </div>
                </div>
                <div class="letters-grid">
                  <button
                    x-for="letter in state.data.alphabet"
                    key="letter"
                    class="{letterClass(letter, state.data.game)}"
                    onclick="chooseLetter(letter, ctx)"
                  >
                    {letter}
                  </button>
                </div>
                <div class="game-controls">
                  <div class="control-row">
                    <span class="toggle">
                      <input type="checkbox" onclick="toggleMusic(event, ctx)" checked="{state.data.game.musicOn ? 'checked' : null}" />
                      <span>
                        {state.data.game.musicOn
                          ? translate(state, 'game.musicOn')
                          : translate(state, 'game.musicOff')}
                      </span>
                    </span>
                    <select onchange="selectTrack(event, ctx)">
                      <option
                        x-for="track, idx in state.data.game.audioList"
                        key="track.url"
                        value="{idx}"
                        selected="{idx === state.data.game.audioIdx ? 'selected' : null}"
                      >
                        {track.name}
                      </option>
                    </select>
                  </div>
                  <div class="control-row">
                    <span class="toggle">
                      <input type="checkbox" onclick="toggleTimer(event, ctx)" checked="{state.data.game.timerOn ? 'checked' : null}" />
                      <span>
                        {state.data.game.timerOn
                          ? translate(state, 'game.timerOn')
                          : translate(state, 'game.timerOff')}
                      </span>
                    </span>
                    <label>
                      {translate(state, 'game.timerSeconds')}
                      <input type="number" min="5" max="300" value="{state.data.game.timerSec}" onchange="setTimerSeconds(event, ctx)" />
                    </label>
                  </div>
                </div>
                <div class="game-feedback">
                  <div class="card" x-if="state.data.game.feedback">
                    <strong>{gameFeedbackTitle(state)}</strong>
                    <p>{gameFeedbackMessage(state)}</p>
                  </div>
                  <div class="card" x-if="state.data.game.proverb">
                    <strong>üí° {translate(state, 'game.hintTitle')}</strong>
                    <p>{state.data.game.proverb.hint}</p>
                  </div>
                  <div class="card" x-if="state.data.game.revealSolution && state.data.game.proverb">
                    <strong>üìú {translate(state, 'game.solution')}</strong>
                    <p>{translate(state, 'game.explanation')}: {state.data.game.proverb.explanation}</p>
                    <p>{translate(state, 'game.lesson')}: {state.data.game.proverb.lesson}</p>
                    <p class="hint">{translate(state, 'game.source')}: {state.data.game.proverb.source}</p>
                  </div>
                </div>
                <audio
                  class="hidden"
                  x-if="state.data.game.musicOn && state.data.game.status === 'running'"
                  src="{state.data.game.audioList[state.data.game.audioIdx].url}"
                  autoplay
                  loop
                ></audio>
                <audio
                  class="hidden"
                  x-if="state.data.game.feedback && state.data.game.feedback.sound"
                  src="{state.data.game.feedback.sound}"
                  autoplay
                ></audio>
              </div>
              <div class="controls" style="margin-top: 1.5rem;">
                <button class="button" onclick="startGame(ctx)">
                  {state.data.game.status === 'running'
                    ? translate(state, 'game.new')
                    : translate(state, 'game.start')}
                </button>
                <button class="button secondary" x-if="state.data.game.status === 'lost'" onclick="revealSolution(ctx)">
                  {translate(state, 'game.reveal')}
                </button>
              </div>
            </section>
          </div>
        </div>

        <div class="settings-modal" x-if="state.data.settingsOpen" onclick="closeSettings(event, ctx)">
          <div class="settings-body" onclick="event.stopPropagation()">
            <h3>{translate(state, 'settings.title')}</h3>
            <div class="settings-grid">
              <label>
                {translate(state, 'settings.fontLabel')} ({state.data.themePrefs.fontScale}%)
                <input type="range" min="85" max="130" step="5" value="{state.data.themePrefs.fontScale}" onchange="setFontScale(event, ctx)" />
              </label>
              <label>
                {translate(state, 'settings.background')}
                <select onchange="setBackgroundPreset(event, ctx)">
                  <option
                    x-for="preset in state.data.backgrounds"
                    key="preset.id"
                    value="{preset.id}"
                    selected="{preset.id === state.data.themePrefs.background ? 'selected' : null}"
                  >
                    {preset.label[state.env.lang] || preset.label.ar}
                  </option>
                </select>
              </label>
            </div>
            <div class="settings-actions">
              <button class="button secondary" onclick="resetThemePrefs(ctx)">
                {translate(state, 'settings.reset')}
              </button>
              <button class="button" onclick="toggleSettings(ctx)">
                {translate(state, 'settings.close')}
              </button>
            </div>
          </div>
        </div>
      </div>

      <script>
        function getHelpers() {
          return window.__INDEX || {};
        }

        function cloneState(prev) {
          return JSON.parse(JSON.stringify(prev || {}));
        }

        function translate(state, key) {
          var helpers = getHelpers();
          var dict = helpers.STRINGS || {};
          var entry = dict[key];
          if (!entry) return key;
          var lang = (state.env && state.env.lang) || 'ar';
          return entry[lang] || entry.ar || entry.en || key;
        }

        function range(count) {
          var len = Math.max(0, Number(count) || 0);
          var out = [];
          for (var i = 0; i < len; i++) out.push(i);
          return out;
        }

        function formatTimeLeft(game) {
          if (!game || !game.timerOn) return '‚Äî';
          var value = typeof game.timeLeft === 'number' ? game.timeLeft : game.timerSec;
          return value >= 0 ? value : '‚Äî';
        }

        function logicOptionClass(option, game) {
          if (!game || !game.feedback) return '';
          if (option === game.answer) return 'correct';
          if (game.selected === option) return 'wrong';
          return '';
        }

        function logicFeedbackTitle(state) {
          var game = state && state.data && state.data.logicGame;
          if (!game || !game.feedback) return '';
          var type = game.feedback.type === 'correct' ? 'correct' : 'wrong';
          var key = type === 'correct' ? 'logic.feedback.correct' : 'logic.feedback.wrong';
          var emoji = type === 'correct' ? '‚úÖ ' : '‚ö†Ô∏è ';
          return emoji + translate(state, key);
        }

        function logicFeedbackMessage(state) {
          var game = state && state.data && state.data.logicGame;
          if (!game || !game.feedback) return '';
          var message = game.feedback.message;
          var lang = (state.env && state.env.lang) || 'ar';
          if (typeof message === 'function') {
            return message(lang);
          }
          if (typeof message === 'string') {
            return message;
          }
          if (message && typeof message === 'object') {
            return message[lang] || message.ar || message.en || '';
          }
          return '';
        }

        function tileClass(ch, game) {
          if (ch === ' ') return 'puzzle-tile space';
          var helpers = getHelpers();
          var norm = helpers.normLetter ? helpers.normLetter(ch) : ch;
          var revealed = game && game.guessed && game.guessed[norm];
          return 'puzzle-tile' + (revealed ? ' revealed' : '');
        }

        function tileContent(ch, game) {
          if (ch === ' ') return '';
          var helpers = getHelpers();
          var norm = helpers.normLetter ? helpers.normLetter(ch) : ch;
          return game && game.guessed && game.guessed[norm] ? ch : '‚Ä¢';
        }

        function letterClass(letter, game) {
          if (!game) return '';
          var helpers = getHelpers();
          var norm = helpers.normLetter ? helpers.normLetter(letter) : letter;
          return game.guessed && game.guessed[norm] ? 'used' : '';
        }

        function gameFeedbackTitle(state) {
          var game = state && state.data && state.data.game;
          if (!game || !game.feedback) return '';
          var emojiMap = { correct: '‚úÖ', wrong: '‚ö†Ô∏è', win: 'üèÜ', lose: 'üíî' };
          var keyMap = {
            correct: 'game.feedback.correct',
            wrong: 'game.feedback.wrong',
            win: 'game.feedback.win',
            lose: 'game.feedback.lose'
          };
          var type = game.feedback.type;
          var emoji = emojiMap[type] || '‚ú®';
          var key = keyMap[type] || 'game.feedback.correct';
          return emoji + ' ' + translate(state, key);
        }

        function gameFeedbackMessage(state) {
          var game = state && state.data && state.data.game;
          if (!game || !game.feedback) return '';
          var keyMap = {
            correct: 'game.feedback.correct',
            wrong: 'game.feedback.wrong',
            win: 'game.feedback.win',
            lose: 'game.feedback.lose'
          };
          var key = keyMap[game.feedback.type] || 'game.feedback.correct';
          return translate(state, key);
        }

        function switchTab(tab, ctx) {
          if (!ctx) return;
          ctx.set('data.activeTab', tab);
        }

        function setTheme(theme, ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.env.theme = theme;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyEnvironment) helpers.applyEnvironment(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        }

        function setLanguage(lang, ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.env.lang = lang;
            next.env.dir = lang === 'ar' ? 'rtl' : 'ltr';
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyEnvironment) helpers.applyEnvironment(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        }

        function toggleSettings(ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.data.settingsOpen = !next.data.settingsOpen;
            return next;
          });
        }

        function updateCounter(delta, ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var value = typeof next.data.counter === 'number' ? next.data.counter : 0;
            next.data.counter = value + delta;
            return next;
          });
        }

        function resetCounter(ctx) {
          if (!ctx) return;
          ctx.set('data.counter', 0);
        }

        function startLogic(ctx) {
          if (!ctx) return;
          var helpers = getHelpers();
          var generators = helpers.LOGIC_GENERATORS || [];
          if (!generators.length) return;
          var generator = generators[Math.floor(Math.random() * generators.length)];
          var challenge = generator(helpers);
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var logic = next.data.logicGame;
            logic.sequence = challenge.sequence;
            logic.options = challenge.options;
            logic.answer = challenge.answer;
            logic.feedback = null;
            logic.explain = challenge.message;
            logic.selected = null;
            return next;
          });
        }

        function chooseLogic(option, ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var logic = next.data.logicGame;
            if (!Array.isArray(logic.options) || !logic.options.length) return prev;
            if (logic.feedback && logic.feedback.type === 'correct') return prev;
            var isCorrect = option === logic.answer;
            logic.selected = option;
            logic.feedback = {
              type: isCorrect ? 'correct' : 'wrong',
              message: logic.explain
            };
            return next;
          });
        }

        function startGame(ctx) {
          if (!ctx) return;
          var helpers = getHelpers();
          if (helpers.clearTimer) helpers.clearTimer();
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var game = next.data.game;
            var list = helpers.PROVERBS || [];
            var proverb = list.length ? list[Math.floor(Math.random() * list.length)] : null;
            game.proverb = proverb;
            game.guessed = {};
            game.triesLeft = game.triesMax;
            game.status = 'running';
            game.revealSolution = false;
            game.feedback = null;
            game.timeLeft = game.timerOn ? game.timerSec : 0;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyEnvironment) helpers.applyEnvironment(state);
            if (state.data.game.timerOn && state.data.game.status === 'running' && helpers.startTimer) {
              helpers.startTimer(ctx);
            }
          }, 0);
        }

        function chooseLetter(letter, ctx) {
          if (!ctx) return;
          var helpers = getHelpers();
          var normValue = helpers.normLetter ? helpers.normLetter(letter) : letter;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var game = next.data.game;
            if (!game || game.status !== 'running') return prev;
            if (game.guessed[normValue]) return prev;
            game.guessed[normValue] = true;
            var proverb = game.proverb;
            var hasLetter = proverb && proverb.t.split('').some(function (ch) {
              return (helpers.normLetter ? helpers.normLetter(ch) : ch) === normValue;
            });
            var sounds = helpers.SOUND_EFFECTS || {};
            if (!hasLetter) {
              game.triesLeft = Math.max(0, game.triesLeft - 1);
              game.feedback = { type: 'wrong', sound: sounds.wrong || '' };
            } else {
              game.feedback = { type: 'correct', sound: sounds.correct || '' };
            }
            if (helpers.checkSolved && helpers.checkSolved(game)) {
              game.status = 'won';
              game.revealSolution = true;
              game.feedback = { type: 'win', sound: sounds.win || '' };
              game.timeLeft = game.timerOn ? game.timeLeft : 0;
              if (helpers.clearTimer) helpers.clearTimer();
            } else if (game.triesLeft <= 0) {
              game.status = 'lost';
              game.revealSolution = true;
              game.feedback = { type: 'lose', sound: sounds.lose || '' };
              if (helpers.clearTimer) helpers.clearTimer();
            }
            return next;
          });
        }

        function toggleMusic(event, ctx) {
          if (!ctx) return;
          var checked = !!(event && event.target && event.target.checked);
          ctx.set('data.game.musicOn', checked);
        }

        function selectTrack(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var idx = parseInt(event.target.value, 10);
          if (!Number.isFinite(idx)) idx = 0;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var list = next.data.game.audioList || [];
            next.data.game.audioIdx = Math.max(0, Math.min(idx, list.length - 1));
            return next;
          });
        }

        function toggleTimer(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var helpers = getHelpers();
          var checked = !!event.target.checked;
          if (helpers.clearTimer) helpers.clearTimer();
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var game = next.data.game;
            game.timerOn = checked;
            game.timeLeft = checked ? game.timerSec : 0;
            if (!checked && game.status === 'running') {
              game.status = 'idle';
            }
            return next;
          });
          window.setTimeout(function () {
            var state = ctx.getState();
            if (state.data.game.status === 'running' && state.data.game.timerOn && helpers.startTimer) {
              helpers.startTimer(ctx);
            }
          }, 0);
        }

        function setTimerSeconds(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var value = parseInt(event.target.value, 10);
          if (!Number.isFinite(value)) return;
          value = Math.min(300, Math.max(5, value));
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var game = next.data.game;
            game.timerSec = value;
            if (game.timerOn) {
              game.timeLeft = value;
            }
            return next;
          });
        }

        function revealSolution(ctx) {
          if (!ctx) return;
          ctx.set('data.game.revealSolution', true);
        }

        function closeSettings(event, ctx) {
          if (!ctx) return;
          if (event && event.target && event.currentTarget && event.target !== event.currentTarget) {
            return;
          }
          ctx.set('data.settingsOpen', false);
        }

        function setFontScale(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var value = parseInt(event.target.value, 10);
          if (!Number.isFinite(value)) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.data.themePrefs.fontScale = value;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyThemePrefs) helpers.applyThemePrefs(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        }

        function setBackgroundPreset(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var id = event.target.value;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.data.themePrefs.background = id;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyThemePrefs) helpers.applyThemePrefs(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        }

        function resetThemePrefs(ctx) {
          if (!ctx) return;
          var helpers = getHelpers();
          var defaults = helpers.defaultThemePrefs ? helpers.defaultThemePrefs() : { fontScale: 100, background: 'nebula' };
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.data.themePrefs = defaults;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyThemePrefs) helpers.applyThemePrefs(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        }
      </script>
    
      
    </template>

    <script src="./mishkah-utils.js"></script>
    <script src="./mishkah.core.js"></script>
    <script src="./readme.js"></script>
    <script src="./dist/mishkah-htmlx.js"></script>

    <script>
      (function (window) {
        'use strict';

        var M = window.Mishkah;
        if (!M || !M.HTMLxAgent) {
          console.error('Mishkah HTMLx agent is required.');
          return;
        }

        var helpers = window.__INDEX = window.__INDEX || {};
        var STORAGE_KEY = 'mishkah:htmlx:index:prefs';

        function exposeHelper(name, fn) {
          helpers[name] = fn;
          window[name] = fn;
          return fn;
        }

        var getHelpers = exposeHelper('getHelpers', function getHelpers() {
          return window.__INDEX || {};
        });

        var cloneState = exposeHelper('cloneState', function cloneState(prev) {
          return JSON.parse(JSON.stringify(prev || {}));
        });

        var translate = exposeHelper('translate', function translate(state, key) {
          if (!key) return '';
          var helpers = getHelpers();
          var dict = (state && state.i18n && state.i18n.strings) || helpers.STRINGS || {};
          var entry = dict[key];
          if (!entry) return key;
          var lang = (state && state.env && state.env.lang) || 'ar';
          return entry[lang] || entry.ar || entry.en || key;
        });

        exposeHelper('range', function range(count) {
          var len = Math.max(0, Number(count) || 0);
          var out = [];
          for (var i = 0; i < len; i++) out.push(i);
          return out;
        });

        exposeHelper('formatTimeLeft', function formatTimeLeft(game) {
          if (!game || !game.timerOn) return '‚Äî';
          var value = typeof game.timeLeft === 'number' ? game.timeLeft : game.timerSec;
          return value >= 0 ? value : '‚Äî';
        });

        exposeHelper('logicOptionClass', function logicOptionClass(option, game) {
          if (!game || !game.feedback) return '';
          if (option === game.answer) return 'correct';
          if (game.selected === option) return 'wrong';
          return '';
        });

        exposeHelper('logicFeedbackTitle', function logicFeedbackTitle(state) {
          var game = state && state.data && state.data.logicGame;
          if (!game || !game.feedback) return '';
          var type = game.feedback.type === 'correct' ? 'correct' : 'wrong';
          var key = type === 'correct' ? 'logic.feedback.correct' : 'logic.feedback.wrong';
          var emoji = type === 'correct' ? '‚úÖ ' : '‚ö†Ô∏è ';
          return emoji + translate(state, key);
        });

        exposeHelper('logicFeedbackMessage', function logicFeedbackMessage(state) {
          var game = state && state.data && state.data.logicGame;
          if (!game || !game.feedback) return '';
          var message = game.feedback.message;
          var lang = (state.env && state.env.lang) || 'ar';
          if (typeof message === 'function') {
            return message(lang);
          }
          if (typeof message === 'string') {
            return message;
          }
          if (message && typeof message === 'object') {
            return message[lang] || message.ar || message.en || '';
          }
          return '';
        });

        exposeHelper('tileClass', function tileClass(ch, game) {
          if (ch === ' ') return 'puzzle-tile space';
          var helpers = getHelpers();
          var norm = helpers.normLetter ? helpers.normLetter(ch) : ch;
          var revealed = game && game.guessed && game.guessed[norm];
          return 'puzzle-tile' + (revealed ? ' revealed' : '');
        });

        exposeHelper('tileContent', function tileContent(ch, game) {
          if (ch === ' ') return '';
          var helpers = getHelpers();
          var norm = helpers.normLetter ? helpers.normLetter(ch) : ch;
          return game && game.guessed && game.guessed[norm] ? ch : '‚Ä¢';
        });

        exposeHelper('letterClass', function letterClass(letter, game) {
          if (!game) return '';
          var helpers = getHelpers();
          var norm = helpers.normLetter ? helpers.normLetter(letter) : letter;
          return game.guessed && game.guessed[norm] ? 'used' : '';
        });

        exposeHelper('gameFeedbackTitle', function gameFeedbackTitle(state) {
          var game = state && state.data && state.data.game;
          if (!game || !game.feedback) return '';
          var emojiMap = { correct: '‚úÖ', wrong: '‚ö†Ô∏è', win: 'üèÜ', lose: 'üíî' };
          var keyMap = {
            correct: 'game.feedback.correct',
            wrong: 'game.feedback.wrong',
            win: 'game.feedback.win',
            lose: 'game.feedback.lose'
          };
          var type = game.feedback.type;
          var emoji = emojiMap[type] || '‚ú®';
          var key = keyMap[type] || 'game.feedback.correct';
          return emoji + ' ' + translate(state, key);
        });

        exposeHelper('gameFeedbackMessage', function gameFeedbackMessage(state) {
          var game = state && state.data && state.data.game;
          if (!game || !game.feedback) return '';
          var keyMap = {
            correct: 'game.feedback.correct',
            wrong: 'game.feedback.wrong',
            win: 'game.feedback.win',
            lose: 'game.feedback.lose'
          };
          var key = keyMap[game.feedback.type] || 'game.feedback.correct';
          return translate(state, key);
        });

        exposeHelper('switchTab', function switchTab(tab, ctx) {
          if (!ctx) return;
          ctx.set('data.activeTab', tab);
        });

        exposeHelper('setTheme', function setTheme(theme, ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.env.theme = theme;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyEnvironment) helpers.applyEnvironment(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        });

        exposeHelper('setLanguage', function setLanguage(lang, ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.env.lang = lang;
            next.env.dir = lang === 'ar' ? 'rtl' : 'ltr';
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyEnvironment) helpers.applyEnvironment(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        });

        exposeHelper('toggleSettings', function toggleSettings(ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.data.settingsOpen = !next.data.settingsOpen;
            return next;
          });
        });

        exposeHelper('updateCounter', function updateCounter(delta, ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var value = typeof next.data.counter === 'number' ? next.data.counter : 0;
            next.data.counter = value + delta;
            return next;
          });
        });

        exposeHelper('resetCounter', function resetCounter(ctx) {
          if (!ctx) return;
          ctx.set('data.counter', 0);
        });

        exposeHelper('startLogic', function startLogic(ctx) {
          if (!ctx) return;
          var helpers = getHelpers();
          var generators = helpers.LOGIC_GENERATORS || [];
          if (!generators.length) return;
          var generator = generators[Math.floor(Math.random() * generators.length)];
          var challenge = generator(helpers);
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var logic = next.data.logicGame;
            logic.sequence = challenge.sequence;
            logic.options = challenge.options;
            logic.answer = challenge.answer;
            logic.feedback = null;
            logic.explain = challenge.message;
            logic.selected = null;
            return next;
          });
        });

        exposeHelper('chooseLogic', function chooseLogic(option, ctx) {
          if (!ctx) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var logic = next.data.logicGame;
            if (!Array.isArray(logic.options) || !logic.options.length) return prev;
            if (logic.feedback && logic.feedback.type === 'correct') return prev;
            var isCorrect = option === logic.answer;
            logic.selected = option;
            logic.feedback = {
              type: isCorrect ? 'correct' : 'wrong',
              message: logic.explain
            };
            return next;
          });
        });

        exposeHelper('startGame', function startGame(ctx) {
          if (!ctx) return;
          var helpers = getHelpers();
          if (helpers.clearTimer) helpers.clearTimer();
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var game = next.data.game;
            var list = helpers.PROVERBS || [];
            var proverb = list.length ? list[Math.floor(Math.random() * list.length)] : null;
            game.proverb = proverb;
            game.guessed = {};
            game.triesLeft = game.triesMax;
            game.status = 'running';
            game.revealSolution = false;
            game.feedback = null;
            game.timeLeft = game.timerOn ? game.timerSec : 0;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyEnvironment) helpers.applyEnvironment(state);
            if (state.data.game.timerOn && state.data.game.status === 'running' && helpers.startTimer) {
              helpers.startTimer(ctx);
            }
          }, 0);
        });

        exposeHelper('chooseLetter', function chooseLetter(letter, ctx) {
          if (!ctx) return;
          var helpers = getHelpers();
          var normValue = helpers.normLetter ? helpers.normLetter(letter) : letter;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var game = next.data.game;
            if (!game || game.status !== 'running') return prev;
            if (game.guessed[normValue]) return prev;
            game.guessed[normValue] = true;
            var proverb = game.proverb;
            var hasLetter = proverb && proverb.t.split('').some(function (ch) {
              return (helpers.normLetter ? helpers.normLetter(ch) : ch) === normValue;
            });
            var sounds = helpers.SOUND_EFFECTS || {};
            if (!hasLetter) {
              game.triesLeft = Math.max(0, game.triesLeft - 1);
              game.feedback = { type: 'wrong', sound: sounds.wrong || '' };
            } else {
              game.feedback = { type: 'correct', sound: sounds.correct || '' };
            }
            if (helpers.checkSolved && helpers.checkSolved(game)) {
              game.status = 'won';
              game.revealSolution = true;
              game.feedback = { type: 'win', sound: sounds.win || '' };
              game.timeLeft = game.timerOn ? game.timeLeft : 0;
              if (helpers.clearTimer) helpers.clearTimer();
            } else if (game.triesLeft <= 0) {
              game.status = 'lost';
              game.revealSolution = true;
              game.feedback = { type: 'lose', sound: sounds.lose || '' };
              if (helpers.clearTimer) helpers.clearTimer();
            }
            return next;
          });
        });

        exposeHelper('toggleMusic', function toggleMusic(event, ctx) {
          if (!ctx) return;
          var checked = !!(event && event.target && event.target.checked);
          ctx.set('data.game.musicOn', checked);
        });

        exposeHelper('selectTrack', function selectTrack(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var idx = parseInt(event.target.value, 10);
          if (!Number.isFinite(idx)) idx = 0;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var list = next.data.game.audioList || [];
            next.data.game.audioIdx = Math.max(0, Math.min(idx, list.length - 1));
            return next;
          });
        });

        exposeHelper('toggleTimer', function toggleTimer(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var helpers = getHelpers();
          var checked = !!event.target.checked;
          if (helpers.clearTimer) helpers.clearTimer();
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var game = next.data.game;
            game.timerOn = checked;
            game.timeLeft = checked ? game.timerSec : 0;
            if (!checked && game.status === 'running') {
              game.status = 'idle';
            }
            return next;
          });
          window.setTimeout(function () {
            var state = ctx.getState();
            if (state.data.game.status === 'running' && state.data.game.timerOn && helpers.startTimer) {
              helpers.startTimer(ctx);
            }
          }, 0);
        });

        exposeHelper('setTimerSeconds', function setTimerSeconds(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var value = parseInt(event.target.value, 10);
          if (!Number.isFinite(value)) return;
          value = Math.min(300, Math.max(5, value));
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            var game = next.data.game;
            game.timerSec = value;
            if (game.timerOn) {
              game.timeLeft = value;
            }
            return next;
          });
        });

        exposeHelper('revealSolution', function revealSolution(ctx) {
          if (!ctx) return;
          ctx.set('data.game.revealSolution', true);
        });

        exposeHelper('closeSettings', function closeSettings(event, ctx) {
          if (!ctx) return;
          if (event && event.target && event.currentTarget && event.target !== event.currentTarget) {
            return;
          }
          ctx.set('data.settingsOpen', false);
        });

        exposeHelper('setFontScale', function setFontScale(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var value = parseInt(event.target.value, 10);
          if (!Number.isFinite(value)) return;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.data.themePrefs.fontScale = value;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyThemePrefs) helpers.applyThemePrefs(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        });

        exposeHelper('setBackgroundPreset', function setBackgroundPreset(event, ctx) {
          if (!ctx || !event || !event.target) return;
          var id = event.target.value;
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.data.themePrefs.background = id;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyThemePrefs) helpers.applyThemePrefs(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        });

        exposeHelper('resetThemePrefs', function resetThemePrefs(ctx) {
          if (!ctx) return;
          var helpers = getHelpers();
          var defaults = helpers.defaultThemePrefs ? helpers.defaultThemePrefs() : { fontScale: 100, background: 'nebula' };
          ctx.setState(function (prev) {
            var next = cloneState(prev);
            next.data.themePrefs = defaults;
            return next;
          });
          window.setTimeout(function () {
            var helpers = getHelpers();
            var state = ctx.getState();
            if (helpers.applyThemePrefs) helpers.applyThemePrefs(state);
            if (helpers.persistPrefs) helpers.persistPrefs(state);
          }, 0);
        });

        var STRINGS = {
          'app.title': { ar: 'ŸÖÿ¥ŸÉÿßÿ© ‚Äî ÿ™ÿ¨ÿ±ÿ®ÿ© HTMLx', en: 'Mishkah ‚Äî HTMLx Experience' },
          'header.subtitle': {
            ar: 'ŸÜŸÖŸàÿ∞ÿ¨ ŸÖÿ®ÿ≥ÿ∑ Ÿäÿπÿ±ÿ∂ ÿßŸÑÿ™ÿ®ŸàŸäÿ®ÿßÿ™ÿå ÿßŸÑÿπÿØÿßÿØÿßÿ™ÿå Ÿàÿ™ÿ≠ÿØŸäÿßÿ™ Mishkah ÿØŸàŸÜ ŸÑÿ∫ÿ© DSL.',
            en: 'A lightweight showcase of tabs, counters, and Mishkah challenges without the legacy DSL.'
          },
          'header.theme.light': { ar: 'ŸÜŸáÿßÿ±Ÿä', en: 'Light' },
          'header.theme.dark': { ar: 'ŸÑŸäŸÑŸä', en: 'Dark' },
          'header.lang.ar': { ar: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', en: 'Arabic' },
          'header.lang.en': { ar: 'ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©', en: 'English' },
          'nav.menu': { ar: 'ÿßŸÑÿ™ÿµŸÅŸëÿ≠', en: 'Navigation' },
          'nav.readmeBase': { ar: 'ÿßŸÑÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÖÿπŸÖÿßÿ±Ÿäÿ©', en: 'Architectural Journey' },
          'nav.readmeTec': { ar: 'ÿßŸÑÿØŸÑŸäŸÑ ÿßŸÑÿ™ŸÇŸÜŸä', en: 'Technical Guide' },
          'nav.counter': { ar: 'ÿßŸÑÿπÿØÿßÿØ ÿßŸÑÿ™ŸÅÿßÿπŸÑŸä', en: 'Interactive Counter' },
          'nav.logic': { ar: 'ÿ™ÿ≠ÿØŸä ÿßŸÑŸÖŸÜÿ∑ŸÇ', en: 'Logic Challenge' },
          'nav.game': { ar: 'ŸÑÿπÿ®ÿ© ÿßŸÑÿ£ŸÖÿ´ÿßŸÑ', en: 'Proverbs Game' },
          'doc.base.lead': {
            ar: 'ŸÇÿ±ÿßÿ°ÿ© ÿ±Ÿàÿ≠Ÿäÿ© ŸÑŸÖÿπŸÖÿßÿ±Ÿäÿßÿ™ ŸÖÿ¥ŸÉÿßÿ© ŸàŸÖÿ≠ÿ±ŸÉŸáÿß.',
            en: "A reflective tour through Mishkah's architecture."
          },
          'doc.tec.lead': {
            ar: 'ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ™ŸÇŸÜŸä ÿßŸÑÿ∞Ÿä Ÿäÿ¥ÿ±ÿ≠ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÜÿ∏ÿßŸÖ.',
            en: 'The technical dossier explaining the system.'
          },
          'doc.language.hint': {
            ar: 'ÿ®ÿØŸëŸÑ ÿßŸÑŸÑÿ∫ÿ© ŸÖŸÜ ÿßŸÑÿ£ÿπŸÑŸâ ŸÑÿπÿ±ÿ∂ ÿßŸÑŸàÿ´ŸäŸÇÿ© ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ÿ£Ÿà ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©.',
            en: 'Use the header switcher to view the document in Arabic or English.'
          },
          'counter.title': { ar: 'ÿπÿØÿßÿØ ÿ®ÿ≥Ÿäÿ∑', en: 'Simple Counter' },
          'counter.lead': { ar: 'ŸÖÿ´ÿßŸÑ ŸäŸàÿ∂ÿ≠ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ£ŸàÿßŸÖÿ± HTMLx ŸÑŸÑÿ™ÿ≠ÿØŸäÿ´.', en: 'An example that shows HTMLx driven updates.' },
          'counter.reset': { ar: 'ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ∂ÿ®ÿ∑', en: 'Reset' },
          'logic.title': { ar: 'ÿ™ÿ≠ÿØŸä ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿ≥ÿ™ŸÇÿ±ÿßÿ¶Ÿä', en: 'Pattern Logic Trainer' },
          'logic.subtitle': { ar: 'ÿßÿ≥ÿ™ŸÉÿ¥ŸÅ ÿßŸÑŸÖÿ™ÿ™ÿßŸÑŸäÿßÿ™ ŸàÿµŸÇŸÑ ŸÖŸáÿßÿ±ÿ© ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿßŸÑŸÜŸÖÿ∑.', en: 'Explore sequences and sharpen your pattern sense.' },
          'logic.lead': { ar: 'ÿ≠ŸÑ ŸÖÿ™ÿ™ÿßŸÑŸäÿßÿ™ ÿ±ŸÇŸÖŸäÿ© ÿ®ÿ£ÿ≥ŸÑŸàÿ® ŸÖŸÖÿ™ÿπ.', en: 'Solve number sequences in a playful way.' },
          'logic.start': { ar: 'ÿßÿ®ÿØÿ£ ÿßŸÑÿ™ÿ≠ÿØŸä', en: 'Start challenge' },
          'logic.newChallenge': { ar: 'ÿ™ÿ≠ÿØŸç ÿ¨ÿØŸäÿØ', en: 'New challenge' },
          'logic.feedback.correct': { ar: 'ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©! ŸÖŸÜÿ∑ŸÇŸÉ ÿ≠ÿßÿ∂ÿ±.', en: 'Great choice! Your reasoning is sharp.' },
          'logic.feedback.wrong': { ar: 'ŸÑŸäÿ≥ÿ™ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©ÿå ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', en: 'Not quite right, try once more.' },
          'game.title': { ar: 'ŸÑÿπÿ®ÿ© ÿßŸÑÿ£ŸÖÿ´ÿßŸÑ ŸàÿßŸÑÿ≠ŸÉŸÖ', en: 'Proverbs & Wisdom Game' },
          'game.subtitle': { ar: 'ÿßŸÉÿ™ÿ¥ŸÅ ÿßŸÑÿ≠ŸÉŸÖÿ© ÿ®ÿ≠ÿ±ŸàŸÅ ÿπÿ±ÿ®Ÿäÿ© Ÿàÿ™ÿ≠ÿØŸäÿßÿ™ ÿ∞ŸÉŸäÿ©.', en: 'Unveil wisdom through Arabic letters and smart challenges.' },
          'game.lead': { ar: 'ŸÑÿπÿ®ÿ© ÿ™ŸÅÿßÿπŸÑŸäÿ© ŸÑŸÑÿ™ÿπÿ±ŸëŸÅ ÿπŸÑŸâ ÿßŸÑÿ£ŸÖÿ´ÿßŸÑ.', en: 'An interactive game to rediscover proverbs.' },
          'game.timeLabel': { ar: 'ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä', en: 'Time left' },
          'game.tries': { ar: 'ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™', en: 'Tries' },
          'game.statusLabel': { ar: 'ÿßŸÑÿ≠ÿßŸÑÿ©', en: 'Status' },
          'game.status.idle': { ar: 'ÿ¨ÿßŸáÿ≤ÿ©', en: 'Ready' },
          'game.status.running': { ar: 'ŸÇŸäÿØ ÿßŸÑŸÑÿπÿ®', en: 'Running' },
          'game.status.won': { ar: 'ÿßŸÜÿ™ÿµÿßÿ±', en: 'Victory' },
          'game.status.lost': { ar: 'ÿÆÿ≥ÿßÿ±ÿ©', en: 'Defeat' },
          'game.start': { ar: 'ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®ÿ©', en: 'Start game' },
          'game.new': { ar: 'ŸÖÿ´ŸÑ ÿ¨ÿØŸäÿØ', en: 'New proverb' },
          'game.musicOn': { ar: 'ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ŸÖŸÅÿπŸëŸÑÿ©', en: 'Music on' },
          'game.musicOff': { ar: 'ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ŸÖÿ™ŸàŸÇŸÅÿ©', en: 'Music off' },
          'game.timerOn': { ar: 'ÿßŸÑŸÖÿ§ŸÇÿ™ ŸÜÿ¥ÿ∑', en: 'Timer on' },
          'game.timerOff': { ar: 'ÿßŸÑŸÖÿ§ŸÇÿ™ ŸÖÿ™ŸàŸÇŸÅ', en: 'Timer off' },
          'game.timerSeconds': { ar: 'ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä', en: 'Seconds' },
          'game.hintTitle': { ar: 'ÿßŸÑÿ™ŸÑŸÖŸäÿ≠ ÿßŸÑÿ™ÿπŸÑŸäŸÖŸä', en: 'Educational hint' },
          'game.solution': { ar: 'ÿßŸÑÿ≠ŸÑ ÿßŸÑŸÉÿßŸÖŸÑ', en: 'Full solution' },
          'game.explanation': { ar: 'ÿßŸÑÿ¥ÿ±ÿ≠', en: 'Explanation' },
          'game.lesson': { ar: 'ÿßŸÑÿπÿ®ÿ±ÿ©', en: 'Lesson' },
          'game.source': { ar: 'ÿßŸÑŸÖÿµÿØÿ±', en: 'Source' },
          'game.feedback.correct': { ar: 'ÿ£ÿ≠ÿ≥ŸÜÿ™! ÿ≠ÿ±ŸÅ ÿµÿ≠Ÿäÿ≠.', en: 'Great! Correct letter.' },
          'game.feedback.wrong': { ar: 'Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑŸÖ ÿ™ÿµÿ® ÿßŸÑŸáÿØŸÅ.', en: 'That guess missed the mark.' },
          'game.feedback.win': { ar: 'ÿ•ÿ®ÿØÿßÿπ! ÿßŸÉÿ™ŸÖŸÑÿ™ ÿßŸÑÿ≠ŸÉŸÖÿ©.', en: 'Brilliant! Wisdom unveiled.' },
          'game.feedback.lose': { ar: 'ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™ÿå ŸÑÿß ÿ®ÿ£ÿ≥ ÿ£ŸÜ ÿ™ŸÉÿ¥ŸÅ ÿßŸÑÿ≠ŸÉŸÖÿ©.', en: 'No tries left, time to reveal the wisdom.' },
          'game.reveal': { ar: 'ÿßŸÉÿ™ÿ¥ŸÅ ÿßŸÑÿ≠ŸÉŸÖÿ©', en: 'Reveal wisdom' },
          'settings.open': { ar: 'ÿßŸÑÿ™ÿÆÿµŸäÿµ', en: 'Customize' },
          'settings.title': { ar: 'ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÖÿ∏Ÿáÿ±', en: 'Appearance settings' },
          'settings.fontLabel': { ar: 'ÿ≠ÿ¨ŸÖ ÿßŸÑÿÆÿ∑', en: 'Font scale' },
          'settings.background': { ar: 'ÿßŸÑÿÆŸÑŸÅŸäÿ©', en: 'Background' },
          'settings.reset': { ar: 'ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä', en: 'Reset defaults' },
          'settings.close': { ar: 'ÿ™ŸÖ', en: 'Done' }
        };
        helpers.STRINGS = STRINGS;

        var SOUND_EFFECTS = {
          correct: 'https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3',
          wrong: 'https://assets.mixkit.co/sfx/preview/mixkit-failure-arcade-alert-notification-240.mp3',
          win: 'https://assets.mixkit.co/sfx/preview/mixkit-small-crowd-cheer-and-applause-518.mp3',
          lose: 'https://assets.mixkit.co/sfx/preview/mixkit-game-over-dark-2068.mp3'
        };
        helpers.SOUND_EFFECTS = SOUND_EFFECTS;

        var PROVERBS = Array.isArray(window.PROVERBS) && window.PROVERBS.length
          ? window.PROVERBS.slice()
          : [
              { t: 'ÿ±ÿ¨ÿπ ÿ®ÿÆŸÅŸä ÿ≠ŸÜŸäŸÜ', hint: 'ŸäŸèŸÇÿßŸÑ ŸÑŸÖŸÜ ÿπÿßÿØ ÿ®ŸÑÿß ŸÜÿ™Ÿäÿ¨ÿ©.', explanation: 'ÿ™ÿ≠ŸÉŸä ÿßŸÑŸÇÿµÿ© ÿπŸÜ ÿ±ÿ¨ŸÑ ŸÅÿ¥ŸÑ ŸÅŸä ŸÖŸÅÿßŸàÿ∂ÿ© ÿ•ÿ≥ŸÉÿßŸÅŸä ŸÅÿπÿßÿØ ÿÆÿßŸÑŸä ÿßŸÑŸàŸÅÿßÿ∂ ŸàŸÇÿØ ŸÅŸÇÿØ ŸÜÿπŸÑŸäŸáÿå ŸÅÿµÿßÿ± ŸÖÿ´ŸÑÿßŸã ÿπŸÜ ÿßŸÑÿÆŸäÿ®ÿ© ÿ®ÿπÿØ ŸÖÿ¥ŸÇÿ©.', lesson: 'ÿßŸÑÿ™ÿÆÿ∑Ÿäÿ∑ ŸàÿßŸÑŸÖÿ±ŸàŸÜÿ© ŸÅŸä ÿßŸÑÿ™ŸÅÿßŸàÿ∂ Ÿäÿ≠ŸÖŸäÿßŸÜ ŸÖŸÜ ÿ∂Ÿäÿßÿπ ÿßŸÑÿ¨ŸáÿØ.', source: 'ŸÖÿ´ŸÑ ÿπÿ±ÿ®Ÿä ŸÇÿØŸäŸÖ' },
              { t: 'ÿÆŸäÿ± ÿßŸÑŸÉŸÑÿßŸÖ ŸÖÿß ŸÇŸÑ ŸàÿØŸÑ', hint: 'Ÿäÿ™ÿπŸÑŸÇ ÿ®ŸÅÿµÿßÿ≠ÿ© ÿßŸÑÿ™ÿπÿ®Ÿäÿ±.', explanation: 'Ÿäÿ¥ÿ¨ÿπ ÿßŸÑŸÖÿ´ŸÑ ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ± ŸÉŸÑŸÖÿßÿ™ ŸÇŸÑŸäŸÑÿ© ŸÑŸÉŸÜŸáÿß ŸÖÿπÿ®ÿ±ÿ© ŸàŸàÿßÿ∂ÿ≠ÿ© ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ÿßŸÑÿ•ÿ∑ÿßŸÑÿ© ÿßŸÑŸÖŸÖŸÑÿ©.', lesson: 'ÿßŸÑÿ•Ÿäÿ¨ÿßÿ≤ ÿßŸÑŸàÿßÿ∂ÿ≠ Ÿäÿ®ŸÜŸä ÿ™ŸàÿßÿµŸÑÿßŸã ÿ£ŸÇŸàŸâ.', source: 'ÿ≠ŸÉŸÖÿ© ÿπÿ±ÿ®Ÿäÿ© ŸÇÿØŸäŸÖÿ©' },
              { t: 'ÿßŸÑÿµÿ®ÿ± ŸÖŸÅÿ™ÿßÿ≠ ÿßŸÑŸÅÿ±ÿ¨', hint: 'ŸäÿØÿπŸà ŸÑŸÑÿ™ÿ±Ÿäÿ´.', explanation: 'ŸäÿπŸÑŸÖŸÜÿß ÿßŸÑŸÖÿ´ŸÑ ÿ£ŸÜ ÿ∂ŸäŸÇ ÿßŸÑŸÑÿ≠ÿ∏ÿ© ŸÑÿß ŸäÿØŸàŸÖ Ÿàÿ£ŸÜ ÿßŸÑÿµÿ®ÿ± ŸäŸÅÿ™ÿ≠ ÿ£ÿ®Ÿàÿßÿ® ÿßŸÑÿ≠ŸÑŸàŸÑ.', lesson: 'ÿßŸÑŸáÿØŸàÿ° ŸàÿßŸÑÿ´ÿ®ÿßÿ™ ŸäŸÖŸÜÿ≠ÿßŸÜ ÿ±ÿ§Ÿäÿ© ÿ£Ÿàÿ∂ÿ≠.', source: 'ÿ≠ŸÉŸÖÿ© ÿ±Ÿàÿ≠ÿßŸÜŸäÿ©' },
              { t: 'ŸÖŸÜ ÿ∑ŸÑÿ® ÿßŸÑÿπŸÑÿß ÿ≥Ÿáÿ± ÿßŸÑŸÑŸäÿßŸÑŸä', hint: 'Ÿäÿ™ÿ≠ÿØÿ´ ÿπŸÜ ÿßŸÑÿßÿ¨ÿ™ŸáÿßÿØ.', explanation: 'ÿßŸÑŸÖÿ´ŸÑ ŸäÿØÿπŸà ÿ•ŸÑŸâ ÿßŸÑŸÖÿ´ÿßÿ®ÿ±ÿ© Ÿàÿ®ÿ∞ŸÑ ÿßŸÑÿ¨ŸáÿØ ŸÑÿ™ÿ≠ŸÇŸäŸÇ ÿßŸÑÿ£ŸáÿØÿßŸÅ ÿßŸÑÿ≥ÿßŸÖŸäÿ©.', lesson: 'ÿßŸÑÿ∑ŸÖŸàÿ≠ Ÿäÿ™ÿ≠ŸÇŸÇ ÿ®ÿßŸÑÿπŸÖŸÑ ŸàÿßŸÑÿµÿ®ÿ±.', source: 'ÿ≠ŸÉŸÖÿ© ÿ™ÿπŸÑŸäŸÖŸäÿ©' },
              { t: 'ÿßŸÑŸÇŸÜÿßÿπÿ© ŸÉŸÜÿ≤ ŸÑÿß ŸäŸÅŸÜŸâ', hint: 'ŸäÿØÿπŸà ŸÑŸÑÿ±ÿ∂ÿß.', explanation: 'Ÿäÿ®ŸäŸÜ ÿßŸÑŸÖÿ´ŸÑ ÿ£ŸÜ ÿßŸÑŸÇŸÜÿßÿπÿ© ÿ´ÿ±Ÿàÿ© ÿØÿßÿÆŸÑŸäÿ© ÿ™ŸÖŸÜÿ≠ ÿµÿßÿ≠ÿ®Ÿáÿß ÿ±ÿßÿ≠ÿ© ŸÖÿ≥ÿ™ÿØÿßŸÖÿ©.', lesson: 'ÿ™ŸÇÿØŸäÿ± ÿßŸÑŸÜÿπŸÖ ÿßŸÑÿ≠ÿßŸÑŸäÿ© Ÿäÿ¨ŸÑÿ® ÿßŸÑÿ≥ŸÉŸäŸÜÿ©.', source: 'ŸÖÿ´ŸÑ ÿπÿ±ÿ®Ÿä ŸÖÿ™ÿØÿßŸàŸÑ' },
              { t: 'ŸÖŸÜ ÿ¥ÿ® ÿπŸÑŸâ ÿ¥Ÿäÿ° ÿ¥ÿßÿ® ÿπŸÑŸäŸá', hint: 'Ÿäÿ™ÿπŸÑŸÇ ÿ®ÿßŸÑÿπÿßÿØÿßÿ™.', explanation: 'Ÿäÿ§ŸÉÿØ ÿßŸÑŸÖÿ´ŸÑ ÿ£ŸÜ ŸÖÿß ŸäŸÜÿ¥ÿ£ ÿπŸÑŸäŸá ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜ ŸÅŸä ÿµÿ∫ÿ±Ÿá Ÿäÿ≥ÿ™ŸÖÿ± ÿ∫ÿßŸÑÿ®Ÿãÿß ŸÖÿπŸá.', lesson: 'ÿ™ÿ¥ŸÉŸäŸÑ ÿßŸÑÿπÿßÿØÿßÿ™ ÿßŸÑÿ•Ÿäÿ¨ÿßÿ®Ÿäÿ© ŸÖÿ®ŸÉÿ±Ÿãÿß ÿßÿ≥ÿ™ÿ´ŸÖÿßÿ± ÿ∑ŸàŸäŸÑ ÿßŸÑÿ£ŸÖÿØ.', source: 'ŸÖÿ´ŸÑ ÿπÿ±ÿ®Ÿä ÿØÿßÿ±ÿ¨' },
              { t: 'ÿ±ÿ® ÿ∂ÿßÿ±ÿ© ŸÜÿßŸÅÿπÿ©', hint: 'Ÿäÿ±Ÿâ ÿßŸÑÿÆŸäÿ± ŸÅŸä ÿßŸÑÿßÿ®ÿ™ŸÑÿßÿ°.', explanation: 'ŸäŸàÿ∂ÿ≠ ÿßŸÑŸÖÿ´ŸÑ ÿ£ŸÜ ÿßŸÑŸÖÿµÿßÿ¶ÿ® ŸÇÿØ ÿ™ÿ≠ŸÖŸÑ ŸÅŸä ÿ∑Ÿäÿßÿ™Ÿáÿß ŸÅÿ±ÿµŸãÿß ŸÑÿß ŸÜÿ±ÿßŸáÿß ÿ£ŸàŸÑÿßŸã.', lesson: 'ÿ™ÿ∫ŸäŸäÿ± ÿ≤ÿßŸàŸäÿ© ÿßŸÑŸÜÿ∏ÿ± Ÿäÿ≠ŸàŸÑ ÿßŸÑŸÖÿ≠ŸÜ ÿ•ŸÑŸâ ŸÖŸÜÿ≠.', source: 'ÿ≠ŸÉŸÖÿ© ÿ•ÿ≥ŸÑÿßŸÖŸäÿ© ÿ¥ÿßÿ¶ÿπÿ©' },
              { t: 'ÿßŸÑÿπŸÑŸÖ ŸÜŸàÿ±', hint: 'Ÿäÿ¥ŸäÿØ ÿ®ÿßŸÑŸÖÿπÿ±ŸÅÿ©.', explanation: 'Ÿäÿ¥ÿ®Ÿá ÿßŸÑŸÖÿ´ŸÑ ÿßŸÑÿπŸÑŸÖ ÿ®ÿßŸÑŸÜŸàÿ± ÿßŸÑÿ∞Ÿä Ÿäÿ®ÿØÿØ ÿßŸÑÿ∏ŸÑÿßŸÖ ŸàŸäŸáÿØŸä ÿßŸÑÿπŸÇŸàŸÑ.', lesson: 'ÿßŸÑÿ™ÿπŸÑŸÖ ÿßŸÑŸÖÿ≥ÿ™ŸÖÿ± ŸäŸÅÿ™ÿ≠ ÿßŸÑÿ¢ŸÅÿßŸÇ.', source: 'ŸÇŸàŸÑ ÿ™ÿ±ÿ®ŸàŸä ŸÖÿ£ÿ´Ÿàÿ±' }
            ];
        helpers.PROVERBS = PROVERBS;

        function randomBetween(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        helpers.randomBetween = randomBetween;

        function shuffle(arr) {
          var copy = arr.slice();
          for (var i = copy.length - 1; i > 0; i--) {
            var j = Math.floor(Math.random() * (i + 1));
            var tmp = copy[i];
            copy[i] = copy[j];
            copy[j] = tmp;
          }
          return copy;
        }
        helpers.shuffle = shuffle;

        function normLetter(ch) {
          return String(ch || '').replace(/[ÿ£ÿ•ÿ¢]/g, 'ÿß');
        }
        helpers.normLetter = normLetter;

        function checkSolved(game) {
          if (!game || !game.proverb) return false;
          return game.proverb.t.split('').every(function (ch) {
            return ch === ' ' || game.guessed[normLetter(ch)];
          });
        }
        helpers.checkSolved = checkSolved;

        function defaultThemePrefs() {
          return { fontScale: 100, background: 'nebula' };
        }
        helpers.defaultThemePrefs = defaultThemePrefs;

        var THEME_BACKGROUND_PRESETS = [
          {
            id: 'nebula',
            label: { ar: 'ÿ¥ŸÅŸÇ ÿ®ŸÜŸÅÿ≥ÿ¨Ÿä', en: 'Violet nebula' },
            light: {
              gradient: 'linear-gradient(160deg, #f8f9ff 0%, #e8ecff 100%)',
              overlay1: 'radial-gradient(circle at 20% 25%, rgba(79, 70, 229, 0.18), transparent 55%)',
              overlay2: 'radial-gradient(circle at 80% 70%, rgba(14, 165, 233, 0.18), transparent 50%)'
            },
            dark: {
              gradient: 'linear-gradient(160deg, #0d1224 0%, #111c3d 100%)',
              overlay1: 'radial-gradient(circle at 80% 30%, rgba(168, 85, 247, 0.22), transparent 55%)',
              overlay2: 'radial-gradient(circle at 15% 80%, rgba(56, 189, 248, 0.18), transparent 55%)'
            }
          },
          {
            id: 'sunset',
            label: { ar: 'ÿ∫ÿ±Ÿàÿ® ÿ∞Ÿáÿ®Ÿä', en: 'Golden sunset' },
            light: {
              gradient: 'linear-gradient(145deg, #fff7ed 0%, #fde68a 100%)',
              overlay1: 'radial-gradient(circle at 25% 20%, rgba(251, 191, 36, 0.24), transparent 55%)',
              overlay2: 'radial-gradient(circle at 75% 80%, rgba(249, 115, 22, 0.18), transparent 55%)'
            },
            dark: {
              gradient: 'linear-gradient(145deg, #1f172a 0%, #312e81 100%)',
              overlay1: 'radial-gradient(circle at 25% 20%, rgba(147, 51, 234, 0.24), transparent 55%)',
              overlay2: 'radial-gradient(circle at 75% 80%, rgba(234, 179, 8, 0.18), transparent 55%)'
            }
          }
        ];
        helpers.BACKGROUNDS = THEME_BACKGROUND_PRESETS;

        var ALPHABET = ['ÿß','ÿ®','ÿ™','ÿ´','ÿ¨','ÿ≠','ÿÆ','ÿØ','ÿ∞','ÿ±','ÿ≤','ÿ≥','ÿ¥','ÿµ','ÿ∂','ÿ∑','ÿ∏','ÿπ','ÿ∫','ŸÅ','ŸÇ','ŸÉ','ŸÑ','ŸÖ','ŸÜ','Ÿà','Ÿá','ÿ©','ÿ°','Ÿä','Ÿâ'];
        helpers.ALPHABET = ALPHABET;

        var LOGIC_GENERATORS = [
          function arithmetic(h) {
            var step = h.randomBetween(2, 8);
            var start = h.randomBetween(2, 15);
            var length = 4;
            var sequence = [];
            for (var i = 0; i < length; i++) {
              sequence.push(start + i * step);
            }
            var answer = start + length * step;
            var pool = h.shuffle([answer, answer + step, answer - step, answer + 2 * step, answer - 2 * step]).slice(0, 4);
            return {
              type: 'arithmetic',
              sequence: sequence,
              answer: answer,
              options: pool,
              message: {
                ar: 'ÿ™ÿ≤ÿØÿßÿØ ÿßŸÑŸÇŸäŸÖ ÿ®ŸÖŸÇÿØÿßÿ± ' + step + ' ŸÅŸä ŸÉŸÑ ÿÆÿ∑Ÿàÿ©.',
                en: 'Values increase by ' + step + ' each step.'
              }
            };
          },
          function doubling(h) {
            var start = h.randomBetween(2, 6);
            var length = 4;
            var sequence = [];
            for (var i = 0; i < length; i++) {
              sequence.push(start * Math.pow(2, i));
            }
            var answer = start * Math.pow(2, length);
            var pool = h.shuffle([answer, answer / 2, answer * 2, answer + start, answer - start]).slice(0, 4);
            return {
              type: 'double',
              sequence: sequence,
              answer: answer,
              options: pool,
              message: {
                ar: 'ŸÉŸÑ ŸÇŸäŸÖÿ© ÿ∂ÿπŸÅ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©.',
                en: 'Each value doubles the previous one.'
              }
            };
          },
          function squares(h) {
            var start = h.randomBetween(2, 5);
            var length = 4;
            var sequence = [];
            for (var i = 0; i < length; i++) {
              var base = start + i;
              sequence.push(base * base);
            }
            var nextBase = start + length;
            var answer = nextBase * nextBase;
            var pool = h.shuffle([
              answer,
              (nextBase + 1) * (nextBase + 1),
              (nextBase - 1) * (nextBase - 1),
              answer + nextBase,
              answer - nextBase
            ]).slice(0, 4);
            return {
              type: 'square',
              sequence: sequence,
              answer: answer,
              options: pool,
              message: {
                ar: 'ÿßŸÑÿ£ÿπÿØÿßÿØ ŸÖÿ±ÿ®ÿπÿßÿ™ ŸÖÿ™ÿ™ÿßŸÑŸäÿ© ÿ™ÿ®ÿØÿ£ ŸÖŸÜ ' + start + '¬≤.',
                en: 'Squares that start at ' + start + '¬≤.'
              }
            };
          }
        ];
        helpers.LOGIC_GENERATORS = LOGIC_GENERATORS;

        var activeTimer = null;
        function clearTimer() {
          if (activeTimer) {
            window.clearInterval(activeTimer);
            activeTimer = null;
          }
        }
        helpers.clearTimer = clearTimer;

        function tickTimer(ctx) {
          var state = ctx.getState();
          var game = state.data && state.data.game;
          if (!game || !game.timerOn || game.status !== 'running') {
            clearTimer();
            return;
          }
          ctx.setState(function (prev) {
            var next = JSON.parse(JSON.stringify(prev || {}));
            var g = next.data.game;
            if (!g.timerOn || g.status !== 'running') return prev;
            var nextTime = typeof g.timeLeft === 'number' ? g.timeLeft - 1 : g.timerSec - 1;
            g.timeLeft = Math.max(0, nextTime);
            if (g.timeLeft <= 0) {
              g.status = 'lost';
              g.revealSolution = true;
              g.feedback = { type: 'lose', sound: SOUND_EFFECTS.lose };
              clearTimer();
            }
            return next;
          });
        }
        helpers.tickTimer = tickTimer;

        helpers.startTimer = function (ctx) {
          clearTimer();
          activeTimer = window.setInterval(function () {
            tickTimer(ctx);
          }, 1000);
        };

        function applyThemePrefs(state) {
          var prefs = (state.data && state.data.themePrefs) || defaultThemePrefs();
          var scale = prefs.fontScale || 100;
          document.documentElement.style.setProperty('--user-font-scale', String(scale));
          var preset = THEME_BACKGROUND_PRESETS.find(function (p) { return p.id === prefs.background; }) || THEME_BACKGROUND_PRESETS[0];
          if (preset) {
            var theme = state.env.theme === 'dark' ? preset.dark : preset.light;
            document.documentElement.style.setProperty('--page-gradient', theme.gradient);
            document.documentElement.style.setProperty('--page-overlay-1', theme.overlay1);
            document.documentElement.style.setProperty('--page-overlay-2', theme.overlay2);
          }
        }
        helpers.applyThemePrefs = applyThemePrefs;

        function applyEnvironment(state) {
          document.documentElement.lang = state.env.lang || 'ar';
          document.documentElement.dir = state.env.dir || (state.env.lang === 'ar' ? 'rtl' : 'ltr');
          document.documentElement.classList.toggle('dark', state.env.theme === 'dark');
          applyThemePrefs(state);
        }
        helpers.applyEnvironment = applyEnvironment;

        function persistPrefs(state) {
          try {
            var payload = {
              theme: state.env.theme,
              lang: state.env.lang,
              dir: state.env.dir,
              themePrefs: state.data.themePrefs
            };
            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
          } catch (err) {
            console.warn('Failed to persist preferences', err);
          }
        }
        helpers.persistPrefs = persistPrefs;

        function loadPrefs() {
          try {
            var raw = window.localStorage.getItem(STORAGE_KEY);
            if (!raw) return null;
            return JSON.parse(raw);
          } catch (err) {
            console.warn('Failed to read preferences', err);
            return null;
          }
        }
        helpers.loadPrefs = loadPrefs;

        function escapeHtml(text) {
          return String(text).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        function inlineMarkdown(text) {
          var out = escapeHtml(text);
          out = out.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
          out = out.replace(/\*(.+?)\*/g, '<em>$1</em>');
          out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
          return out;
        }

        function simpleMarkdownToHtml(md) {
          var lines = String(md || '').replace(/\r\n?/g, '\n').split('\n');
          var html = [];
          var inList = false;
          var inCode = false;
          var codeBuffer = [];
          lines.forEach(function (line) {
            if (line.trim().startsWith('```')) {
              if (!inCode) {
                inCode = true;
                codeBuffer = [];
              } else {
                inCode = false;
                html.push('<pre><code>' + escapeHtml(codeBuffer.join('\n')) + '</code></pre>');
              }
              return;
            }
            if (inCode) {
              codeBuffer.push(line);
              return;
            }
            if (!line.trim()) {
              if (inList) {
                html.push('</ul>');
                inList = false;
              }
              return;
            }
            if (/^\s*[-*+] /.test(line)) {
              if (!inList) {
                html.push('<ul>');
                inList = true;
              }
              html.push('<li>' + inlineMarkdown(line.replace(/^\s*[-*+]\s*/, '')) + '</li>');
              return;
            }
            if (inList) {
              html.push('</ul>');
              inList = false;
            }
            if (/^###\s+/.test(line)) {
              html.push('<h3>' + inlineMarkdown(line.replace(/^###\s+/, '')) + '</h3>');
              return;
            }
            if (/^##\s+/.test(line)) {
              html.push('<h2>' + inlineMarkdown(line.replace(/^##\s+/, '')) + '</h2>');
              return;
            }
            if (/^#\s+/.test(line)) {
              html.push('<h2>' + inlineMarkdown(line.replace(/^#\s+/, '')) + '</h2>');
              return;
            }
            if (/^>\s?/.test(line)) {
              html.push('<blockquote>' + inlineMarkdown(line.replace(/^>\s?/, '')) + '</blockquote>');
              return;
            }
            html.push('<p>' + inlineMarkdown(line) + '</p>');
          });
          if (inList) html.push('</ul>');
          if (inCode) html.push('<pre><code>' + escapeHtml(codeBuffer.join('\n')) + '</code></pre>');
          return html.join('\n');
        }
        helpers.simpleMarkdownToHtml = simpleMarkdownToHtml;

        function prepareDocs() {
          var store = M.readme || {};
          var baseAr = (store.base && store.base.ar) || '';
          var baseEn = (store.base && store.base.en) || baseAr;
          var tecAr = (store.tec && store.tec.ar) || '';
          var tecEn = (store.tec && store.tec.en) || tecAr;
          return {
            base: { ar: simpleMarkdownToHtml(baseAr), en: simpleMarkdownToHtml(baseEn) },
            tec: { ar: simpleMarkdownToHtml(tecAr), en: simpleMarkdownToHtml(tecEn) }
          };
        }
        helpers.prepareDocs = prepareDocs;

        function buildInitialState() {
          var prefs = loadPrefs() || {};
          var lang = prefs.lang || 'ar';
          var theme = prefs.theme || 'dark';
          var strings = helpers.STRINGS || STRINGS;
          return {
            env: { lang: lang, dir: lang === 'ar' ? 'rtl' : 'ltr', theme: theme },
            i18n: { strings: JSON.parse(JSON.stringify(strings || {})) },
            data: {
              activeTab: 'readmeBase',
              docs: prepareDocs(),
              counter: 0,
              logicGame: { sequence: [], options: [], answer: null, feedback: null, explain: null, selected: null },
              settingsOpen: false,
              themePrefs: prefs.themePrefs || defaultThemePrefs(),
              backgrounds: THEME_BACKGROUND_PRESETS,
              alphabet: ALPHABET,
              game: {
                musicOn: true,
                timerOn: true,
                timerSec: 45,
                timeLeft: 45,
                triesMax: 5,
                triesLeft: 5,
                audioList: [
                  { name: 'Ghost Stories', url: 'https://www.fesliyanstudios.com/musicfiles/2020-10-26_-_Ghost_Stories_-_www.FesliyanStudios.com_Steve_Oxen/2020-10-26_-_Ghost_Stories_-_www.FesliyanStudios.com_Steve_Oxen.mp3' },
                  { name: 'The Unsolved Mystery', url: 'https://www.fesliyanstudios.com/musicfiles/2018-07-22_-_The_Unsolved_Murder_-_David_Fesliyan.mp3' },
                  { name: 'Dark Shadows', url: 'https://www.fesliyanstudios.com/musicfiles/2020-06-25_-_Dark_Shadows_-_www.FesliyanStudios.com_David_Fesliyan.mp3' }
                ],
                audioIdx: 0,
                proverb: null,
                guessed: {},
                status: 'idle',
                revealSolution: false,
                feedback: null
              }
            }
          };
        }
        helpers.buildInitialState = buildInitialState;

        var state = buildInitialState();
        applyEnvironment(state);
        persistPrefs(state);

        var start = M.HTMLxAgent.make({
          head: { title: 'ŸÖÿ¥ŸÉÿßÿ© ‚Äî ÿ™ÿ¨ÿ±ÿ®ÿ© HTMLx' },
          env: state.env,
          i18n: state.i18n,
          data: state.data,
          orders: {},
          templates: [{ id: 'mishkah-index' }]
        });

        if (start && typeof start.catch === 'function') {
          start.catch(function (error) {
            console.error('Failed to start Mishkah HTMLx index:', error);
          });
        }
      })(window);
    </script>

  </body>
</html>
