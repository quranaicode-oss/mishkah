
### **Mishkah.js — التوجيه الهندسي لمساعد الذكاء الاصطناعي**

**الموضوع:** دليل مرجعي صارم لتوليد أكواد متوافقة مع بنية "مشكاة" وفلسفتها.

**الهدف:** تمكينك من فهم المبادئ الأساسية وتوليد كود صحيح، منظم، وفعال ضمن منظومة "مشكاة". أي انحراف عن هذه القواعد يعتبر خطأً معماريًا.

#### **المبدأ الجوهري: رحلة الخلق ذات المرحلتين**

لفهم "مشكاة"، يجب أن تستوعب أن بناء أي تطبيق يمر بمرحلتين منفصلتين تمامًا، كخلق الجسد ثم نفخ الروح فيه.

1.  **المرحلة الأولى: التصوير والتسوية (خلق الجسد)**

      * **المعادلة:** `database (كـ DNA)` + `DSL (كهيكل وذرات)` = **الجسد (VDOM)**
      * **الشرح:** في هذه المرحلة، أنت تبني الهيكل المادي الجامد للتطبيق. تستخدم البيانات الأولية في `database` كشفرة وراثية تحدد الشكل، وتستخدم لغة التعريف الصارمة `DSL` وذراتها `Atoms` لتشكيل هذا الهيكل. النتيجة هي مخطط دقيق (Virtual DOM) لواجهة المستخدم، لكنه لا يتفاعل بعد.

2.  **المرحلة الثانية: التمكين والتكليف (نفخ الروح والحياة)**

      * **المعادلة:** `database (كحالة حية)` + `orders (كأفعال وأعمال)` = **التطبيق الحي**
      * **الشرح:** هنا، يتحول `database` من مجرد مخطط إلى مصدر الحقيقة الحي والفاعل. ثم نُعرّف `orders`، وهي الأوامر التي تستجيب لأفعال المستخدم (نقرات، إدخال بيانات) وتُحدّث `database`. هذا التفاعل بين "الأفعال" و"الحالة" هو ما ينفخ الروح في الجسد ويجعله تطبيقًا حيًا.

-----

### **1. لغة التعريف (DSL) وتصنيف الذرات (Atoms): قانون البناء الصارم**

هذه هي النقطة الأكثر أهمية وحساسية. أي خطأ هنا يفسد الهيكل بأكمله. **الهدف من الـ DSL هو منع الفوضى، وليس إدارتها.**

**القاعدة الذهبية للذرات:** كل "ذرة" (Atom) تنتمي إلى فئة وظيفية واحدة فقط. الخلط بين الفئات ممنوع منعًا باتًا. مهمتك هي استخدام الذرة الصحيحة من الفئة الصحيحة دائمًا.

#### **التصنيف الكامل للذرات `(D)`:**

  * `D.Containers`: للهياكل الحاوية فقط.
      * **الأمثلة:** `Div`, `Section`, `Article`, `Header`, `Footer`, `Main`, `Nav`, `Aside`.
  * `D.Text`: للنصوص والعناوين والروابط.
      * **الأمثلة:** `P`, `Span`, `H1`-`H6`, `Strong`, `Em`, `Code`, `Blockquote`, `A`.
  * `D.Lists`: للقوائم حصرًا.
      * **الأمثلة:** `Ul`, `Ol`, `Li`, `Dl`, `Dt`, `Dd`.
  * `D.Forms`: لعناصر النماذج التي **لا** تدخل بيانات مباشرة، بل تؤدي أفعالًا.
      * **الأمثلة:** `Form`, `Label`, `Button`, `Fieldset`, `Legend`.
  * `D.Inputs`: لعناصر النماzذج التي **تستقبل** بيانات من المستخدم.
      * **الأمثلة:** `Input`, `Textarea`, `Select`, `Option`.
  * `D.Media`: لعناصر الوسائط.
      * **الأمثلة:** `Img`, `Video`, `Audio`, `Picture`.
  * `D.Tables`: للجداول.
      * **الأمثلة:** `Table`, `Thead`, `Tbody`, `Tr`, `Th`, `Td`.
  * `D.SVG`: لرسوميات SVG.
      * **الأمثلة:** `Svg`, `Path`, `Circle`, `Rect`.

#### **أمثلة على الأخطاء الشائعة (ما يجب تجنبه):**

> **خطأ:** وضع `<input>` داخل فئة `Forms`.
> **الصواب:** `D.Inputs.Input({...})`

> **خطأ:** وضع `<img>` داخل فئة `Containers`.
> **الصواب:** `D.Media.Img({...})`

> **خطأ:** وضع `<button>` داخل فئة `Inputs`.
> **الصواب:** `D.Forms.Button({...})`

**مهمتك كذكاء اصطناعي هي حفظ هذا التصنيف وتطبيقه بصرامة مطلقة.**

-----

### **2. هندسة الأوامر (Orders): منطق العمل المنظم**

الأوامر هي "الجهاز العصبي" للتطبيق. هي المكان الوحيد الذي يُكتب فيه منطق التفاعل. الأمر ليس مجرد دالة، بل هو كائن مُنظَّم له قواعد دقيقة لفهمه من قبل نواة "مشكاة".

#### **بنية الأمر (Order):**

```javascript
const orders = {
  // 'domain.action': { ... }
  'counter:inc': {
    // 1. المُشغِّل (on): ما هو الحدث الذي يستمع له؟
    on: ['click'],

    // 2. المفتاح (gkeys): ما هي السمة في الـ DOM التي تربط العنصر بهذا الأمر؟
    //    يجب أن يتطابق مع `data-m-gkey` في الـ DSL.
    gkeys: ['counter:inc'],

    // 3. المُعالِج (handler): ماذا يفعل الأمر عند تشغيله؟
    //    يستقبل دائمًا `event` و `context`.
    handler: (event, context) => {
      // أ. اقرأ الحالة الحالية (لا تعدلها مباشرة!)
      const currentState = context.getState();

      // ب. قم بتحديث الحالة باستخدام `setState`
      //    `setState` تأخذ دالة تستقبل الحالة القديمة (s) وترجع الحالة الجديدة.
      context.setState(s => ({
        ...s, // انسخ كل شيء كما هو
        data: {
          ...s.data, // انسخ كل البيانات
          counter: s.data.counter + 1 // عدّل القيمة المطلوبة فقط
        }
      }));
      // التحديث يحدث تلقائيًا الآن — لا حاجة لنداء إضافي.
      // عند الحاجة لتحكم متقدم يمكنك استخدام:
      // context.flush({ keepScroll: ['#list'] });
    }
  }
};
```

**ملاحظات هندسية للأوامر:**

  * **الفصل التام:** الـ `handler` لا يعرف شيئًا عن الـ DOM. هو فقط يقرأ الحالة ويطلب تحديثها.
  * **الثبات (Immutability):** لا تقم أبدًا بتعديل `currentState` مباشرة. دائمًا قم بإنشاء كائن جديد باستخدام `...` (Spread Syntax). هذا أساس التزامن التلقائي الفعال.
  * **الاستجابة الفطرية:** `setState()` يشعل إعادة البناء آليًا. استخدم `context.flush()` عندما تحتاج تحديثًا فوريًا أو خيارات متقدمة مثل `keepScroll` و`except`، ولفّ عدة تحديثات داخل `context.batch()` أو `context.freeze()/context.unfreeze()` لتحصل على دفعة واحدة. أمر `context.rebuild()` باقٍ كتوافق تاريخي لكنه يستدعي `flush()` تحت الغطاء.

-----

### **3. مبدأ موقع المكونات (Component Locality)**

للحفاظ على النظام وإعادة الاستخدام، اتبع هذه القواعد:

1.  **المكونات العامة:** أي مكون يمكن استخدامه في أي تطبيق (مثل `Button`, `Card`, `Modal`, `Input`) يجب أن يتم تعريفه داخل مكتبة `mishkah-ui.js`. هذه هي "الشجرة المباركة".
2.  **المكونات المتخصصة:** أي مكون خاص بتطبيق معين فقط (مثل `OrderLinesList.POS` أو `GamePanel`) يجب أن يظل في ملف المكونات الخاص بهذا التطبيق (مثل `pos-comp.js` أو داخل `<script>` في `index.html`).

**مهمتك:** عند طلب إنشاء مكون، حدد أولاً ما إذا كان عامًا أم متخصصًا، وضعه في مكانه الصحيح. الأصل دائمًا في التعميم.

-----

### **4. بيئة الإعداد والإنزال (Auto & Mount)**

هذه هي المرحلة الأخيرة التي تجمع كل شيء معًا.

1.  **`U.twcss.auto(database, app)`:**

      * **ماذا تفعل:** هذه الدالة المساعدة تقوم بتهيئة البيئة الكاملة.
      * **أولاً:** تقرأ `db.env` (الخاص بالثيم واللغة) وتطبقه على الصفحة (تضيف كلاس `.dark` وتضبط `dir="rtl"`).
      * **ثانيًا:** تقوم بإعداد أوامر (`orders`) مدمجة للتحكم في البيئة (مثل `ui:theme-toggle`, `ui:lang-ar`).
      * **ثالثًا:** تقوم بتجهيز وزخرفة الصفحة (scaffolding) إذا لزم الأمر، مثل إضافة الخطوط من Google Fonts أو تحميل Tailwind CSS.

2.  **`app.setOrders({...})`:**

      * **ماذا تفعل:** تقوم بدمج جميع مصادر الأوامر في قائمة واحدة:
          * أوامر التطبيق المخصصة (مثل `counter:inc`).
          * أوامر واجهة المستخدم العامة من `UI.orders` (مثل `ui:modal:close`).
          * أوامر البيئة من `twx.orders` (الناتجة عن دالة `auto`).

3.  **`app.mount('#app')`:**

      * **ماذا تفعل:** هذا هو أمر "البعث" النهائي.
      * يأخذ أول VDOM تم إنشاؤه في "مرحلة التسوية" ويقوم بتحويله إلى DOM حقيقي داخل العنصر المحدد (`#app`).
      * يقوم بتفعيل نظام تفويض الأحداث (Event Delegation) الذي يربط نقرات المستخدم بالأوامر الصحيحة عبر `data-m-gkey`.

#### **خلاصة سير العمل الكامل للتوليد:**

عندما يُطلب منك بناء تطبيق "مشكاة":

1.  **ابدأ بالـ DNA:** عرّف بنية `database` الأولية، شاملة `env`, `i18n`, و `data`.
2.  **ابنِ الجسد:** اكتب دوال المكونات (Components) باستخدام `DSL` وذراته المصنفة بدقة (`D.Containers.Div`, `D.Forms.Button`, etc.).
3.  **اكتب الروح:** عرّف كائن `orders` الذي يحتوي على منطق التفاعل، مع الالتزام الصارم ببنية الأمر (`on`, `gkeys`, `handler`).
4.  **اجمع الخلق:** في نهاية السكريبت، استخدم التسلسل المقدس:
      * `Mishkah.app.createApp(database, orders)`
      * `U.twcss.auto(...)`
      * `Mishkah.app.setBody(...)`
      * `app.setOrders({...})`
      * `app.mount(...)`

> **تنبيه جوهري:** لا تخلط بين `Mishkah.Head` ووحدة التطبيق `Mishkah.app`. تعيين هيكل الواجهة يكون دائمًا عبر `Mishkah.app.setBody(...)` بينما `Mishkah.Head` تُستعمل لتعديل بيانات `<head>` فقط (مثل العنوان والوصف). أي استدعاء لـ `M.Head.setBody` خطأ بنيوي.

باتباع هذه التعليمات الهندسية، ستتمكن من توليد أكواد "مشكاة" صحيحة ومنظمة، تعكس فلسفة النور والنظام.

-----

### **5. قاعدة الأدوات (Utils) — التزام صارم**

- **استخدم دائمًا الأدوات الموجودة في `Mishkah.utils` لكل وظيفة متاحة بدل كتابة كود خام.** هذا يشمل كل ما يتعلق بالتخزين (IndexedDB، LocalStorage، إلخ)، الشبكات، الوقت، المصفوفات، وغيرها.
- **إذا لم تجد أداة جاهزة، أنشئها داخل `utils` أولًا ثم استعملها.** لا يُسمح بكتابة حلول مخصصة متكررة في الملفات الأخرى.
- **أعد مراجعة أي كود تلمسه وتحقق إن كان يمكن استبدال أجزاء منه بأدوات `utils`.** أي تجاهل لهذه القاعدة يعتبر خطأ جسيمًا.
- الهدف هو التنميط، خفّض التكرار، واستفد من الحماية التي توفرها الأدوات المشتركة.


### **6. كتابة برامج HTMLx ناجحة — تعليمات خاصة بالذكاء الاصطناعي**

1. **التزم بالسياج التلقائي للقوالب:** اعتبر كل `<template>` نطاقًا مستقلًا. لا تُسقط `data-m-scope` أو مفتاح `tpl:<hash>` إلا إذا طُلب صراحةً.
2. **ولّد مفاتيح `data-m-gkey` معبّرة وفريدة:** اشتق الاسم من وظيفة العنصر (`lang:switch:ar`) وأضف معرف البيانات (`item.id` أو الفهرس) عندما تتعامل مع تكرار.
3. **قسّم الأوامر حسب المكوّن:** عند توليد أوامر HTMLx، اجعل كل مكوّن يملك أمرًا أو أكثر يحمل نفس `gkey` الذي أنشأته له. لا تدمج أوامر متعددة تحت مفتاح واحد عام.
4. **استخدم سياق HTMLx الممرَّر:** اعتمد على `context.scopeNode`, `context.scopeQuery*`, و`context.stop()` بدلًا من `document.querySelector` أو التلاعب العام بالـ DOM.
5. **اربط التوليد بالوثيقة المرجعية:** راجع ملف `docs/htmlx-guidelines.md` قبل كتابة أي كود HTMLx، واتبع سير العمل المذكور فيه (تصميم البيانات → بناء القوالب → توليد الأوامر → المراجعة → الاختبار).
6. **حافظ على التوافق مع الـ DSL:** أي كود HTMLx تُنتجه يجب أن يترجم إلى DSL مطابقة لمعايير الذرات وقواعد الحارس والرقيب. تجنّب إدخال منطق الأعمال داخل القالب، وأرسله إلى الأوامر فقط.
