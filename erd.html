<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Ù…Ø®Ø·Ø· Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙƒØ§Ø©</title>
  <style>
    :root {
      color-scheme: light dark;
      --background: #f8fafc;
      --surface-0: #f8fafc;
      --surface-1: #ffffff;
      --surface-2: #eef2ff;
      --card: #ffffff;
      --card-foreground: #0f172a;
      --foreground: #0f172a;
      --muted: #475569;
      --muted-foreground: #475569;
      --border: #cfd8ea;
      --input: #dbe3f8;
      --accent: #eaf2ff;
      --accent-foreground: #102341;
      --primary: #2563eb;
      --primary-foreground: #f8fafc;
      --secondary: #d8e1ff;
      --secondary-foreground: #102341;
      --destructive: #ef4444;
      --destructive-foreground: #ffffff;
      --ring: #2563eb;
      --shadow: 0 28px 60px -28px rgba(15, 23, 42, 0.35);
      --radius: 16px;
    }
    :root.dark {
      color-scheme: dark;
      --background: #0b1220;
      --surface-0: #0b1220;
      --surface-1: #101a2c;
      --surface-2: #16243a;
      --card: #111d30;
      --card-foreground: #e2e8f0;
      --foreground: #f8fafc;
      --muted: #94a3b8;
      --muted-foreground: #94a3b8;
      --border: #1f2a3d;
      --input: #223044;
      --accent: #1e2a3f;
      --accent-foreground: #e2e8f0;
      --primary: #60a5fa;
      --primary-foreground: #0b1220;
      --secondary: #27364e;
      --secondary-foreground: #e2e8f0;
      --destructive: #f87171;
      --destructive-foreground: #0b1220;
      --ring: #60a5fa;
      --shadow: 0 30px 70px -36px rgba(8, 15, 30, 0.75);
      --radius: 16px;
    }
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      height: 100%;
      min-height: 100vh;
      margin: 0;
      background: var(--background, #0f1115);
      color: var(--foreground, #f8fafc);
      font-family: "Tajawal", "Cairo", system-ui, sans-serif;
      transition: background-color 160ms ease, color 160ms ease;
    }
    body { display: flex; min-height: 100vh; }
    #app { flex: 1 1 auto; display: flex; }
    textarea[readonly] { user-select: all; }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/@antv/x6@1.35.3/dist/x6.css"/>
  <script src="https://unpkg.com/@antv/x6@1.35.3/dist/x6.js"></script>
  <script src="./mishkah-utils.js"></script>
  <script src="./mishkah.core.js"></script>
  <script src="./mishkah-ui.js"></script>
  <script src="./mishkah-schema.js"></script>
</head>
<body>
  <div id="app"></div>
  <script>
  (async function(){
    const M = Mishkah;
    const UI = M.UI;
    const U = M.utils;
    const D = M.DSL;
    const Schema = M.schema;
    const { tw } = U.twcss;
    const Text = U.Text || {};

    let erdAppInstance = null;
    let erdDriver = null;
    let activeDriverName = null;
    let pendingDiagramFrame = false;
    let lastDiagramState = null;

    const TABLE_WIDTH = 280;
    const HEADER_HEIGHT = 48;
    const ROW_HEIGHT = 28;

    const DEFAULT_FIELD_TYPES = [
      'string','integer','decimal','float','boolean','timestamp','date','json','uuid','text'
    ];

    const RELATION_ACTION_OPTIONS = ['CASCADE','RESTRICT','SET NULL','NO ACTION'];

    const clone = (U.JSON && U.JSON.clone) ? U.JSON.clone : (obj => JSON.parse(JSON.stringify(obj)));

    class FakeDriver {
      init(container, hooks){
        this.container = container;
        this.hooks = hooks || {};
        container.innerHTML = '<div style="padding:8px;color:#666">FakeDriver mounted (no drawing)</div>';
      }
      render(state){
        const tables = Array.isArray(state?.tables) ? state.tables.length : 0;
        console.log('Fake render', tables, 'tables');
      }
      fitToScreen(){ }
      undo(){ }
      redo(){ }
      async exportPNG(){ return new Blob(); }
      async exportSVG(){ return '<svg/>'; }
      destroy(){ if(this.container) this.container.innerHTML = ''; }
    }

    class X6Driver {
      constructor(){
        this.graph = null;
        this.hooks = null;
        this.initialized = false;
      }

      init(container, hooks){
        this.hooks = hooks || {};
        const Graph = window?.X6?.Graph;
        if(!Graph){
          console.warn('[Mishkah][ERD] AntV X6 Graph not available, falling back to FakeDriver');
          throw new Error('X6 not available');
        }
        this.graph = new Graph({
          container,
          grid: true,
          scroller: { enabled: true, pannable: true },
          mousewheel: { enabled: true, modifiers: ['ctrl','meta'] },
          history: { enabled: true },
          selecting: { enabled: true, multiple: true, rubberband: true },
          keyboard: { enabled: true },
          clipboard: { enabled: true },
          snapline: { enabled: true },
          connecting: {
            allowBlank: false,
            allowLoop: false,
            snap: true,
            router: { name: 'manhattan' },
            connector: { name: 'rounded' },
            validateConnection: ({ sourceMagnet, targetMagnet }) => !!(sourceMagnet && targetMagnet),
          },
        });

        this.graph.on('node:change:position', ({ node }) => {
          const { x, y } = node.getPosition();
          this.hooks?.onNodeMove?.({ id: String(node.id), x, y });
        });

        this.graph.on('selection:changed', ({ selected }) => {
          if(!selected) return;
          const ids = selected
            .filter(cell => cell && typeof cell.isNode === 'function' && cell.isNode())
            .map(cell => String(cell.id));
          this.hooks?.onSelect?.(ids);
        });

        this.graph.on('edge:connected', ({ edge, isNew }) => {
          if(!edge) return;
          const meta = edge.getData ? edge.getData() : null;
          if(meta?.hydrated){
            edge.setData({ ...meta, hydrated: false });
            return;
          }
          if(isNew === false) return;
          const source = edge.getSource();
          const target = edge.getTarget();
          if(!source || !target) return;
          this.hooks?.onEdgeConnect?.({
            source: { id: String(source.cell), port: String(source.port) },
            target: { id: String(target.cell), port: String(target.port) },
          });
        });
      }

      render(state){
        if(!this.graph) return;
        const layout = state?.layout || {};
        const tables = Array.isArray(state?.tables) ? state.tables : [];
        const relations = Array.isArray(state?.relations) ? state.relations : [];
        const nodes = tables.map(tbl => {
          const position = layout[tbl.id] || { x: 80, y: 80 };
          const fields = Array.isArray(tbl.fields) ? tbl.fields : [];
          const lines = fields.map(field => {
            const typeSuffix = field.type ? ` : ${field.type}` : '';
            return `â€¢ ${field.name}${typeSuffix}`;
          });
          const title = tbl.displayName || tbl.label || tbl.name || tbl.id;
          const bodyText = lines.length ? `${title}\n${lines.join('\n')}` : title;
          return {
            id: tbl.id,
            shape: 'rect',
            x: position.x,
            y: position.y,
            width: 260,
            height: Math.max(60, 32 + 24 * fields.length),
            data: { hydrated: true },
            attrs: {
              body: { fill: '#0ea5e9', stroke: '#0284c7', rx: 12, ry: 12 },
              label: {
                text: bodyText,
                fill: '#f8fafc',
                fontSize: 12,
                fontWeight: 600,
                lineHeight: 1.4,
                textAnchor: 'start',
                refX: 12,
                refY: 16,
              },
            },
            ports: {
              groups: {
                in: {
                  position: 'left',
                  attrs: { circle: { r: 4, magnet: true, stroke: '#0f172a', fill: '#f8fafc' } },
                },
                out: {
                  position: 'right',
                  attrs: { circle: { r: 4, magnet: true, stroke: '#0f172a', fill: '#f8fafc' } },
                },
              },
              items: fields.map((field, index) => ({
                id: `${tbl.id}:${field.name}`,
                group: index % 2 === 0 ? 'out' : 'in',
                attrs: {
                  circle: {
                    title: `${field.name}${field.type ? ` (${field.type})` : ''}`,
                  },
                },
              })),
            },
          };
        });

        const edges = relations.map(rel => ({
          id: rel.id || `${rel.from.table}:${rel.from.field}â†’${rel.to.table}:${rel.to.field}`,
          shape: 'edge',
          source: { cell: rel.from.table, port: `${rel.from.table}:${rel.from.field}` },
          target: { cell: rel.to.table, port: `${rel.to.table}:${rel.to.field}` },
          router: { name: 'manhattan' },
          connector: { name: 'rounded' },
          attrs: { line: { stroke: '#0284c7', strokeWidth: 1.6 } },
          labels: rel.cardinality || rel.onDelete || rel.onUpdate ? [
            {
              attrs: {
                label: {
                  text: rel.cardinality || '1..*',
                  fill: '#0f172a',
                  background: {
                    fill: '#f8fafc',
                    stroke: '#94a3b8',
                    padding: 2,
                  },
                },
              },
            },
          ] : [],
          data: { hydrated: true },
        }));

        this.graph.fromJSON({ cells: [...nodes, ...edges] });

        const selection = state?.selection;
        if(selection?.table){
          const node = this.graph.getCellById(selection.table);
          if(node){
            this.graph.resetSelection(node);
          }
        }

        if(typeof state?.zoom === 'number' && Number.isFinite(state.zoom)){
          try { this.graph.zoomTo(state.zoom); }
          catch(error){ console.warn('[Mishkah][ERD] zoomTo failed', error); }
        }

        if(!this.initialized){
          this.initialized = true;
        }
      }

      fitToScreen(padding = 16){
        if(!this.graph) return;
        this.graph.scaleContentToFit({ padding });
      }

      undo(){
        if(!this.graph) return;
        this.graph.history?.undo();
      }

      redo(){
        if(!this.graph) return;
        this.graph.history?.redo();
      }

      async exportSVG(){
        if(!this.graph) return '<svg />';
        return this.graph.toSVG({ preserveDimensions: true });
      }

      async exportPNG(opts = {}){
        if(!this.graph) return new Blob();
        const dataUrl = await this.graph.toPNG({
          backgroundColor: opts.background || '#ffffff',
          padding: 16,
          quality: 1,
        });
        const response = await fetch(dataUrl);
        return await response.blob();
      }

      destroy(){
        if(this.graph){
          this.graph.dispose();
          this.graph = null;
        }
      }
    }

    const DiagramDrivers = {
      fake: FakeDriver,
      x6: X6Driver,
    };

    function sanitizeSqlIdentifier(value){
      if(!value) return '';
      const snake = Schema.utils.toSnakeCase(value || '') || '';
      return snake
        .replace(/[^a-z0-9_]/g, '')
        .replace(/_{2,}/g, '_')
        .replace(/^_+|_+$/g, '')
        .slice(0, 64);
    }

    function identifierFromLabel(label, fallback){
      const sanitized = sanitizeSqlIdentifier(label || '');
      if(sanitized) return sanitized;
      if(Text && typeof Text.identifierFromArabic === 'function'){
        const derived = sanitizeSqlIdentifier(Text.identifierFromArabic(label, { fallback }));
        if(derived) return derived;
      }
      const fallbackBase = sanitizeSqlIdentifier(fallback || 'item');
      return fallbackBase || (fallback || 'item');
    }

    function formatIdentifier(value){
      if(!value) return '';
      return value
        .replace(/_/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/(^|\s)([a-z])/g, (_, space, ch)=> space + ch.toUpperCase());
    }

    function ensureUniqueTableName(registry, base){
      const clean = base || 'table';
      let candidate = clean;
      let index = 1;
      while(registry.get(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function ensureUniqueFieldName(table, base){
      const clean = base || 'field';
      if(!table) return clean;
      let candidate = clean;
      let index = 1;
      while(table.getField(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function computeTableIdentifier(registry, source){
      const fallback = `table_${registry.list().length + 1}`;
      const base = sanitizeSqlIdentifier(source || '') || identifierFromLabel(source, fallback);
      return ensureUniqueTableName(registry, base);
    }

    function computeFieldIdentifier(table, label){
      const fallback = `field_${(table?.fields?.length || 0) + 1}`;
      const base = identifierFromLabel(label, fallback);
      return ensureUniqueFieldName(table, base);
    }

    function currentPalette(){
      if(typeof window === 'undefined') return {};
      const computed = getComputedStyle(document.documentElement);
      const read = key => (computed.getPropertyValue(key) || '').trim();
      return {
        background: read('--background') || '#f8fafc',
        surface: read('--surface-2') || '#eef2ff',
        border: read('--border') || '#d7deed',
        foreground: read('--foreground') || '#0f172a',
        muted: read('--muted-foreground') || '#475569',
        accent: read('--accent') || '#eaf2ff',
        accentForeground: read('--accent-foreground') || '#102341',
        primary: read('--primary') || '#2563eb',
        primaryForeground: read('--primary-foreground') || '#f8fafc'
      };
    }

    function buildDriverStateSnapshot(state){
      const registry = getRegistry(state);
      const layout = state.data.layout || {};
      const tables = registry.list().map(table => ({
        id: table.name,
        name: table.name,
        label: table.label || '',
        displayName: formatIdentifier(table.name),
        fields: (table.fields || []).map(field => ({
          name: field.name,
          type: field.type,
          pk: !!field.primaryKey,
          unique: !!field.unique,
          nullable: field.nullable !== false,
          default: field.defaultValue,
          references: field.references || null,
        })),
      }));
      const relations = [];
      registry.list().forEach(table => {
        (table.fields || []).forEach(field => {
          if(field.references && field.references.table){
            relations.push({
              id: `${table.name}:${field.name}â†’${field.references.table}:${field.references.column || field.references.field || 'id'}`,
              from: { table: table.name, field: field.name },
              to: {
                table: field.references.table,
                field: field.references.column || field.references.field || 'id',
              },
              cardinality: field.references.cardinality || '',
              onDelete: field.references.onDelete,
              onUpdate: field.references.onUpdate,
            });
          }
        });
      });
      return {
        tables,
        relations,
        layout,
        selection: state.data.selection || {},
        zoom: state.data.canvas?.zoom || 1,
      };
    }

    function scheduleDiagramRender(state){
      lastDiagramState = state;
      if(pendingDiagramFrame) return;
      pendingDiagramFrame = true;
      requestAnimationFrame(()=>{
        pendingDiagramFrame = false;
        const snapshot = erdAppInstance ? erdAppInstance.getState() : lastDiagramState;
        if(snapshot) renderDiagram(snapshot);
      });
    }

    function ensureDriverInstance(state){
      if(typeof window === 'undefined') return null;
      const host = document.getElementById('erd-diagram');
      if(!host) return null;
      const driverKey = (state?.env?.graph?.driver || 'fake').toLowerCase();
      if(erdDriver && activeDriverName === driverKey){
        return erdDriver;
      }
      if(erdDriver){
        try { erdDriver.destroy(); }
        catch(error){ console.warn('[Mishkah][ERD] driver destroy failed', error); }
        erdDriver = null;
      }
      const DriverCtor = DiagramDrivers[driverKey] || DiagramDrivers.fake;
      try {
        const instance = new DriverCtor();
        instance.init(host, {
          onNodeMove: handleDriverNodeMove,
          onSelect: handleDriverSelect,
          onEdgeConnect: handleDriverEdgeConnect,
        });
        erdDriver = instance;
        activeDriverName = driverKey;
        host.setAttribute('data-driver', driverKey);
        return erdDriver;
      } catch(error){
        console.warn('[Mishkah][ERD] failed to initialise driver', driverKey, error);
        if(driverKey !== 'fake'){
          try {
            const fallback = new FakeDriver();
            fallback.init(host, {
              onNodeMove: handleDriverNodeMove,
              onSelect: handleDriverSelect,
              onEdgeConnect: handleDriverEdgeConnect,
            });
            erdDriver = fallback;
            activeDriverName = 'fake';
            host.setAttribute('data-driver', 'fake');
            return erdDriver;
          } catch(fallbackError){
            console.error('[Mishkah][ERD] failed to initialise FakeDriver', fallbackError);
          }
        }
        return null;
      }
    }

    function renderDiagram(state){
      if(!state || typeof window === 'undefined') return;
      const host = document.getElementById('erd-diagram');
      if(!host) return;
      const driver = ensureDriverInstance(state);
      if(!driver) return;
      const payload = buildDriverStateSnapshot(state);
      const palette = currentPalette();
      host.style.background = palette.background || '#f8fafc';
      try {
        driver.render(payload);
      } catch(error){
        console.warn('[Mishkah][ERD] driver render failed', error);
      }
    }

    function extractFieldFromPort(portId){
      if(!portId) return '';
      const parts = String(portId).split(':');
      if(parts.length <= 1) return parts[0] || '';
      return parts.slice(1).join(':');
    }

    function handleDriverNodeMove(position){
      if(!erdAppInstance || !position) return;
      const id = String(position.id || '');
      if(!id) return;
      const x = Math.round(Number(position.x) || 0);
      const y = Math.round(Number(position.y) || 0);
      let persistRecord = null;
      erdAppInstance.setState(s => {
        const layout = Object.assign({}, s.data.layout || {});
        const current = layout[id] || {};
        if(current.x === x && current.y === y){
          return s;
        }
        layout[id] = { x, y };
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: s.data.schema,
          layout,
          canvas: s.data.canvas,
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now,
        };
        persistRecord = record;
        return {
          ...s,
          data:{
            ...s.data,
            layout,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) },
          },
          ui:{
            ...(s.ui || {}),
            form:{
              ...(s.ui?.form || {}),
              layout:{ x, y },
            },
          },
        };
      });
      erdAppInstance.rebuild();
      if(persistRecord){
        schedulePersist(persistRecord);
      }
    }

    function handleDriverSelect(ids){
      if(!erdAppInstance) return;
      const list = Array.isArray(ids) ? ids : [];
      if(!list.length) return;
      const tableName = list[0];
      if(!tableName) return;
      erdAppInstance.setState(s => withTableSelection(s, tableName));
      erdAppInstance.rebuild();
    }

    function handleDriverEdgeConnect(connection){
      if(!erdAppInstance || !connection) return;
      const sourceTable = connection.source?.id ? String(connection.source.id) : '';
      const targetTable = connection.target?.id ? String(connection.target.id) : '';
      const sourceField = extractFieldFromPort(connection.source?.port);
      const targetField = extractFieldFromPort(connection.target?.port);
      if(!sourceTable || !sourceField || !targetTable || !targetField) return;
      let persistRecord = null;
      erdAppInstance.setState(s => {
        const registry = Schema.Registry.fromJSON(s.data.schema);
        const table = registry.get(sourceTable);
        if(!table) return s;
        const field = table.getField(sourceField);
        if(!field) return s;
        const currentRefs = field.references || {};
        try {
          table.updateField(sourceField, {
            references:{
              table: targetTable,
              column: targetField,
              onDelete: currentRefs.onDelete || 'CASCADE',
              onUpdate: currentRefs.onUpdate || 'CASCADE',
              cardinality: currentRefs.cardinality,
            },
          });
        } catch(error){
          console.warn('[Mishkah][ERD] failed to apply edge connection', error);
          return s;
        }
        const schemaJSON = registry.toJSON();
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: schemaJSON,
          layout: s.data.layout,
          canvas: s.data.canvas,
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now,
        };
        persistRecord = record;
        let draft = {
          ...s,
          data:{
            ...s.data,
            schema: schemaJSON,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) },
          },
        };
        draft = withFieldSelection(draft, sourceTable, sourceField);
        return draft;
      });
      erdAppInstance.rebuild();
      if(persistRecord){
        schedulePersist(persistRecord);
      }
    }


    const SchemaLibrary = (function(){
      const storeName = 'schemas';
      const AdapterClass = (U && (U.IndexedDBX || U.IndexedDB)) || null;
      const hasIndexedDB = typeof indexedDB !== 'undefined' && !!AdapterClass;
      const adapter = hasIndexedDB ? new AdapterClass({
        name:'mishkah-erd',
        version:1,
        schema:{
          stores:{
            [storeName]:{
              keyPath:'id',
              autoIncrement:false,
              indexes:{
                by_name:{ keyPath:'name', unique:true },
                by_updatedAt:{ keyPath:'updatedAt' },
                by_createdAt:{ keyPath:'createdAt' }
              }
            }
          }
        }
      }) : null;
      const memory = new Map();
      const status = hasIndexedDB ? 'indexeddb' : 'memory';

      const SEED_SCHEMA = {
        id:'schema_seed',
        name:'commerce_schema',
        title:'Ù…Ø®Ø·Ø· Ù…ØªØ¬Ø± Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
        description:'Ù…Ø®Ø·Ø· Ø§ÙØªØ±Ø§Ø¶ÙŠ ÙŠÙˆØ¶Ø­ Ø¹Ù„Ø§Ù‚Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø¨Ø§Ù„Ø·Ù„Ø¨Ø§Øª ÙˆØ§Ù„Ù…Ø®Ø²ÙˆÙ† ÙˆØ§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª.',
        tables:[
          {
            name:'customers',
            label:'Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡',
            layout:{ x:120, y:160 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'full_name', type:'string', nullable:false, maxLength:180, comment:'Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…Ù„' },
              { name:'email', type:'string', nullable:false, unique:true, comment:'Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ÙØ±ÙŠØ¯ Ù„ÙƒÙ„ Ø¹Ù…ÙŠÙ„' },
              { name:'phone_number', type:'string', nullable:true, comment:'Ø±Ù‚Ù… Ù„Ù„ØªÙˆØ§ØµÙ„' },
              { name:'created_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'orders',
            label:'Ø§Ù„Ø·Ù„Ø¨Ø§Øª',
            layout:{ x:420, y:160 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_number', type:'string', nullable:false, unique:true, comment:'Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø¸Ø§Ù‡Ø± Ù„Ù„Ø¹Ù…ÙŠÙ„' },
              { name:'customer_id', type:'uuid', nullable:false, references:{ table:'customers', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'status', type:'string', nullable:false, defaultValue:'pending', enum:['pending','processing','shipped','completed','cancelled'] },
              { name:'total_amount', type:'decimal', nullable:false, precision:12, scale:2 },
              { name:'placed_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'order_items',
            label:'Ø¨Ù†ÙˆØ¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª',
            layout:{ x:720, y:200 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_id', type:'uuid', nullable:false, references:{ table:'orders', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'product_id', type:'uuid', nullable:false, references:{ table:'products', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'quantity', type:'integer', nullable:false, defaultValue:1 },
              { name:'unit_price', type:'decimal', nullable:false, precision:10, scale:2 },
              { name:'line_total', type:'decimal', nullable:false, precision:12, scale:2 }
            ]
          },
          {
            name:'products',
            label:'Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª',
            layout:{ x:420, y:360 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'name', type:'string', nullable:false, maxLength:160 },
              { name:'sku', type:'string', nullable:false, unique:true, comment:'Ù…Ø¹Ø±Ù‘Ù ÙØ±ÙŠØ¯ Ù„Ù„Ù…Ø®Ø²ÙˆÙ†' },
              { name:'price', type:'decimal', nullable:false, precision:10, scale:2 },
              { name:'stock_quantity', type:'integer', nullable:false, defaultValue:0 },
              { name:'category_id', type:'uuid', nullable:true, references:{ table:'categories', column:'id', onDelete:'SET NULL', onUpdate:'CASCADE' } },
              { name:'created_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'categories',
            label:'Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª',
            layout:{ x:120, y:360 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'name', type:'string', nullable:false, unique:true },
              { name:'description', type:'text', nullable:true }
            ]
          },
          {
            name:'payments',
            label:'Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª',
            layout:{ x:720, y:360 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_id', type:'uuid', nullable:false, references:{ table:'orders', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'payment_method', type:'string', nullable:false },
              { name:'paid_amount', type:'decimal', nullable:false, precision:12, scale:2 },
              { name:'paid_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          }
        ]
      };

      function buildSeedRecord(){
        const registry = new Schema.Registry({ tables: SEED_SCHEMA.tables });
        const layout = {};
        registry.list().forEach(table => {
          const pos = Object.assign({ x:120, y:120 }, table.layout || {});
          layout[table.name] = { x: pos.x, y: pos.y };
        });
        const now = Date.now();
        return {
          id: SEED_SCHEMA.id,
          name: SEED_SCHEMA.name,
          title: SEED_SCHEMA.title,
          description: SEED_SCHEMA.description,
          schema: registry.toJSON(),
          layout,
          canvas:{ zoom:1 },
          createdAt: now,
          updatedAt: now
        };
      }

      function normalize(input, { bumpUpdatedAt=true }={}){
        const now = Date.now();
        const id = input.id || U.Id.uid('schema');
        const name = (input.name || '').trim() || `schema_${id.slice(-4)}`;
        const title = (input.title || '').trim() || name;
        const description = (input.description || '').trim();
        const schema = clone(input.schema || { tables: [] });
        const layout = clone(input.layout || {});
        const canvas = clone(input.canvas || { zoom:1 });
        const createdAt = input.createdAt || now;
        const updatedAt = bumpUpdatedAt ? now : (input.updatedAt || now);
        return { id, name, title, description, schema, layout, canvas, createdAt, updatedAt };
      }

      async function ready(){
        if(adapter && adapter.ensureSchema){
          try { await adapter.ensureSchema(); }
          catch(error){ console.warn('[Mishkah][ERD] failed to ensure schema store', error); }
        }
        return true;
      }

      async function save(input, opts={}){
        const record = normalize(input, opts);
        if(adapter){
          try { await adapter.put(storeName, record); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB save failed', error); }
        }
        memory.set(record.id, clone(record));
        return clone(record);
      }

      async function get(id){
        if(!id) return null;
        if(adapter){
          try {
            const row = await adapter.get(storeName, id);
            if(row){
              memory.set(row.id, clone(row));
              return clone(row);
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB get failed', error);
          }
        }
        const existing = memory.get(id);
        return existing ? clone(existing) : null;
      }

      async function list(){
        if(adapter){
          try {
            const rows = await adapter.getAll(storeName);
            if(Array.isArray(rows)){
              rows.forEach(row => memory.set(row.id, clone(row)));
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB list failed', error);
          }
        }
        const out = Array.from(memory.values()).map(item => clone(item));
        out.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
        return out;
      }

      async function remove(id){
        if(!id) return false;
        if(adapter){
          try { await adapter.delete(storeName, id); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB delete failed', error); }
        }
        memory.delete(id);
        return true;
      }

      async function createBlank(meta={}){
        return save({
          id: meta.id,
          name: meta.name || '',
          title: meta.title || meta.name || 'Ù…Ø®Ø·Ø· Ø¬Ø¯ÙŠØ¯',
          description: meta.description || '',
          schema: new Schema.Registry().toJSON(),
          layout:{},
          canvas:{ zoom:1 },
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
      }

      async function createSeed(){
        const seed = buildSeedRecord();
        return save(seed, { bumpUpdatedAt:false });
      }

      return { status, available:true, ready, save, get, list, remove, createBlank, createSeed };
    })();

    await SchemaLibrary.ready();

    let libraryItems = await SchemaLibrary.list();
    if(!libraryItems.length){
      const seedRecord = await SchemaLibrary.createSeed();
      libraryItems = [seedRecord];
    }

    const activeRecord = libraryItems[0];
    const activeRegistry = Schema.Registry.fromJSON(activeRecord.schema || { tables: [] });

    function computeLayout(registry, layout){
      const map = Object.assign({}, layout || {});
      registry.list().forEach((table, index)=>{
        if(!map[table.name]){
          map[table.name] = table.layout || { x: 160 + index * 160, y: 120 + index * 80 };
        }
      });
      return map;
    }

    const initialLayout = computeLayout(activeRegistry, activeRecord.layout);
    const firstTable = activeRegistry.list()[0]?.name || null;
    const initialLayoutPoint = firstTable ? (initialLayout[firstTable] || { x:120, y:120 }) : { x:120, y:120 };

    const erdState = {
      head:{ title: activeRecord.title || 'Ù…Ø®Ø·Ø· Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙƒØ§Ø©' },
      env:{ theme:'dark', lang:'ar', dir:'rtl', graph:{ driver:'x6' } },
      data:{
        schemaId: activeRecord.id,
        schemaMeta:{
          name: activeRecord.name,
          title: activeRecord.title,
          description: activeRecord.description || ''
        },
        schemaCreatedAt: activeRecord.createdAt,
        schemaUpdatedAt: activeRecord.updatedAt,
        schema: activeRegistry.toJSON(),
        layout: initialLayout,
        selection:{ table:firstTable, field:null },
        canvas: activeRecord.canvas || { zoom:1 },
        sqlPreview:'',
        error:null,
        library:{ items: libraryItems, status: SchemaLibrary.status }
      },
      ui:{
        modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false },
        template:{ open:true },
        form:{
          table:{ name:'', nameInput:'', label:'', comment:'', includeId:true },
          field:{
            table:firstTable || '',
            name:'',
            columnName:'',
            type:'string',
            nullable:true,
            primaryKey:false,
            unique:false,
            defaultValue:'',
            references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
          },
          relation:{
            sourceTable:firstTable || '',
            sourceField:'',
            targetTable:'',
            targetField:'',
            onDelete:'CASCADE',
            onUpdate:'CASCADE'
          },
          import:{ name: activeRecord.name || '', title: activeRecord.title || '', targetId: activeRecord.id || '', text:'' },
          export:{ text:'' },
          sql:{ text:'' },
          layout:{ x: initialLayoutPoint.x, y: initialLayoutPoint.y },
          schemaMeta:{
            name: activeRecord.name || '',
            title: activeRecord.title || '',
            description: activeRecord.description || ''
          }
        }
      }
    };

    function getRegistry(db){
      try {
        return Schema.Registry.fromJSON(db.data.schema);
      } catch(error){
        console.warn('[Mishkah][ERD] schema parse failed', error);
        return new Schema.Registry();
      }
    }

    function ensureLayout(db, tableName){
      const layout = Object.assign({}, db.data.layout || {});
      if(!layout[tableName]) layout[tableName] = { x: 120, y: 120 };
      return layout;
    }

    function withTableSelection(state, tableName){
      if(!tableName) return state;
      const layout = ensureLayout({ data:{ layout: state.data.layout } }, tableName);
      const tablePos = layout[tableName] || { x: 120, y: 120 };
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field:null }, layout },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            field:{ ...(state.ui?.form?.field || {}), table: tableName },
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName },
            layout:{ x: tablePos.x, y: tablePos.y }
          }
        }
      };
    }

    function withFieldSelection(state, tableName, fieldName){
      if(!tableName || !fieldName) return state;
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field: fieldName } },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName, sourceField: fieldName }
          }
        }
      };
    }

    function mergeLibraryItems(list, record){
      const items = Array.isArray(list) ? list.slice() : [];
      const entry = clone(record);
      const idx = items.findIndex(item => item.id === record.id);
      if(idx >= 0) items[idx] = entry; else items.push(entry);
      items.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
      return items;
    }

    const schedulePersist = (function(){
      if(!SchemaLibrary.available) return ()=>{};
      const debounced = U.Control.debounce(async (record)=>{
        try{
          await SchemaLibrary.save(record, { bumpUpdatedAt:false });
        } catch(error){
          console.warn('[Mishkah][ERD] persist failed', error);
        }
      }, 600);
      return record => debounced(clone(record));
    })();

    function recordFromState(state){
      const meta = state.data.schemaMeta || {};
      return {
        id: state.data.schemaId,
        name: meta.name || '',
        title: meta.title || '',
        description: meta.description || '',
        schema: state.data.schema,
        layout: state.data.layout,
        canvas: state.data.canvas,
        createdAt: state.data.schemaCreatedAt,
        updatedAt: state.data.schemaUpdatedAt
      };
    }

    function SchemaLibraryPanel(db){
      const library = db.data.library || {};
      const items = library.items || [];
      const activeId = db.data.schemaId;
      const listContent = items.length
        ? D.Lists.Ul({ attrs:{ class: tw`flex flex-col gap-2 list-none m-0 p-0` } },
            items.map(item=> D.Lists.Li({ attrs:{ class: tw`rounded-xl border border-[var(--border)]/60 bg-[var(--surface-1)]/70 px-3 py-2 transition ${item.id === activeId ? 'ring-2 ring-[var(--primary)]/60' : 'hover:border-[var(--primary)]/50'}`, gkey:'erd:library:select', 'data-schema-id': item.id } }, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2` }}, [
                D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-0.5` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [item.title || item.name]),
                  D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [item.name])
                ]),
                D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-[10px] text-[var(--muted)]` }}, [U.Time.fmt(item.updatedAt || item.createdAt || Date.now())]),
                  UI.Button({ attrs:{ gkey:'erd:library:delete', 'data-schema-id': item.id, title:'Ø­Ø°Ù Ø§Ù„Ù…Ø®Ø·Ø·', class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, ['ğŸ—‘ï¸'])
                ])
              ])
            ])))
        : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['Ù„Ù… ÙŠØªÙ… Ø­ÙØ¸ Ø£ÙŠ Ù…Ø®Ø·Ø·Ø§Øª Ø¨Ø¹Ø¯.']);
      return D.Containers.Aside({ attrs:{ class: tw`hidden lg:flex w-72 flex-col border-l border-[var(--border)] bg-[var(--surface-2)]/70 backdrop-blur` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between px-4 py-3 border-b border-[var(--border)]` }}, [
          D.Text.Span({ attrs:{ class: tw`text-base font-semibold` }}, ['Ù…ÙƒØªØ¨Ø© Ø§Ù„Ù…Ø®Ø·Ø·Ø§Øª']),
          D.Text.Span({ attrs:{ class: tw`text-[10px] uppercase tracking-wide text-[var(--muted)]` }}, [library.status === 'indexeddb' ? 'IndexedDB' : 'Ø°Ø§ÙƒØ±Ø© Ù…Ø¤Ù‚ØªØ©'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`px-4 py-3 flex flex-col gap-2` }}, [
          UI.Button({ attrs:{ gkey:'erd:library:new' }, variant:'solid', size:'sm' }, ['â• Ù…Ø®Ø·Ø· Ø¬Ø¯ÙŠØ¯']),
          UI.Button({ attrs:{ gkey:'erd:import:open' }, variant:'ghost', size:'sm' }, ['â¬†ï¸ Ø§Ø³ØªÙŠØ±Ø§Ø¯ JSON'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`flex-1 overflow-y-auto px-3 pb-4` }}, [listContent])
      ]);
    }

    function TemplateOverlay(db, tables){
      const templateState = db.ui?.template || {};
      if(templateState.open === false) return null;
      const registryTables = Array.isArray(tables) ? tables : getRegistry(db).list();
      const previewTables = registryTables.slice(0, 6);
      const cards = previewTables.length
        ? previewTables.map(table => {
            const fieldCount = (table.fields || []).length;
            const relationCount = (table.fields || []).filter(field => field.references).length;
            return D.Containers.Div({ attrs:{ class: tw`rounded-xl border border-[var(--border)]/70 bg-[var(--surface-2)]/60 px-3 py-2 flex flex-col gap-1` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [formatIdentifier(table.name)]),
              table.label ? D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [table.label]) : null,
              D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [`Fields: ${fieldCount} Â· Relations: ${relationCount}`])
            ].filter(Boolean));
          })
        : [
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, ['Ø§Ø¨Ø¯Ø£ Ø¨Ø¥Ø¶Ø§ÙØ© Ø¬Ø¯ÙˆÙ„ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ù„Ø¨ Ø§Ù„Ù…Ø®Ø·Ø·.'])
          ];
      return D.Containers.Div({ attrs:{ class: tw`absolute bottom-4 left-4 z-20 w-80 max-w-full pointer-events-auto` }}, [
        D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)] bg-[var(--surface-1)]/95 shadow-xl backdrop-blur flex flex-col` }}, [
          D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between px-4 py-3 border-b border-[var(--border)]/80` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-semibold flex items-center gap-2` }}, ['ğŸ§© Ù…Ù„Ø®Øµ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ']),
            UI.Button({ attrs:{ gkey:'erd:template:toggle', title:'Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù…Ù„Ø®Øµ', class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, ['Ø¥Ø®ÙØ§Ø¡'])
          ]),
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2 px-4 py-3 max-h-60 overflow-y-auto` }}, cards),
          D.Containers.Div({ attrs:{ class: tw`px-4 py-2 border-t border-[var(--border)]/60` }}, [
            D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)] leading-relaxed` }}, ['Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ø®Øµ ÙŠÙˆØ¶Ø­ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø© ÙˆØ¹Ø¯Ø¯ Ø§Ù„Ø­Ù‚ÙˆÙ„ ÙˆØ§Ù„Ø¹Ù„Ø§Ù‚Ø§ØªØŒ Ù…Ù…Ø§ ÙŠØ³Ø§Ø¹Ø¯Ùƒ Ø¹Ù„Ù‰ ÙÙ‡Ù… Ø´ÙƒÙ„ Ø§Ù„Ù…Ø®Ø·Ø· Ø¨Ø³Ø±Ø¹Ø©.'])
          ])
        ])
      ]);
    }

    function SchemaCanvas(db){
      const registry = getRegistry(db);
      const tables = registry.list();
      scheduleDiagramRender(db);
      const hasTables = tables.length > 0;
      const emptyState = !hasTables
        ? D.Containers.Div({ attrs:{ class: tw`absolute inset-0 flex items-center justify-center pointer-events-none` }}, [
            D.Containers.Div({ attrs:{ class: tw`rounded-3xl border border-dashed border-[var(--border)] bg-[var(--surface-2)]/70 px-6 py-5 text-center text-sm text-[var(--muted)] max-w-md` }}, ['Ø£Ø¶Ù Ø¬Ø¯ÙˆÙ„Ù‹Ø§ Ø¬Ø¯ÙŠØ¯Ù‹Ø§ Ù„Ø¨Ø¯Ø¡ Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø®Ø·Ø·.'])
          ])
        : null;
      const overlay = TemplateOverlay(db, tables);
      return D.Containers.Div({ attrs:{ class: tw`relative flex-1 bg-[var(--surface-1)]` }}, [
        D.Containers.Div({ attrs:{ id:'erd-diagram', class: tw`absolute inset-0` }}, []),
        overlay,
        emptyState
      ].filter(Boolean));
    }

    function Toolbar(db){
      const zoom = db.data.canvas?.zoom || 1;
      const metaTitle = db.data.schemaMeta?.title || 'Ù…Ø®Ø·Ø· Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…';
      const schemaIdentifier = db.data.schemaMeta?.name ? formatIdentifier(db.data.schemaMeta.name) : '';
      const lang = db.env?.lang || db.i18n?.lang || 'ar';
      const theme = db.env?.theme || 'dark';
      const templateOpen = db.ui?.template?.open !== false;
      return UI.Toolbar({
        left:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col` }}, [
            D.Text.Span({ attrs:{ class: tw`text-xl font-bold` }}, [metaTitle]),
            schemaIdentifier ? D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [schemaIdentifier]) : null
          ].filter(Boolean)),
          UI.Button({ attrs:{ gkey:'erd:schema:meta:open' }, variant:'ghost', size:'sm' }, ['âœï¸ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø®Ø·Ø·']),
          UI.Button({ attrs:{ gkey:'erd:table:add' }, variant:'ghost', size:'sm' }, ['â• Ø¬Ø¯ÙˆÙ„']),
          UI.Button({ attrs:{ gkey:'erd:field:add' }, variant:'ghost', size:'sm' }, ['â• Ø­Ù‚Ù„']),
          UI.Button({ attrs:{ gkey:'erd:relation:add' }, variant:'ghost', size:'sm' }, ['ğŸ”— Ø¹Ù„Ø§Ù‚Ø©']),
          UI.Button({ attrs:{ gkey:'erd:template:toggle' }, variant: templateOpen ? 'secondary' : 'ghost', size:'sm' }, [templateOpen ? 'ğŸ§© Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù‚Ø§Ù„Ø¨' : 'ğŸ§© Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ù„Ø¨'])
        ],
        right:[
          UI.LanguageSwitch({ lang }),
          UI.ThemeToggleIcon({ theme }),
          UI.Button({ attrs:{ gkey:'erd:undo', title:'ØªØ±Ø§Ø¬Ø¹' }, variant:'ghost', size:'sm' }, ['â†º']),
          UI.Button({ attrs:{ gkey:'erd:redo', title:'Ø¥Ø¹Ø§Ø¯Ø©' }, variant:'ghost', size:'sm' }, ['â†»']),
          UI.Button({ attrs:{ gkey:'erd:fit', title:'Ù…Ù„Ø§Ø¡Ù…Ø© Ø§Ù„Ù…Ø®Ø·Ø· Ù„Ù„Ø´Ø§Ø´Ø©' }, variant:'ghost', size:'sm' }, ['ğŸ—ºï¸']),
          UI.Button({ attrs:{ gkey:'erd:export:svg', title:'ØªØµØ¯ÙŠØ± SVG' }, variant:'ghost', size:'sm' }, ['ğŸ–¼ï¸ SVG']),
          UI.Button({ attrs:{ gkey:'erd:export:png', title:'ØªØµØ¯ÙŠØ± PNG' }, variant:'ghost', size:'sm' }, ['ğŸ–¼ï¸ PNG']),
          UI.Button({ attrs:{ gkey:'erd:export:json' }, variant:'ghost', size:'sm' }, ['â¬‡ï¸ ØªØµØ¯ÙŠØ± JSON']),
          UI.Button({ attrs:{ gkey:'erd:export:sql' }, variant:'ghost', size:'sm' }, ['ğŸ§¾ SQL']),
          UI.Button({ attrs:{ gkey:'erd:zoom:out', title:'ØªØµØºÙŠØ±' }, variant:'ghost', size:'sm' }, ['â–']),
          D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, [`${Math.round(zoom * 100)}%`]),
          UI.Button({ attrs:{ gkey:'erd:zoom:reset', title:'Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø¬Ù…' }, variant:'ghost', size:'sm' }, ['âŸ³']),
          UI.Button({ attrs:{ gkey:'erd:zoom:in', title:'ØªÙƒØ¨ÙŠØ±' }, variant:'ghost', size:'sm' }, ['â•'])
        ]
      });
    }

    function InspectorPanel(db){
      const selection = db.data.selection || {};
      const registry = getRegistry(db);
      const table = selection.table ? registry.get(selection.table) : null;
      const layout = db.data.layout || {};
      const formLayout = db.ui?.form?.layout || { x:0, y:0 };
      const relationships = table ? (table.fields || []).filter(field=> field.references) : [];
      return D.Containers.Aside({ attrs:{ class: tw`hidden xl:flex w-80 flex-col border-r border-[var(--border)] bg-[var(--surface-2)]/90 backdrop-blur p-4 gap-4` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
          D.Text.H3({ attrs:{ class: tw`text-lg font-semibold` }}, ['Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø®Ø·Ø·']),
          UI.Button({ attrs:{ gkey:'erd:schema:meta:open', class: tw`justify-center` }, variant:'secondary', size:'sm' }, ['ØªØ­Ø±ÙŠØ± Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„ÙˆØµÙ'])
        ]),
        D.Text.H3({ attrs:{ class: tw`text-lg font-semibold` }}, ['Ø§Ù„ØªÙØ§ØµÙŠÙ„']),
        table ? D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
          D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [`${table.sqlName || Schema.utils.toSnakeCase(table.name)}`]),
          table.label ? D.Text.Span({ attrs:{ class: tw`text-sm` }}, [`Ø§Ù„Ù…Ø³Ù…Ù‰ Ø§Ù„Ø¥Ø¶Ø§ÙÙŠ: ${table.label}`]) : null,
          D.Text.Span({ attrs:{ class: tw`text-sm` }}, [`Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ù‚ÙˆÙ„: ${table.fields.length}`]),
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù„ÙˆØ­Ø©']),
            UI.Input({ attrs:{ gkey:'erd:layout:input', 'data-axis':'x', value:String(formLayout.x), type:'number', class: tw`w-full`, placeholder:'Ø§Ù„Ù…Ø­ÙˆØ± X' } }),
            UI.Input({ attrs:{ gkey:'erd:layout:input', 'data-axis':'y', value:String(formLayout.y), type:'number', class: tw`w-full`, placeholder:'Ø§Ù„Ù…Ø­ÙˆØ± Y' } }),
            UI.Button({ attrs:{ gkey:'erd:layout:apply', variant:'solid', size:'sm' }}, ['ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆÙ‚Ø¹'])
          ]),
          relationships.length ? D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-1` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø®Ø§Ø±Ø¬Ø©']),
            ...relationships.map(field=> D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [`${field.name} â†’ ${field.references.table}.${field.references.column}`]))
          ]) : D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, ['Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù„Ø§Ù‚Ø§Øª Ù…Ø­Ø¯Ø¯Ø©.'])
        ].filter(Boolean)) : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['Ø§Ø®ØªØ± Ø¬Ø¯ÙˆÙ„Ù‹Ø§ Ù…Ù† Ø§Ù„Ù…Ø®Ø·Ø· Ù„Ø§Ø³ØªØ¹Ø±Ø§Ø¶ ØªÙØ§ØµÙŠÙ„Ù‡.'])
      ]);
    }

    function ModalImport(db){
      const open = db.ui?.modals?.import;
      const form = db.ui?.form?.import || { name:'', title:'', targetId:'', text:'' };
      const library = db.data.library || {};
      const items = library.items || [];
      return UI.Modal({
        open,
        size:'lg',
        title:'Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ø®Ø·Ø· JSON',
        description:'Ø£Ù„ØµÙ‚ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø·Ø· Ø£Ùˆ Ø§Ø³ØªØ¨Ø¯Ù„ Ù…Ø®Ø·Ø·Ù‹Ø§ Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'name', value: form.name || '', placeholder:'Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„ÙØ±ÙŠØ¯ Ù„Ù„Ù…Ø®Ø·Ø· (name)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'title', value: form.title || '', placeholder:'Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶' } }),
            UI.Select({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'targetId', value: form.targetId || '' }, options:[
              { value:'', label:'Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø®Ø·Ø· Ø¬Ø¯ÙŠØ¯' },
              ...items.map(item=> ({ value:item.id, label:`Ø§Ø³ØªØ¨Ø¯Ø§Ù„: ${item.title || item.name}` }))
            ] }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'text', value: form.text || '', rows:12, class: tw`w-full font-mono text-xs`, placeholder:'{"schema":{...}}' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:import:apply', variant:'solid', size:'sm' }}, ['Ø§Ø³ØªÙŠØ±Ø§Ø¯ ÙˆØªØ®Ø²ÙŠÙ†']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['Ø¥ØºÙ„Ø§Ù‚'])
        ]
      });
    }

    function ModalExportJson(db){
      const open = db.ui?.modals?.exportJson;
      const text = db.ui?.form?.export?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'Ù…Ø®Ø·Ø· JSON',
        description:'Ø§Ù†Ø³Ø® Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ Ø£Ù…Ø§ÙƒÙ† Ø£Ø®Ø±Ù‰.',
        closeGkey:'erd:modal:close',
        content:[
          UI.Textarea({ attrs:{ readonly:true, value: text, rows:14, class: tw`w-full font-mono text-xs` } })
        ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['ØªÙ…']) ]
      });
    }

    function ModalExportSql(db){
      const open = db.ui?.modals?.exportSql;
      const text = db.ui?.form?.sql?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'Ù†Øµ SQL',
        description:'Ù‡Ø°Ø§ Ø§Ù„Ù†Øµ ÙŠÙ…Ø«Ù„ Ø£ÙˆØ§Ù…Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ PostgreSQL.',
        closeGkey:'erd:modal:close',
        content:[ UI.Textarea({ attrs:{ readonly:true, value: text, rows:16, class: tw`w-full font-mono text-xs` } }) ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['ØªÙ…']) ]
      });
    }

    function ModalSchemaMeta(db){
      const open = db.ui?.modals?.schemaMeta;
      const form = db.ui?.form?.schemaMeta || { name:'', title:'', description:'' };
      return UI.Modal({
        open,
        size:'md',
        title:'Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø®Ø·Ø·',
        description:'Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« Ø§Ø³Ù… Ø§Ù„ØªØ¹Ø±ÙŠÙ ÙˆØ§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ§Ù„ÙˆØµÙ.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'name', value: form.name || '', placeholder:'Name (snake_case)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'title', value: form.title || '', placeholder:'Title' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'description', value: form.description || '', rows:4, placeholder:'ÙˆØµÙ Ù…Ø®ØªØµØ± Ù„Ù„Ù…Ø®Ø·Ø·' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:schema:meta:save', variant:'solid', size:'sm' }}, ['Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['Ø¥Ù„ØºØ§Ø¡'])
        ]
      });
    }

    function ModalAddTable(db){
      const open = db.ui?.modals?.table;
      const form = db.ui?.form?.table || { name:'', nameInput:'', label:'', comment:'', includeId:true };
      const registry = getRegistry(db);
      const sanitizedName = form.name || '';
      const suggestedName = sanitizedName || (form.label ? sanitizeSqlIdentifier(form.label) : '');
      const helperText = suggestedName
        ? `Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„Ø§Ø³Ù…: ${suggestedName} Ù…Ø¹ Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… ØªÙƒØ±Ø§Ø± Ø§Ù„Ù…Ø¹Ø±Ù Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø®Ø·Ø·.`
        : 'Ø§ÙƒØªØ¨ Ø§Ø³Ù…Ù‹Ø§ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠÙ‹Ø§ØŒ ÙˆØ³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ø³Ø§ÙØ§Øª ÙˆØ§Ù„Ù…Ø­Ø§Ø±Ù Ø§Ù„Ø®Ø§ØµØ© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¥Ù„Ù‰ ØµÙŠØºØ© SQL Ø³Ù„ÙŠÙ…Ø©.';
      return UI.Modal({
        open,
        size:'md',
        title:'Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø¬Ø¯ÙŠØ¯',
        description:'Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ Ù…Ø·Ù„ÙˆØ¨ ÙˆØ³ÙŠÙØ³ØªØ®Ø¯Ù… ÙƒØ§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ù…Ù‰ Ø¨Ù„ØºØ© Ø£Ø®Ø±Ù‰ Ø§Ø®ØªÙŠØ§Ø±ÙŠÙ‹Ø§.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'name', value: form.nameInput || '', placeholder:'English name (Ù…Ø«Ø§Ù„: Sales Orders)' } }),
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [helperText]),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'label', value: form.label || '', placeholder:'Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ù„ØºØ© Ø«Ø§Ù†ÙŠØ© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'comment', value: form.comment || '', rows:3, placeholder:'Ù…Ù„Ø§Ø­Ø¸Ø§Øª' } }),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-2` }}, [
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'table', 'data-field':'includeId', type:'checkbox', checked: form.includeId !== false } }),
              UI.Label({ text:'Ø¥Ù†Ø´Ø§Ø¡ Ø­Ù‚Ù„ id Ø§ÙØªØ±Ø§Ø¶ÙŠØŸ' })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:table:create', variant:'solid', size:'sm' }}, ['Ø¥Ù†Ø´Ø§Ø¡']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['Ø¥Ù„ØºØ§Ø¡'])
        ]
      });
    }

    function ModalAddField(db){
      const open = db.ui?.modals?.field;
      const form = db.ui?.form?.field || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} â€” ${table.label}`
          : formatIdentifier(table.name)
      }));
      const selectedTable = form.table && registry.get(form.table)
        ? form.table
        : (tableOptions[0]?.value || '');
      const currentTable = selectedTable ? registry.get(selectedTable) : null;
      const previewFieldName = form.name || (form.label ? computeFieldIdentifier(currentTable, form.label) : '');
      const selectedReferenceTable = form.references?.table && registry.get(form.references.table)
        ? form.references.table
        : '';
      const referenceTableEntity = selectedReferenceTable ? registry.get(selectedReferenceTable) : null;
      const referenceFieldOptions = referenceTableEntity
        ? referenceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const selectedReferenceField = referenceFieldOptions.some(opt => opt.value === form.references?.column)
        ? form.references?.column
        : '';
      return UI.Modal({
        open,
        size:'lg',
        title:'Ø¥Ø¶Ø§ÙØ© Ø­Ù‚Ù„',
        description:'Ø­Ø¯Ø¯ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{
                gkey:'erd:form:update',
                'data-form':'field',
                'data-field':'table',
                value: selectedTable || ''
              },
              options:[{ value:'', label:'Ø§Ø®ØªØ± Ø§Ù„Ø¬Ø¯ÙˆÙ„' }, ...tableOptions]
            }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'label', value: form.label || '', placeholder:'Ø§Ù„Ù…Ø³Ù…Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠ Ù„Ù„Ø­Ù‚Ù„' } }),
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)] md:col-span-2` }}, [previewFieldName ? `Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ: ${previewFieldName}` : 'Ø³ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø¹Ø±Ù ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¹Ù†Ø¯ Ø§Ù„ÙƒØªØ§Ø¨Ø©.']),
            UI.Select({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'type', value: form.type || 'string' }, options: DEFAULT_FIELD_TYPES.map(type=> ({ value:type, label:type })) }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'defaultValue', value: form.defaultValue || '', placeholder:'Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©' } }),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'NullableØŸ' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'nullable', type:'checkbox', checked: form.nullable !== false } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Primary KeyØŸ' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'primaryKey', type:'checkbox', checked: !!form.primaryKey } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'UniqueØŸ' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'unique', type:'checkbox', checked: !!form.unique } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`col-span-full flex flex-col gap-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['Ø¹Ù„Ø§Ù‚Ø© Ù…Ø±Ø¬Ø¹ÙŠØ© Ø§Ø®ØªÙŠØ§Ø±ÙŠØ©']),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'table',
                  value: selectedReferenceTable
                },
                options:[{ value:'', label:'Ø¨Ø¯ÙˆÙ† Ø¹Ù„Ø§Ù‚Ø©' }, ...tableOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'column',
                  value: selectedReferenceField
                },
                options:[{ value:'', label:'Ø§Ø®ØªØ± Ø§Ù„Ø­Ù‚Ù„' }, ...referenceFieldOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onDelete',
                  value: form.references?.onDelete || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onUpdate',
                  value: form.references?.onUpdate || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:field:create', variant:'solid', size:'sm' }}, ['Ø¥Ø¶Ø§ÙØ©']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['Ø¥Ù„ØºØ§Ø¡'])
        ]
      });
    }

    function ModalRelation(db){
      const open = db.ui?.modals?.relation;
      const form = db.ui?.form?.relation || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} â€” ${table.label}`
          : formatIdentifier(table.name)
      }));
      const sourceTableValue = form.sourceTable && registry.get(form.sourceTable)
        ? form.sourceTable
        : '';
      const sourceTableEntity = sourceTableValue ? registry.get(sourceTableValue) : null;
      const sourceFieldOptions = sourceTableEntity
        ? sourceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const sourceFieldValue = sourceFieldOptions.some(opt => opt.value === form.sourceField)
        ? form.sourceField
        : '';
      const targetTableValue = form.targetTable && registry.get(form.targetTable)
        ? form.targetTable
        : '';
      const targetTableEntity = targetTableValue ? registry.get(targetTableValue) : null;
      const targetFieldOptions = targetTableEntity
        ? targetTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const targetFieldValue = targetFieldOptions.some(opt => opt.value === form.targetField)
        ? form.targetField
        : '';
      return UI.Modal({
        open,
        size:'md',
        title:'Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„',
        description:'Ø­Ø¯Ø¯ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…ØµØ¯Ø± ÙˆØ§Ù„Ù‡Ø¯Ù ÙˆØ£Ø³Ù„ÙˆØ¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceTable', value: sourceTableValue },
              options:[{ value:'', label:'Ø§Ø®ØªØ± Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…ØµØ¯Ø±' }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceField', value: sourceFieldValue },
              options:[{ value:'', label:'Ø§Ø®ØªØ± Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ù…ØµØ¯Ø±' }, ...sourceFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetTable', value: targetTableValue },
              options:[{ value:'', label:'Ø§Ø®ØªØ± Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù‡Ø¯Ù' }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetField', value: targetFieldValue },
              options:[{ value:'', label:'Ø§Ø®ØªØ± Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ù‡Ø¯Ù' }, ...targetFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onDelete', value: form.onDelete || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onUpdate', value: form.onUpdate || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:relation:create', variant:'solid', size:'sm' }}, ['Ø­ÙØ¸ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø©']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['Ø¥Ù„ØºØ§Ø¡'])
        ]
      });
    }

    function Modals(db){
      return [
        ModalImport(db),
        ModalExportJson(db),
        ModalExportSql(db),
        ModalSchemaMeta(db),
        ModalAddTable(db),
        ModalAddField(db),
        ModalRelation(db)
      ];
    }

    function AppView(db){
      return D.Containers.Div({ attrs:{ class: tw`flex h-screen w-full bg-[var(--surface-0)] text-[var(--foreground)]` }}, [
        SchemaLibraryPanel(db),
        D.Containers.Div({ attrs:{ class: tw`flex flex-1 flex-col` }}, [
          Toolbar(db),
          SchemaCanvas(db)
        ]),
        InspectorPanel(db),
        ...Modals(db)
      ]);
    }

    const erdOrders = {
      'erd.fit':{
        on:['click'],
        gkeys:['erd:fit'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.fitToScreen === 'function'){
            try { driver.fitToScreen(16); }
            catch(error){ console.warn('[Mishkah][ERD] fit failed', error); }
          } else {
            UI.pushToast(ctx, { title:'Ù„Ù… ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Ø£Ø¯Ø§Ø© Ø§Ù„Ø±Ø³Ù… Ø¨Ø¹Ø¯', icon:'âš ï¸' });
          }
        }
      },
      'erd.undo':{
        on:['click'],
        gkeys:['erd:undo'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.undo === 'function'){
            try { driver.undo(); }
            catch(error){ console.warn('[Mishkah][ERD] undo failed', error); }
          }
        }
      },
      'erd.redo':{
        on:['click'],
        gkeys:['erd:redo'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.redo === 'function'){
            try { driver.redo(); }
            catch(error){ console.warn('[Mishkah][ERD] redo failed', error); }
          }
        }
      },
      'erd.zoom.in':{
        on:['click'],
        gkeys:['erd:zoom:in'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.min(2, (s.data.canvas?.zoom || 1) + 0.1);
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas:{ zoom },
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas:{ zoom },
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.out':{
        on:['click'],
        gkeys:['erd:zoom:out'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.max(0.2, (s.data.canvas?.zoom || 1) - 0.1);
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas:{ zoom },
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas:{ zoom },
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.reset':{
        on:['click'],
        gkeys:['erd:zoom:reset'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas:{ zoom:1 },
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas:{ zoom:1 },
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.export.svg':{
        on:['click'],
        gkeys:['erd:export:svg'],
        handler: async (e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(!driver || typeof driver.exportSVG !== 'function'){
            UI.pushToast(ctx, { title:'Ø³Ø§Ø¦Ù‚ Ø§Ù„Ø±Ø³Ù… Ù„Ø§ ÙŠØ¯Ø¹Ù… ØªØµØ¯ÙŠØ± SVG', icon:'âš ï¸' });
            return;
          }
          try{
            const svg = await driver.exportSVG();
            const blob = svg instanceof Blob ? svg : new Blob([svg], { type:'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const name = ctx.getState().data?.schemaMeta?.name || 'schema';
            link.href = url;
            link.download = `${name}.svg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            UI.pushToast(ctx, { title:'ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„Ø±Ø³Ù… Ø¨ØµÙŠØºØ© SVG', icon:'âœ…' });
          } catch(error){
            console.warn('[Mishkah][ERD] export SVG failed', error);
            UI.pushToast(ctx, { title:'ØªØ¹Ø°Ø± ØªØµØ¯ÙŠØ± SVG', message:String(error), icon:'ğŸ›‘' });
          }
        }
      },
      'erd.export.png':{
        on:['click'],
        gkeys:['erd:export:png'],
        handler: async (e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(!driver || typeof driver.exportPNG !== 'function'){
            UI.pushToast(ctx, { title:'Ø³Ø§Ø¦Ù‚ Ø§Ù„Ø±Ø³Ù… Ù„Ø§ ÙŠØ¯Ø¹Ù… ØªØµØ¯ÙŠØ± PNG', icon:'âš ï¸' });
            return;
          }
          try{
            const blob = await driver.exportPNG({ background: currentPalette().background || '#ffffff' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const name = ctx.getState().data?.schemaMeta?.name || 'schema';
            link.href = url;
            link.download = `${name}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            UI.pushToast(ctx, { title:'ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„Ø±Ø³Ù… Ø¨ØµÙŠØºØ© PNG', icon:'âœ…' });
          } catch(error){
            console.warn('[Mishkah][ERD] export PNG failed', error);
            UI.pushToast(ctx, { title:'ØªØ¹Ø°Ø± ØªØµØ¯ÙŠØ± PNG', message:String(error), icon:'ğŸ›‘' });
          }
        }
      },
      'erd.table.select':{
        on:['click'],
        gkeys:['erd:table:select'],
        handler:(e,ctx)=>{
          const card = e.target.closest('[data-table-name]');
          if(!card) return;
          const tableName = card.getAttribute('data-table-name');
          ctx.setState(s => withTableSelection(s, tableName));
          ctx.rebuild();
        }
      },
      'erd.field.select':{
        on:['click'],
        gkeys:['erd:field:select'],
        handler:(e,ctx)=>{
          const row = e.target.closest('[data-field-name]');
          if(!row) return;
          const tableName = row.getAttribute('data-table-name');
          const fieldName = row.getAttribute('data-field-name');
          ctx.setState(s => withFieldSelection(s, tableName, fieldName));
          ctx.rebuild();
        }
      },
      'erd.import.open':{
        on:['click'],
        gkeys:['erd:import:open'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), import:true },
              form:{ ...(s.ui?.form || {}), import:{ name: payload.name, title: payload.title, targetId: s.data.schemaId || '', text: JSON.stringify(payload, null, 2) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.export.json':{
        on:['click'],
        gkeys:['erd:export:json'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas,
            createdAt: state.data.schemaCreatedAt,
            updatedAt: state.data.schemaUpdatedAt
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), exportJson:true },
              form:{ ...(s.ui?.form || {}), export:{ text: JSON.stringify(payload, null, 2) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.export.sql':{
        on:['click'],
        gkeys:['erd:export:sql'],
        handler:(e,ctx)=>{
          const registry = getRegistry(ctx.getState());
          const sql = registry.generateSQL({ schemaName:'public' });
          ctx.setState(s=>({
            ...s,
            data:{ ...s.data, sqlPreview: sql },
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), exportSql:true },
              form:{ ...(s.ui?.form || {}), sql:{ text: sql } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.modal.close':{
        on:['click'],
        gkeys:['erd:modal:close','ui:modal:close'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false } }
          }));
          ctx.rebuild();
        }
      },
      'erd.template.toggle':{
        on:['click'],
        gkeys:['erd:template:toggle'],
        handler:(e,ctx)=>{
          ctx.setState(s=>{
            const currentOpen = s.ui?.template?.open !== false;
            const nextOpen = !currentOpen;
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                template:{ ...(s.ui?.template || {}), open: nextOpen }
              }
            };
          });
          ctx.rebuild();
        }
      },
      'erd.form.update':{
        on:['input','change'],
        gkeys:['erd:form:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          const parent = input.getAttribute('data-parent');
          if(!formKey) return;
          const value = input.value;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            if(formKey === 'fieldRef' || formKey === 'fieldRefColumn' || parent === 'field'){
              const current = currentForms.field || {};
              let nextRef = { ...(current.references || {}) };
              if(fieldKey){
                nextRef[fieldKey] = value;
              }
              if(fieldKey === 'table'){
                nextRef = { ...nextRef, table: value, column: '' };
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...current, references: nextRef } } } };
            }
            if(formKey === 'table' && fieldKey === 'name'){
              const targetForm = currentForms.table || {};
              const normalized = sanitizeSqlIdentifier(value);
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    table:{ ...targetForm, name: normalized, nameInput: value }
                  }
                }
              };
            }
            if(formKey === 'table' && fieldKey === 'label'){
              const targetForm = currentForms.table || {};
              const hasNameInput = !!(targetForm.nameInput && targetForm.nameInput.trim());
              const suggestion = sanitizeSqlIdentifier(value);
              const nextTable = { ...targetForm, label: value };
              if(!hasNameInput){
                nextTable.name = suggestion;
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, table: nextTable } } };
            }
            if(formKey === 'field' && fieldKey === 'label'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = targetForm.table ? registry.get(targetForm.table) : null;
              const slug = computeFieldIdentifier(table, value);
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...targetForm, label:value, name: slug, columnName: slug } } } };
            }
            if(formKey === 'field' && fieldKey === 'table'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = value ? registry.get(value) : null;
              let slug = targetForm.name || '';
              if(targetForm.label){
                slug = computeFieldIdentifier(table, targetForm.label);
              }
              const currentRefs = targetForm.references || {};
              const references = currentRefs.table === value
                ? currentRefs
                : { table:'', column:'', onDelete: currentRefs.onDelete || 'CASCADE', onUpdate: currentRefs.onUpdate || 'CASCADE' };
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...targetForm, table:value, name: slug, columnName: slug, references } } } };
            }
            if(formKey === 'relation' && fieldKey === 'sourceTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, sourceTable: value, sourceField:'' } } }
              };
            }
            if(formKey === 'relation' && fieldKey === 'targetTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, targetTable: value, targetField:'' } } }
              };
            }
            if(fieldKey){
              const targetForm = currentForms[formKey] || {};
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: value } } } };
            }
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: value } } };
          });
          ctx.rebuild();
        }
      },
      'erd.form.toggle':{
        on:['change'],
        gkeys:['erd:form:toggle'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          if(!formKey || !fieldKey) return;
          const checked = input.checked;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            const targetForm = currentForms[formKey] || {};
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: checked } } } };
          });
          ctx.rebuild();
        }
      },
      'erd.table.add':{
        on:['click'],
        gkeys:['erd:table:add'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), table:true } }
          }));
          ctx.rebuild();
        }
      },
      'erd.table.create':{
        on:['click'],
        gkeys:['erd:table:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.table || {};
          const registry = getRegistry(state);
          const englishInput = (form.name || '').trim();
          if(!englishInput){
            UI.pushToast(ctx, { title:'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ Ù„Ù„Ø¬Ø¯ÙˆÙ„', icon:'âš ï¸' });
            return;
          }
          const name = computeTableIdentifier(registry, englishInput);
          const label = (form.label || '').trim();
          try{
            const tableConfig = {
              name,
              label: label || '',
              comment: form.comment || '',
              layout:{ x: 160 + registry.list().length * 120, y: 120 + registry.list().length * 60 },
              fields: []
            };
            if(form.includeId){
              tableConfig.fields.push({ name:'id', columnName:'id', type:'uuid', primaryKey:true, nullable:false });
            }
            registry.register(tableConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const layout = ensureLayout({ data:{ layout: s.data.layout } }, name);
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                head:{ ...(s.head || {}), title: record.title || (s.head?.title || 'Ù…Ø®Ø·Ø· Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙƒØ§Ø©') },
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  layout,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), table:false },
                  form:{
                    ...(s.ui?.form || {}),
                    table:{ name:'', nameInput:'', label:'', comment:'', includeId:true },
                    field:{ ...(s.ui?.form?.field || {}), table: name, label:'', name:'', columnName:'' },
                    layout:{ x: layout[name].x, y: layout[name].y }
                  }
                }
              };
              draft = withTableSelection(draft, name);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create table', error);
            UI.pushToast(ctx, { title:'ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„', message:String(error), icon:'ğŸ›‘' });
          }
        }
      },
      'erd.field.add':{
        on:['click'],
        gkeys:['erd:field:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const first = registry.list()[0]?.name || '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), field:true },
              form:{
                ...(s.ui?.form || {}),
                field:{
                  table: s.data.selection?.table || first,
                  label:'',
                  name:'',
                  columnName:'',
                  type:'string',
                  nullable:true,
                  primaryKey:false,
                  unique:false,
                  defaultValue:'',
                  references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
                }
              }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.field.create':{
        on:['click'],
        gkeys:['erd:field:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.field || {};
          const tableName = (form.table || '').trim();
          const label = (form.label || '').trim();
          if(!tableName || !label){
            UI.pushToast(ctx, { title:'Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙˆØ§Ù„Ù…Ø³Ù…Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠ Ù„Ù„Ø­Ù‚Ù„ Ù…Ø·Ù„ÙˆØ¨Ø§Ù†', icon:'âš ï¸' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:'Ø§Ù„Ø¬Ø¯ÙˆÙ„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', icon:'âš ï¸' });
            return;
          }
          try{
            const fieldName = computeFieldIdentifier(table, label);
            const fieldConfig = {
              name: fieldName,
              columnName: form.columnName ? Schema.utils.toSnakeCase(form.columnName) : fieldName,
              type: form.type || 'string',
              nullable: form.nullable !== false,
              primaryKey: !!form.primaryKey,
              unique: !!form.unique,
              comment: label
            };
            if(form.defaultValue){
              const val = form.defaultValue;
              if(['integer','number','decimal','float'].includes(fieldConfig.type)){
                const num = Number(val);
                if(!Number.isNaN(num)) fieldConfig.defaultValue = num;
              } else if(fieldConfig.type === 'boolean'){
                fieldConfig.defaultValue = ['true','1','yes','on'].includes(String(val).toLowerCase());
              } else {
                fieldConfig.defaultValue = val;
              }
            }
            if(form.references && form.references.table && form.references.column){
              fieldConfig.references = {
                table: form.references.table,
                column: form.references.column,
                onDelete: form.references.onDelete || 'CASCADE',
                onUpdate: form.references.onUpdate || 'CASCADE'
              };
            }
            table.addField(fieldConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), field:false },
                  form:{ ...(s.ui?.form || {}), field:{ ...form, label:'', name:'', columnName:'', defaultValue:'', primaryKey:false, unique:false } }
                }
              };
              draft = withFieldSelection(draft, tableName, fieldName);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to add field', error);
            UI.pushToast(ctx, { title:'ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚Ù„', message:String(error), icon:'ğŸ›‘' });
          }
        }
      },
      'erd.relation.add':{
        on:['click'],
        gkeys:['erd:relation:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), relation:true },
              form:{ ...(s.ui?.form || {}), relation:{ sourceTable: selection.table || '', sourceField: selection.field || '', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.relation.create':{
        on:['click'],
        gkeys:['erd:relation:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.relation || {};
          if(!form.sourceTable || !form.sourceField || !form.targetTable || !form.targetField){
            UI.pushToast(ctx, { title:'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…ØµØ¯Ø± ÙˆØ§Ù„Ù‡Ø¯Ù', icon:'âš ï¸' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(form.sourceTable);
          if(!table){
            UI.pushToast(ctx, { title:'Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…ØµØ¯Ø± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', icon:'âš ï¸' });
            return;
          }
          try{
            table.updateField(form.sourceField, {
              references:{
                table: form.targetTable,
                column: form.targetField,
                onDelete: form.onDelete || 'CASCADE',
                onUpdate: form.onUpdate || 'CASCADE'
              }
            });
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), relation:false } }
              };
              draft = withFieldSelection(draft, form.sourceTable, form.sourceField);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create relation', error);
            UI.pushToast(ctx, { title:'ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø©', message:String(error), icon:'ğŸ›‘' });
          }
        }
      },
      'erd.import.apply':{
        on:['click'],
        gkeys:['erd:import:apply'],
        handler:async (e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.import || {};
          const raw = form.text || '';
          try{
            const parsed = JSON.parse(raw);
            const schemaPayload = parsed.schema && parsed.schema.tables ? parsed.schema : parsed;
            const registry = Schema.Registry.fromJSON(schemaPayload);
            const normalizedSchema = registry.toJSON();
            const layout = computeLayout(registry, parsed.layout);
            const targetId = form.targetId || '';
            let existing = null;
            if(targetId){ existing = await SchemaLibrary.get(targetId); }
            const now = Date.now();
            const recordInput = {
              id: targetId || undefined,
              name: form.name || parsed.name || schemaPayload.name || `schema_${now}`,
              title: form.title || parsed.title || form.name || `Ù…Ø®Ø·Ø· ${now}`,
              description: parsed.description || '',
              schema: normalizedSchema,
              layout,
              canvas: parsed.canvas || existing?.canvas || state.data.canvas,
              createdAt: existing?.createdAt,
              updatedAt: now
            };
            const saved = await SchemaLibrary.save(recordInput);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: saved.title || 'Ù…Ø®Ø·Ø· Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙƒØ§Ø©' },
              data:{
                ...s.data,
                schemaId: saved.id,
                schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' },
                schemaCreatedAt: saved.createdAt,
                schemaUpdatedAt: saved.updatedAt,
                schema: normalizedSchema,
                layout,
                selection:{ table:first, field:null },
                canvas: saved.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), import:false },
                form:{
                  ...(s.ui?.form || {}),
                  import:{ name:'', title:'', targetId:'', text:'' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…Ø®Ø·Ø· ÙˆØªØ®Ø²ÙŠÙ†Ù‡', icon:'âœ…' });
          } catch(error){
            console.warn('[Mishkah][ERD] import failed', error);
            UI.pushToast(ctx, { title:'ØªØ¹Ø°Ø± Ø§Ø³ØªÙŠØ±Ø§Ø¯ JSON', message:String(error), icon:'ğŸ›‘' });
          }
        }
      },
      'erd.layout.input':{
        on:['input','change'],
        gkeys:['erd:layout:input'],
        handler:(e,ctx)=>{
          const axis = e.target.getAttribute('data-axis');
          if(!axis) return;
          const value = Number(e.target.value);
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), form:{ ...(s.ui?.form || {}), layout:{ ...(s.ui?.form?.layout || {}), [axis]: Number.isFinite(value) ? value : 0 } } }
          }));
          ctx.rebuild();
        }
      },
      'erd.layout.apply':{
        on:['click'],
        gkeys:['erd:layout:apply'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          if(!selection.table){
            UI.pushToast(ctx, { title:'Ø§Ø®ØªØ± Ø¬Ø¯ÙˆÙ„Ø§Ù‹ Ù„ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹Ù‡', icon:'âš ï¸' });
            return;
          }
          const formLayout = state.ui?.form?.layout || { x:120, y:120 };
          let next;
          ctx.setState(s=>{
            const layout = Object.assign({}, s.data.layout || {});
            layout[selection.table] = { x: Number(formLayout.x) || 0, y: Number(formLayout.y) || 0 };
            const now = Date.now();
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              data:{
                ...s.data,
                layout,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.library.new':{
        on:['click'],
        gkeys:['erd:library:new'],
        handler:async (e,ctx)=>{
          try{
            const record = await SchemaLibrary.createBlank({ title:'Ù…Ø®Ø·Ø· Ø¬Ø¯ÙŠØ¯' });
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'Ù…Ø®Ø·Ø· Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙƒØ§Ø©' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: record.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  table:{ name:'', nameInput:'', label:'', comment:'', includeId:true },
                  field:{ table:first || '', name:'', columnName:'', type:'string', nullable:true, primaryKey:false, unique:false, defaultValue:'', references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' } },
                  relation:{ sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø®Ø·Ø· Ø¬Ø¯ÙŠØ¯', icon:'âœ¨' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create new schema', error);
            UI.pushToast(ctx, { title:'ØªØ¹Ø°Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø®Ø·Ø·', message:String(error), icon:'ğŸ›‘' });
          }
        }
      },
      'erd.library.select':{
        on:['click'],
        gkeys:['erd:library:select'],
        handler:async (e,ctx)=>{
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId || schemaId === state.data.schemaId) return;
          try{
            const record = await SchemaLibrary.get(schemaId);
            if(!record){
              UI.pushToast(ctx, { title:'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø®Ø·Ø·', icon:'ğŸ›‘' });
              return;
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'Ù…Ø®Ø·Ø· Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙƒØ§Ø©' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: record.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
          } catch(error){
            console.warn('[Mishkah][ERD] failed to select schema', error);
            UI.pushToast(ctx, { title:'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø®Ø·Ø·', message:String(error), icon:'ğŸ›‘' });
          }
        }
      },
      'erd.library.delete':{
        on:['click'],
        gkeys:['erd:library:delete'],
        handler:async (e,ctx)=>{
          e.preventDefault();
          e.stopPropagation();
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId) return;
          const count = state.data.library?.items?.length || 0;
          if(count <= 1){
            UI.pushToast(ctx, { title:'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø¢Ø®Ø± Ù…Ø®Ø·Ø·', icon:'âš ï¸' });
            return;
          }
          try{
            await SchemaLibrary.remove(schemaId);
            let list = await SchemaLibrary.list();
            if(!list.length){
              const blank = await SchemaLibrary.createBlank({ title:'Ù…Ø®Ø·Ø· Ø¬Ø¯ÙŠØ¯' });
              list = [blank];
            }
            let record = null;
            if(schemaId === state.data.schemaId){
              record = list[0];
            } else {
              record = await SchemaLibrary.get(state.data.schemaId) || list[0];
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'Ù…Ø®Ø·Ø· Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙƒØ§Ø©' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: record.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø®Ø·Ø·', icon:'ğŸ—‘ï¸' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to delete schema', error);
            UI.pushToast(ctx, { title:'ØªØ¹Ø°Ø± Ø­Ø°Ù Ø§Ù„Ù…Ø®Ø·Ø·', message:String(error), icon:'ğŸ›‘' });
          }
        }
      },
      'erd.schema.meta.open':{
        on:['click'],
        gkeys:['erd:schema:meta:open'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), schemaMeta:true },
              form:{ ...(s.ui?.form || {}), schemaMeta:{ ...(s.data.schemaMeta || {}) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.schema.meta.save':{
        on:['click'],
        gkeys:['erd:schema:meta:save'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const form = s.ui?.form?.schemaMeta || {};
            const now = Date.now();
            const meta = {
              name: (form.name || s.data.schemaMeta?.name || '').trim() || `schema_${s.data.schemaId?.slice(-4) || 'new'}`,
              title: (form.title || form.name || s.data.schemaMeta?.title || '').trim() || 'Ù…Ø®Ø·Ø· Ø¬Ø¯ÙŠØ¯',
              description: (form.description || '').trim()
            };
            const record = {
              id: s.data.schemaId,
              name: meta.name,
              title: meta.title,
              description: meta.description,
              schema: s.data.schema,
              layout: s.data.layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              head:{ ...(s.head || {}), title: meta.title || 'Ù…Ø®Ø·Ø· Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙƒØ§Ø©' },
              data:{
                ...s.data,
                schemaMeta: meta,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), schemaMeta:false },
                form:{ ...(s.ui?.form || {}), schemaMeta: meta }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      }
    };

    const app = M.app.createApp(erdState, {});
    const auto = U.twcss.auto(erdState, app, { pageScaffold:true });

    M.app.setBody(AppView);

    app.setOrders(Object.assign({}, UI.orders, auto.orders, erdOrders));
    app.mount('#app');
  })();
  </script>
</body>
</html>
