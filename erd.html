<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>ŸÖÿÆÿ∑ÿ∑ ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ¥ŸÉÿßÿ©</title>
  <style>
    :root {
      color-scheme: light dark;
      --background: #f8fafc;
      --surface-0: #f8fafc;
      --surface-1: #ffffff;
      --surface-2: #eef2ff;
      --card: #ffffff;
      --card-foreground: #0f172a;
      --foreground: #0f172a;
      --muted: #475569;
      --muted-foreground: #475569;
      --border: #cfd8ea;
      --input: #dbe3f8;
      --accent: #eaf2ff;
      --accent-foreground: #102341;
      --primary: #2563eb;
      --primary-foreground: #f8fafc;
      --secondary: #d8e1ff;
      --secondary-foreground: #102341;
      --destructive: #ef4444;
      --destructive-foreground: #ffffff;
      --ring: #2563eb;
      --shadow: 0 28px 60px -28px rgba(15, 23, 42, 0.35);
      --radius: 16px;
    }
    :root.dark {
      color-scheme: dark;
      --background: #0b1220;
      --surface-0: #0b1220;
      --surface-1: #101a2c;
      --surface-2: #16243a;
      --card: #111d30;
      --card-foreground: #e2e8f0;
      --foreground: #f8fafc;
      --muted: #94a3b8;
      --muted-foreground: #94a3b8;
      --border: #1f2a3d;
      --input: #223044;
      --accent: #1e2a3f;
      --accent-foreground: #e2e8f0;
      --primary: #60a5fa;
      --primary-foreground: #0b1220;
      --secondary: #27364e;
      --secondary-foreground: #e2e8f0;
      --destructive: #f87171;
      --destructive-foreground: #0b1220;
      --ring: #60a5fa;
      --shadow: 0 30px 70px -36px rgba(8, 15, 30, 0.75);
      --radius: 16px;
    }
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      height: 100%;
      min-height: 100vh;
      margin: 0;
      background: var(--background, #0f1115);
      color: var(--foreground, #f8fafc);
      font-family: "Tajawal", "Cairo", system-ui, sans-serif;
      transition: background-color 160ms ease, color 160ms ease;
    }
    body { display: flex; min-height: 100vh; }
    #app { flex: 1 1 auto; display: flex; }
    textarea[readonly] { user-select: all; }
  </style>
  <script src="https://unpkg.com/gojs@2.3.14/release/go.js"></script>
  <script src="./mishkah-utils.js"></script>
  <script src="./mishkah.core.js"></script>
  <script src="./mishkah-ui.js"></script>
  <script src="./mishkah-schema.js"></script>
</head>
<body>
  <div id="app"></div>
  <script>
  (async function(){
    const M = Mishkah;
    const UI = M.UI;
    const U = M.utils;
    const D = M.DSL;
    const Schema = M.schema;
    const { tw } = U.twcss;
    const Text = U.Text || {};

    let erdAppInstance = null;
    let goDiagram = null;
    let goMaker = null;
    let pendingDiagramFrame = false;
    let lastDiagramState = null;

    const TABLE_WIDTH = 280;
    const HEADER_HEIGHT = 48;
    const ROW_HEIGHT = 28;

    const DEFAULT_FIELD_TYPES = [
      'string','integer','decimal','float','boolean','timestamp','date','json','uuid','text'
    ];

    const RELATION_ACTION_OPTIONS = ['CASCADE','RESTRICT','SET NULL','NO ACTION'];

    const clone = (U.JSON && U.JSON.clone) ? U.JSON.clone : (obj => JSON.parse(JSON.stringify(obj)));

    function identifierFromLabel(label, fallback){
      if(Text && typeof Text.identifierFromArabic === 'function'){
        return Text.identifierFromArabic(label, { fallback });
      }
      const base = Schema.utils.toSnakeCase(label || '') || '';
      if(base) return base;
      return Schema.utils.toSnakeCase(fallback || 'item') || (fallback || 'item');
    }

    function formatIdentifier(value){
      if(!value) return '';
      return value
        .replace(/_/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/(^|\s)([a-z])/g, (_, space, ch)=> space + ch.toUpperCase());
    }

    function ensureUniqueTableName(registry, base){
      const clean = base || 'table';
      let candidate = clean;
      let index = 1;
      while(registry.get(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function ensureUniqueFieldName(table, base){
      const clean = base || 'field';
      if(!table) return clean;
      let candidate = clean;
      let index = 1;
      while(table.getField(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function computeTableIdentifier(registry, label){
      const fallback = `table_${registry.list().length + 1}`;
      const base = identifierFromLabel(label, fallback);
      return ensureUniqueTableName(registry, base);
    }

    function computeFieldIdentifier(table, label){
      const fallback = `field_${(table?.fields?.length || 0) + 1}`;
      const base = identifierFromLabel(label, fallback);
      return ensureUniqueFieldName(table, base);
    }

    function currentPalette(){
      if(typeof window === 'undefined') return {};
      const computed = getComputedStyle(document.documentElement);
      const read = key => (computed.getPropertyValue(key) || '').trim();
      return {
        background: read('--background') || '#f8fafc',
        surface: read('--surface-2') || '#eef2ff',
        border: read('--border') || '#d7deed',
        foreground: read('--foreground') || '#0f172a',
        muted: read('--muted-foreground') || '#475569',
        accent: read('--accent') || '#eaf2ff',
        accentForeground: read('--accent-foreground') || '#102341',
        primary: read('--primary') || '#2563eb',
        primaryForeground: read('--primary-foreground') || '#f8fafc'
      };
    }

    function buildDiagramData(state){
      const registry = getRegistry(state);
      const layout = state.data.layout || {};
      const selection = state.data.selection || {};
      const tables = registry.list();
      const nodes = tables.map(table => {
        const pos = layout[table.name] || table.layout || { x: 120, y: 120 };
        return {
          key: table.name,
          title: formatIdentifier(table.name),
          arabicLabel: table.label || '',
          loc: `${pos.x} ${pos.y}`,
          selected: selection.table === table.name,
          items: (table.fields || []).map(field => ({
            name: field.name,
            display: formatIdentifier(field.name),
            type: field.type,
            isPrimary: !!field.primaryKey,
            isForeign: !!field.references,
            nullable: field.nullable !== false,
            selected: selection.table === table.name && selection.field === field.name,
            references: field.references || null
          }))
        };
      });
      const links = [];
      tables.forEach(table => {
        (table.fields || []).forEach(field => {
          if(field.references && field.references.table){
            links.push({
              from: table.name,
              to: field.references.table,
              fromField: field.name,
              toField: field.references.column || field.references.field || 'id',
              fromLabel: formatIdentifier(field.name),
              toLabel: formatIdentifier(field.references.column || field.references.field || 'id')
            });
          }
        });
      });
      return { nodes, links };
    }

    function scheduleDiagramRender(state){
      lastDiagramState = state;
      if(pendingDiagramFrame) return;
      pendingDiagramFrame = true;
      requestAnimationFrame(()=>{
        pendingDiagramFrame = false;
        const snapshot = erdAppInstance ? erdAppInstance.getState() : lastDiagramState;
        if(snapshot) renderDiagram(snapshot);
      });
    }

    function applyDiagramTemplates(diagram, palette){
      if(!goMaker) return;
      const signature = JSON.stringify(palette);
      if(diagram.__paletteSignature === signature) return;
      diagram.__paletteSignature = signature;
      const $ = goMaker;
      const foreground = palette.foreground || '#0f172a';
      const muted = palette.muted || '#475569';
      const border = palette.border || '#d7deed';
      const surface = palette.surface || '#ffffff';
      const accent = palette.accent || '#e2e8f0';
      const accentFg = palette.accentForeground || foreground;
      const primary = palette.primary || '#2563eb';
      const primaryFg = palette.primaryForeground || '#f8fafc';

      const itemTemplate = $(go.Panel, 'TableRow',
        {
          column: 0,
          stretch: go.GraphObject.Horizontal,
          cursor: 'pointer',
          fromSpot: go.Spot.LeftRightSides,
          toSpot: go.Spot.LeftRightSides
        },
        new go.Binding('portId', 'name'),
        new go.Binding('background', 'selected', sel => sel ? accent : null),
        {
          mouseEnter: (e, row)=>{ if(!row.data?.selected) row.background = accent; },
          mouseLeave: (e, row)=>{ if(!row.data?.selected) row.background = null; },
          click: (e, row)=>{
            const field = row.data;
            const tableKey = row.part?.data?.key;
            if(field && tableKey && erdAppInstance){
              erdAppInstance.setState(s => withFieldSelection(s, tableKey, field.name));
              erdAppInstance.rebuild();
            }
          }
        },
        $(go.Shape, 'Circle', {
          column: 0,
          width: 7,
          height: 7,
          margin: new go.Margin(0, 6, 0, 4),
          strokeWidth: 1.2,
          fill: border,
          stroke: border
        },
          new go.Binding('fill', 'isPrimary', isPrimary => isPrimary ? primary : border),
          new go.Binding('stroke', 'isForeign', isForeign => isForeign ? primary : border),
          new go.Binding('strokeWidth', 'isForeign', isForeign => isForeign ? 1.6 : 1.2)
        ),
        $(go.TextBlock, {
          column: 1,
          alignment: go.Spot.Left,
          margin: new go.Margin(2, 6, 2, 0),
          font: '600 12px Tajawal, sans-serif',
          stroke: foreground,
          maxLines: 1
        }, new go.Binding('text', 'display')),
        $(go.TextBlock, {
          column: 2,
          alignment: go.Spot.Right,
          margin: new go.Margin(2, 0, 2, 0),
          font: '11px Tajawal, sans-serif',
          stroke: muted,
          maxLines: 1
        }, new go.Binding('text', 'type'))
      );

      diagram.nodeTemplate = $(go.Node, 'Auto',
        {
          selectionAdorned: false,
          resizable: false,
          cursor: 'move',
          fromSpot: go.Spot.AllSides,
          toSpot: go.Spot.AllSides,
          click:(e,node)=>{
            const key = node?.data?.key;
            if(key && erdAppInstance){
              erdAppInstance.setState(s => withTableSelection(s, key));
              erdAppInstance.rebuild();
            }
          }
        },
        new go.Binding('location', 'loc', go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, 'RoundedRectangle', {
          fill: surface,
          stroke: border,
          strokeWidth: 1.4,
          name: 'CARD',
          portId: '',
          fromSpot: go.Spot.AllSides,
          toSpot: go.Spot.AllSides
        },
          new go.Binding('stroke', 'selected', sel => sel ? primary : border),
          new go.Binding('strokeWidth', 'selected', sel => sel ? 2 : 1.4)
        ),
        $(go.Panel, 'Table',
          { stretch: go.GraphObject.Fill, defaultRowSeparatorStroke: border },
          $(go.RowColumnDefinition, { row: 0, sizing: go.RowColumnDefinition.None }),
          $(go.TextBlock, {
            row: 0,
            margin: new go.Margin(6, 36, 4, 10),
            font: '600 14px Tajawal, sans-serif',
            stroke: foreground,
            maxLines: 1
          }, new go.Binding('text', 'title')),
          $('PanelExpanderButton', 'FIELD_LIST', { row: 0, alignment: go.Spot.TopRight, margin: new go.Margin(4, 6, 0, 0) }),
          $(go.Panel, 'Vertical', {
            name: 'FIELD_LIST',
            row: 1,
            stretch: go.GraphObject.Horizontal,
            defaultAlignment: go.Spot.Left,
            itemTemplate,
            padding: new go.Margin(4, 0, 6, 0)
          }, new go.Binding('itemArray', 'items'))
        ),
        new go.Binding('toolTip', '', data => {
          if(!data.arabicLabel) return null;
          return $(go.Adornment, 'Auto',
            $(go.Shape, { fill: accent, stroke: border }),
            $(go.TextBlock, { margin: 6, font: '12px Tajawal, sans-serif', stroke: accentFg }, data.arabicLabel)
          );
        })
      );

      diagram.linkTemplate = $(go.Link,
        {
          routing: go.Link.AvoidsNodes,
          corner: 8,
          curve: go.Link.JumpOver,
          relinkableFrom: false,
          relinkableTo: false
        },
        $(go.Shape, { stroke: primary, strokeWidth: 1.6 }),
        $(go.Shape, { toArrow: 'Standard', stroke: null, fill: primary }),
        $(go.TextBlock, {
          segmentIndex: 0,
          segmentOffset: new go.Point(0, -10),
          font: '11px Tajawal, sans-serif',
          stroke: muted
        }, new go.Binding('text', 'fromLabel')),
        $(go.TextBlock, {
          segmentIndex: -1,
          segmentOffset: new go.Point(0, 10),
          font: '11px Tajawal, sans-serif',
          stroke: muted
        }, new go.Binding('text', 'toLabel'))
      );

      diagram.model = $(go.GraphLinksModel, {
        copiesArrays: true,
        copiesArrayObjects: true,
        linkFromPortIdProperty: 'fromField',
        linkToPortIdProperty: 'toField'
      });
    }

    function persistDiagramLayout(diagram){
      if(!erdAppInstance) return;
      const moved = diagram.selection;
      const updates = {};
      moved.each(part => {
        if(part instanceof go.Node){
          const loc = part.location;
          updates[part.data.key] = { x: Math.round(loc.x), y: Math.round(loc.y) };
        }
      });
      if(!Object.keys(updates).length) return;
      let record = null;
      erdAppInstance.setState(s => {
        const layout = Object.assign({}, s.data.layout || {});
        let changed = false;
        for(const [key, pos] of Object.entries(updates)){
          if(!pos) continue;
          const current = layout[key] || {};
          if(current.x !== pos.x || current.y !== pos.y){
            layout[key] = { x: pos.x, y: pos.y };
            changed = true;
          }
        }
        if(!changed) return s;
        const now = Date.now();
        const recordInput = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: s.data.schema,
          layout,
          canvas: s.data.canvas,
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now
        };
        record = recordInput;
        return {
          ...s,
          data:{
            ...s.data,
            layout,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], recordInput) }
          }
        };
      });
      if(record){
        erdAppInstance.rebuild();
        schedulePersist(recordFromState(erdAppInstance.getState()));
      }
    }

    function renderDiagram(state){
      if(!state || typeof window === 'undefined' || !window.go) return;
      const host = document.getElementById('erd-diagram');
      if(!host) return;
      if(!goMaker) goMaker = go.GraphObject.make;
      if(!goDiagram){
        goDiagram = goMaker(go.Diagram, host, {
          'undoManager.isEnabled': false,
          allowCopy: false,
          allowDelete: false,
          allowMove: true,
          padding: 32,
          contentAlignment: go.Spot.Center,
          layout: goMaker(go.ForceDirectedLayout, { defaultSpringLength: 180, defaultElectricalCharge: 180 })
        });
        goDiagram.toolManager.mouseWheelBehavior = go.ToolManager.WheelZoom;
        goDiagram.addDiagramListener('SelectionMoved', e => persistDiagramLayout(e.diagram));
      }
      const palette = currentPalette();
      applyDiagramTemplates(goDiagram, palette);
      const data = buildDiagramData(state);
      goDiagram.model.nodeDataArray = data.nodes;
      goDiagram.model.linkDataArray = data.links;
      goDiagram.background = palette.background || '#f8fafc';
      const zoom = state.data.canvas?.zoom || 1;
      goDiagram.scale = zoom;
      if(state.data.selection?.table){
        const node = goDiagram.findNodeForKey(state.data.selection.table);
        if(node) goDiagram.select(node);
      }
    }

    const SchemaLibrary = (function(){
      const storeName = 'schemas';
      const AdapterClass = (U && (U.IndexedDBX || U.IndexedDB)) || null;
      const hasIndexedDB = typeof indexedDB !== 'undefined' && !!AdapterClass;
      const adapter = hasIndexedDB ? new AdapterClass({
        name:'mishkah-erd',
        version:1,
        schema:{
          stores:{
            [storeName]:{
              keyPath:'id',
              autoIncrement:false,
              indexes:{
                by_name:{ keyPath:'name', unique:true },
                by_updatedAt:{ keyPath:'updatedAt' },
                by_createdAt:{ keyPath:'createdAt' }
              }
            }
          }
        }
      }) : null;
      const memory = new Map();
      const status = hasIndexedDB ? 'indexeddb' : 'memory';

      function normalize(input, { bumpUpdatedAt=true }={}){
        const now = Date.now();
        const id = input.id || U.Id.uid('schema');
        const name = (input.name || '').trim() || `schema_${id.slice(-4)}`;
        const title = (input.title || '').trim() || name;
        const description = (input.description || '').trim();
        const schema = clone(input.schema || { tables: [] });
        const layout = clone(input.layout || {});
        const canvas = clone(input.canvas || { zoom:1 });
        const createdAt = input.createdAt || now;
        const updatedAt = bumpUpdatedAt ? now : (input.updatedAt || now);
        return { id, name, title, description, schema, layout, canvas, createdAt, updatedAt };
      }

      async function ready(){
        if(adapter && adapter.ensureSchema){
          try { await adapter.ensureSchema(); }
          catch(error){ console.warn('[Mishkah][ERD] failed to ensure schema store', error); }
        }
        return true;
      }

      async function save(input, opts={}){
        const record = normalize(input, opts);
        if(adapter){
          try { await adapter.put(storeName, record); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB save failed', error); }
        }
        memory.set(record.id, clone(record));
        return clone(record);
      }

      async function get(id){
        if(!id) return null;
        if(adapter){
          try {
            const row = await adapter.get(storeName, id);
            if(row){
              memory.set(row.id, clone(row));
              return clone(row);
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB get failed', error);
          }
        }
        const existing = memory.get(id);
        return existing ? clone(existing) : null;
      }

      async function list(){
        if(adapter){
          try {
            const rows = await adapter.getAll(storeName);
            if(Array.isArray(rows)){
              rows.forEach(row => memory.set(row.id, clone(row)));
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB list failed', error);
          }
        }
        const out = Array.from(memory.values()).map(item => clone(item));
        out.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
        return out;
      }

      async function remove(id){
        if(!id) return false;
        if(adapter){
          try { await adapter.delete(storeName, id); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB delete failed', error); }
        }
        memory.delete(id);
        return true;
      }

      async function createBlank(meta={}){
        return save({
          id: meta.id,
          name: meta.name || '',
          title: meta.title || meta.name || 'ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸäÿØ',
          description: meta.description || '',
          schema: new Schema.Registry().toJSON(),
          layout:{},
          canvas:{ zoom:1 },
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
      }

      return { status, available:true, ready, save, get, list, remove, createBlank };
    })();

    await SchemaLibrary.ready();

    let libraryItems = await SchemaLibrary.list();
    if(!libraryItems.length){
      const blankRecord = await SchemaLibrary.createBlank({ title:'ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸäÿØ' });
      libraryItems = [blankRecord];
    }

    const activeRecord = libraryItems[0];
    const activeRegistry = Schema.Registry.fromJSON(activeRecord.schema || { tables: [] });

    function computeLayout(registry, layout){
      const map = Object.assign({}, layout || {});
      registry.list().forEach((table, index)=>{
        if(!map[table.name]){
          map[table.name] = table.layout || { x: 160 + index * 160, y: 120 + index * 80 };
        }
      });
      return map;
    }

    const initialLayout = computeLayout(activeRegistry, activeRecord.layout);
    const firstTable = activeRegistry.list()[0]?.name || null;
    const initialLayoutPoint = firstTable ? (initialLayout[firstTable] || { x:120, y:120 }) : { x:120, y:120 };

    const erdState = {
      head:{ title: activeRecord.title || 'ŸÖÿÆÿ∑ÿ∑ ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ¥ŸÉÿßÿ©' },
      env:{ theme:'dark', lang:'ar', dir:'rtl' },
      data:{
        schemaId: activeRecord.id,
        schemaMeta:{
          name: activeRecord.name,
          title: activeRecord.title,
          description: activeRecord.description || ''
        },
        schemaCreatedAt: activeRecord.createdAt,
        schemaUpdatedAt: activeRecord.updatedAt,
        schema: activeRegistry.toJSON(),
        layout: initialLayout,
        selection:{ table:firstTable, field:null },
        canvas: activeRecord.canvas || { zoom:1 },
        sqlPreview:'',
        error:null,
        library:{ items: libraryItems, status: SchemaLibrary.status }
      },
      ui:{
        modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false },
        form:{
          table:{ name:'', label:'', comment:'', includeId:true },
          field:{
            table:firstTable || '',
            name:'',
            columnName:'',
            type:'string',
            nullable:true,
            primaryKey:false,
            unique:false,
            defaultValue:'',
            references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
          },
          relation:{
            sourceTable:firstTable || '',
            sourceField:'',
            targetTable:'',
            targetField:'',
            onDelete:'CASCADE',
            onUpdate:'CASCADE'
          },
          import:{ name: activeRecord.name || '', title: activeRecord.title || '', targetId: activeRecord.id || '', text:'' },
          export:{ text:'' },
          sql:{ text:'' },
          layout:{ x: initialLayoutPoint.x, y: initialLayoutPoint.y },
          schemaMeta:{
            name: activeRecord.name || '',
            title: activeRecord.title || '',
            description: activeRecord.description || ''
          }
        }
      }
    };

    function getRegistry(db){
      try {
        return Schema.Registry.fromJSON(db.data.schema);
      } catch(error){
        console.warn('[Mishkah][ERD] schema parse failed', error);
        return new Schema.Registry();
      }
    }

    function ensureLayout(db, tableName){
      const layout = Object.assign({}, db.data.layout || {});
      if(!layout[tableName]) layout[tableName] = { x: 120, y: 120 };
      return layout;
    }

    function withTableSelection(state, tableName){
      if(!tableName) return state;
      const layout = ensureLayout({ data:{ layout: state.data.layout } }, tableName);
      const tablePos = layout[tableName] || { x: 120, y: 120 };
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field:null }, layout },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            field:{ ...(state.ui?.form?.field || {}), table: tableName },
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName },
            layout:{ x: tablePos.x, y: tablePos.y }
          }
        }
      };
    }

    function withFieldSelection(state, tableName, fieldName){
      if(!tableName || !fieldName) return state;
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field: fieldName } },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName, sourceField: fieldName }
          }
        }
      };
    }

    function mergeLibraryItems(list, record){
      const items = Array.isArray(list) ? list.slice() : [];
      const entry = clone(record);
      const idx = items.findIndex(item => item.id === record.id);
      if(idx >= 0) items[idx] = entry; else items.push(entry);
      items.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
      return items;
    }

    const schedulePersist = (function(){
      if(!SchemaLibrary.available) return ()=>{};
      const debounced = U.Control.debounce(async (record)=>{
        try{
          await SchemaLibrary.save(record, { bumpUpdatedAt:false });
        } catch(error){
          console.warn('[Mishkah][ERD] persist failed', error);
        }
      }, 600);
      return record => debounced(clone(record));
    })();

    function recordFromState(state){
      const meta = state.data.schemaMeta || {};
      return {
        id: state.data.schemaId,
        name: meta.name || '',
        title: meta.title || '',
        description: meta.description || '',
        schema: state.data.schema,
        layout: state.data.layout,
        canvas: state.data.canvas,
        createdAt: state.data.schemaCreatedAt,
        updatedAt: state.data.schemaUpdatedAt
      };
    }

    function SchemaLibraryPanel(db){
      const library = db.data.library || {};
      const items = library.items || [];
      const activeId = db.data.schemaId;
      const listContent = items.length
        ? D.Lists.Ul({ attrs:{ class: tw`flex flex-col gap-2 list-none m-0 p-0` } },
            items.map(item=> D.Lists.Li({ attrs:{ class: tw`rounded-xl border border-[var(--border)]/60 bg-[var(--surface-1)]/70 px-3 py-2 transition ${item.id === activeId ? 'ring-2 ring-[var(--primary)]/60' : 'hover:border-[var(--primary)]/50'}`, gkey:'erd:library:select', 'data-schema-id': item.id } }, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2` }}, [
                D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-0.5` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [item.title || item.name]),
                  D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [item.name])
                ]),
                D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-[10px] text-[var(--muted)]` }}, [U.Time.fmt(item.updatedAt || item.createdAt || Date.now())]),
                  UI.Button({ attrs:{ gkey:'erd:library:delete', 'data-schema-id': item.id, title:'ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿÆÿ∑ÿ∑', class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, ['üóëÔ∏è'])
                ])
              ])
            ])))
        : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['ŸÑŸÖ Ÿäÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿ£Ÿä ŸÖÿÆÿ∑ÿ∑ÿßÿ™ ÿ®ÿπÿØ.']);
      return D.Containers.Aside({ attrs:{ class: tw`hidden lg:flex w-72 flex-col border-l border-[var(--border)] bg-[var(--surface-2)]/70 backdrop-blur` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between px-4 py-3 border-b border-[var(--border)]` }}, [
          D.Text.Span({ attrs:{ class: tw`text-base font-semibold` }}, ['ŸÖŸÉÿ™ÿ®ÿ© ÿßŸÑŸÖÿÆÿ∑ÿ∑ÿßÿ™']),
          D.Text.Span({ attrs:{ class: tw`text-[10px] uppercase tracking-wide text-[var(--muted)]` }}, [library.status === 'indexeddb' ? 'IndexedDB' : 'ÿ∞ÿßŸÉÿ±ÿ© ŸÖÿ§ŸÇÿ™ÿ©'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`px-4 py-3 flex flex-col gap-2` }}, [
          UI.Button({ attrs:{ gkey:'erd:library:new' }, variant:'solid', size:'sm' }, ['‚ûï ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸäÿØ']),
          UI.Button({ attrs:{ gkey:'erd:import:open' }, variant:'ghost', size:'sm' }, ['‚¨ÜÔ∏è ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ JSON'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`flex-1 overflow-y-auto px-3 pb-4` }}, [listContent])
      ]);
    }

    function SchemaCanvas(db){
      const registry = getRegistry(db);
      const tables = registry.list();
      scheduleDiagramRender(db);
      const hasTables = tables.length > 0;
      const emptyState = !hasTables
        ? D.Containers.Div({ attrs:{ class: tw`absolute inset-0 flex items-center justify-center pointer-events-none` }}, [
            D.Containers.Div({ attrs:{ class: tw`rounded-3xl border border-dashed border-[var(--border)] bg-[var(--surface-2)]/70 px-6 py-5 text-center text-sm text-[var(--muted)] max-w-md` }}, ['ÿ£ÿ∂ŸÅ ÿ¨ÿØŸàŸÑŸãÿß ÿ¨ÿØŸäÿØŸãÿß ŸÑÿ®ÿØÿ° ÿ®ŸÜÿßÿ° ÿßŸÑŸÖÿÆÿ∑ÿ∑.'])
          ])
        : null;
      return D.Containers.Div({ attrs:{ class: tw`relative flex-1 bg-[var(--surface-1)]` }}, [
        D.Containers.Div({ attrs:{ id:'erd-diagram', class: tw`absolute inset-0` }}, []),
        emptyState
      ].filter(Boolean));
    }

    function Toolbar(db){
      const zoom = db.data.canvas?.zoom || 1;
      const metaTitle = db.data.schemaMeta?.title || 'ŸÖÿÆÿ∑ÿ∑ ÿ®ÿØŸàŸÜ ÿßÿ≥ŸÖ';
      const schemaIdentifier = db.data.schemaMeta?.name ? formatIdentifier(db.data.schemaMeta.name) : '';
      const lang = db.env?.lang || db.i18n?.lang || 'ar';
      const theme = db.env?.theme || 'dark';
      return UI.Toolbar({
        left:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col` }}, [
            D.Text.Span({ attrs:{ class: tw`text-xl font-bold` }}, [metaTitle]),
            schemaIdentifier ? D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [schemaIdentifier]) : null
          ].filter(Boolean)),
          UI.Button({ attrs:{ gkey:'erd:schema:meta:open' }, variant:'ghost', size:'sm' }, ['‚úèÔ∏è ÿÆÿµÿßÿ¶ÿµ ÿßŸÑŸÖÿÆÿ∑ÿ∑']),
          UI.Button({ attrs:{ gkey:'erd:table:add' }, variant:'ghost', size:'sm' }, ['‚ûï ÿ¨ÿØŸàŸÑ']),
          UI.Button({ attrs:{ gkey:'erd:field:add' }, variant:'ghost', size:'sm' }, ['‚ûï ÿ≠ŸÇŸÑ']),
          UI.Button({ attrs:{ gkey:'erd:relation:add' }, variant:'ghost', size:'sm' }, ['üîó ÿπŸÑÿßŸÇÿ©'])
        ],
        right:[
          UI.LanguageSwitch({ lang }),
          UI.ThemeToggleIcon({ theme }),
          UI.Button({ attrs:{ gkey:'erd:export:json' }, variant:'ghost', size:'sm' }, ['‚¨áÔ∏è ÿ™ÿµÿØŸäÿ± JSON']),
          UI.Button({ attrs:{ gkey:'erd:export:sql' }, variant:'ghost', size:'sm' }, ['üßæ SQL']),
          UI.Button({ attrs:{ gkey:'erd:zoom:out', title:'ÿ™ÿµÿ∫Ÿäÿ±' }, variant:'ghost', size:'sm' }, ['‚ûñ']),
          D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, [`${Math.round(zoom * 100)}%`]),
          UI.Button({ attrs:{ gkey:'erd:zoom:reset', title:'ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ≠ÿ¨ŸÖ' }, variant:'ghost', size:'sm' }, ['‚ü≥']),
          UI.Button({ attrs:{ gkey:'erd:zoom:in', title:'ÿ™ŸÉÿ®Ÿäÿ±' }, variant:'ghost', size:'sm' }, ['‚ûï'])
        ]
      });
    }

    function InspectorPanel(db){
      const selection = db.data.selection || {};
      const registry = getRegistry(db);
      const table = selection.table ? registry.get(selection.table) : null;
      const layout = db.data.layout || {};
      const formLayout = db.ui?.form?.layout || { x:0, y:0 };
      const relationships = table ? (table.fields || []).filter(field=> field.references) : [];
      return D.Containers.Aside({ attrs:{ class: tw`hidden xl:flex w-80 flex-col border-r border-[var(--border)] bg-[var(--surface-2)]/90 backdrop-blur p-4 gap-4` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
          D.Text.H3({ attrs:{ class: tw`text-lg font-semibold` }}, ['ÿÆÿµÿßÿ¶ÿµ ÿßŸÑŸÖÿÆÿ∑ÿ∑']),
          UI.Button({ attrs:{ gkey:'erd:schema:meta:open', class: tw`justify-center` }, variant:'secondary', size:'sm' }, ['ÿ™ÿ≠ÿ±Ÿäÿ± ÿßŸÑÿßÿ≥ŸÖ ŸàÿßŸÑŸàÿµŸÅ'])
        ]),
        D.Text.H3({ attrs:{ class: tw`text-lg font-semibold` }}, ['ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ']),
        table ? D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
          D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [`${table.sqlName || Schema.utils.toSnakeCase(table.name)}`]),
          D.Text.Span({ attrs:{ class: tw`text-sm` }}, [`ÿπÿØÿØ ÿßŸÑÿ≠ŸÇŸàŸÑ: ${table.fields.length}`]),
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['ÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ÿßŸÑŸÑŸàÿ≠ÿ©']),
            UI.Input({ attrs:{ gkey:'erd:layout:input', 'data-axis':'x', value:String(formLayout.x), type:'number', class: tw`w-full`, placeholder:'ÿßŸÑŸÖÿ≠Ÿàÿ± X' } }),
            UI.Input({ attrs:{ gkey:'erd:layout:input', 'data-axis':'y', value:String(formLayout.y), type:'number', class: tw`w-full`, placeholder:'ÿßŸÑŸÖÿ≠Ÿàÿ± Y' } }),
            UI.Button({ attrs:{ gkey:'erd:layout:apply', variant:'solid', size:'sm' }}, ['ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸàŸÇÿπ'])
          ]),
          relationships.length ? D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-1` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['ÿßŸÑÿπŸÑÿßŸÇÿßÿ™ ÿßŸÑÿÆÿßÿ±ÿ¨ÿ©']),
            ...relationships.map(field=> D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [`${field.name} ‚Üí ${field.references.table}.${field.references.column}`]))
          ]) : D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, ['ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿπŸÑÿßŸÇÿßÿ™ ŸÖÿ≠ÿØÿØÿ©.'])
        ]) : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['ÿßÿÆÿ™ÿ± ÿ¨ÿØŸàŸÑŸãÿß ŸÖŸÜ ÿßŸÑŸÖÿÆÿ∑ÿ∑ ŸÑÿßÿ≥ÿ™ÿπÿ±ÿßÿ∂ ÿ™ŸÅÿßÿµŸäŸÑŸá.'])
      ]);
    }

    function ModalImport(db){
      const open = db.ui?.modals?.import;
      const form = db.ui?.form?.import || { name:'', title:'', targetId:'', text:'' };
      const library = db.data.library || {};
      const items = library.items || [];
      return UI.Modal({
        open,
        size:'lg',
        title:'ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ŸÖÿÆÿ∑ÿ∑ JSON',
        description:'ÿ£ŸÑÿµŸÇ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿÆÿ∑ÿ∑ ÿ£Ÿà ÿßÿ≥ÿ™ÿ®ÿØŸÑ ŸÖÿÆÿ∑ÿ∑Ÿãÿß ŸÖŸàÿ¨ŸàÿØŸãÿß.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'name', value: form.name || '', placeholder:'ÿßŸÑŸÖÿπÿ±ŸÅ ÿßŸÑŸÅÿ±ŸäÿØ ŸÑŸÑŸÖÿÆÿ∑ÿ∑ (name)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'title', value: form.title || '', placeholder:'ÿßŸÑÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿπÿ±Ÿàÿ∂' } }),
            UI.Select({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'targetId', value: form.targetId || '' }, options:[
              { value:'', label:'ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸäÿØ' },
              ...items.map(item=> ({ value:item.id, label:`ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ: ${item.title || item.name}` }))
            ] }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'text', value: form.text || '', rows:12, class: tw`w-full font-mono text-xs`, placeholder:'{"schema":{...}}' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:import:apply', variant:'solid', size:'sm' }}, ['ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ Ÿàÿ™ÿÆÿ≤ŸäŸÜ']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['ÿ•ÿ∫ŸÑÿßŸÇ'])
        ]
      });
    }

    function ModalExportJson(db){
      const open = db.ui?.modals?.exportJson;
      const text = db.ui?.form?.export?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'ŸÖÿÆÿ∑ÿ∑ JSON',
        description:'ÿßŸÜÿ≥ÿÆ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÅŸä ÿ£ŸÖÿßŸÉŸÜ ÿ£ÿÆÿ±Ÿâ.',
        closeGkey:'erd:modal:close',
        content:[
          UI.Textarea({ attrs:{ readonly:true, value: text, rows:14, class: tw`w-full font-mono text-xs` } })
        ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['ÿ™ŸÖ']) ]
      });
    }

    function ModalExportSql(db){
      const open = db.ui?.modals?.exportSql;
      const text = db.ui?.form?.sql?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'ŸÜÿµ SQL',
        description:'Ÿáÿ∞ÿß ÿßŸÑŸÜÿµ ŸäŸÖÿ´ŸÑ ÿ£ŸàÿßŸÖÿ± ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ÿØÿßŸàŸÑ PostgreSQL.',
        closeGkey:'erd:modal:close',
        content:[ UI.Textarea({ attrs:{ readonly:true, value: text, rows:16, class: tw`w-full font-mono text-xs` } }) ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['ÿ™ŸÖ']) ]
      });
    }

    function ModalSchemaMeta(db){
      const open = db.ui?.modals?.schemaMeta;
      const form = db.ui?.form?.schemaMeta || { name:'', title:'', description:'' };
      return UI.Modal({
        open,
        size:'md',
        title:'ÿÆÿµÿßÿ¶ÿµ ÿßŸÑŸÖÿÆÿ∑ÿ∑',
        description:'ŸÇŸÖ ÿ®ÿ™ÿ≠ÿØŸäÿ´ ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿπÿ±ŸäŸÅ ŸàÿßŸÑÿπŸÜŸàÿßŸÜ ŸàÿßŸÑŸàÿµŸÅ.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'name', value: form.name || '', placeholder:'Name (snake_case)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'title', value: form.title || '', placeholder:'Title' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'description', value: form.description || '', rows:4, placeholder:'ŸàÿµŸÅ ŸÖÿÆÿ™ÿµÿ± ŸÑŸÑŸÖÿÆÿ∑ÿ∑' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:schema:meta:save', variant:'solid', size:'sm' }}, ['ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ÿπÿØŸäŸÑÿßÿ™']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['ÿ•ŸÑÿ∫ÿßÿ°'])
        ]
      });
    }

    function ModalAddTable(db){
      const open = db.ui?.modals?.table;
      const form = db.ui?.form?.table || { name:'', label:'', comment:'', includeId:true };
      const registry = getRegistry(db);
      const previewName = form.name || (form.label ? computeTableIdentifier(registry, form.label) : '');
      return UI.Modal({
        open,
        size:'md',
        title:'ÿ•ŸÜÿ¥ÿßÿ° ÿ¨ÿØŸàŸÑ ÿ¨ÿØŸäÿØ',
        description:'ÿßŸÉÿ™ÿ® ÿßŸÑŸÖÿ≥ŸÖŸâ ÿßŸÑÿπÿ±ÿ®Ÿä Ÿàÿ≥Ÿäÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÖÿπÿ±ŸÅ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'label', value: form.label || '', placeholder:'ÿßŸÑŸÖÿ≥ŸÖŸâ ÿßŸÑÿπÿ±ÿ®Ÿä (ŸÖÿ´ÿßŸÑ: ÿßŸÑŸÖÿ®Ÿäÿπÿßÿ™)' } }),
            previewName ? D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [`ÿßŸÑŸÖÿπÿ±ŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿä: ${previewName}`]) : D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, ['ÿ≥Ÿäÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÖÿπÿ±ŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿπŸÜÿØ ÿßŸÑŸÉÿ™ÿßÿ®ÿ©.']),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'comment', value: form.comment || '', rows:3, placeholder:'ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™' } }),
            UI.Label({ text:'ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ŸÇŸÑ id ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿü' }),
            UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'table', 'data-field':'includeId', type:'checkbox', checked: form.includeId !== false } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:table:create', variant:'solid', size:'sm' }}, ['ÿ•ŸÜÿ¥ÿßÿ°']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['ÿ•ŸÑÿ∫ÿßÿ°'])
        ]
      });
    }

    function ModalAddField(db){
      const open = db.ui?.modals?.field;
      const form = db.ui?.form?.field || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} ‚Äî ${table.label}`
          : formatIdentifier(table.name)
      }));
      const selectedTable = form.table && registry.get(form.table)
        ? form.table
        : (tableOptions[0]?.value || '');
      const currentTable = selectedTable ? registry.get(selectedTable) : null;
      const previewFieldName = form.name || (form.label ? computeFieldIdentifier(currentTable, form.label) : '');
      const selectedReferenceTable = form.references?.table && registry.get(form.references.table)
        ? form.references.table
        : '';
      const referenceTableEntity = selectedReferenceTable ? registry.get(selectedReferenceTable) : null;
      const referenceFieldOptions = referenceTableEntity
        ? referenceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const selectedReferenceField = referenceFieldOptions.some(opt => opt.value === form.references?.column)
        ? form.references?.column
        : '';
      return UI.Modal({
        open,
        size:'lg',
        title:'ÿ•ÿ∂ÿßŸÅÿ© ÿ≠ŸÇŸÑ',
        description:'ÿ≠ÿØÿØ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ≠ŸÇŸÑ ÿßŸÑÿ¨ÿØŸäÿØ.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{
                gkey:'erd:form:update',
                'data-form':'field',
                'data-field':'table',
                value: selectedTable || ''
              },
              options:[{ value:'', label:'ÿßÿÆÿ™ÿ± ÿßŸÑÿ¨ÿØŸàŸÑ' }, ...tableOptions]
            }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'label', value: form.label || '', placeholder:'ÿßŸÑŸÖÿ≥ŸÖŸâ ÿßŸÑÿπÿ±ÿ®Ÿä ŸÑŸÑÿ≠ŸÇŸÑ' } }),
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)] md:col-span-2` }}, [previewFieldName ? `ÿßŸÑŸÖÿπÿ±ŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿä: ${previewFieldName}` : 'ÿ≥Ÿäÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÖÿπÿ±ŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿπŸÜÿØ ÿßŸÑŸÉÿ™ÿßÿ®ÿ©.']),
            UI.Select({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'type', value: form.type || 'string' }, options: DEFAULT_FIELD_TYPES.map(type=> ({ value:type, label:type })) }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'defaultValue', value: form.defaultValue || '', placeholder:'ŸÇŸäŸÖÿ© ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©' } }),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Nullableÿü' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'nullable', type:'checkbox', checked: form.nullable !== false } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Primary Keyÿü' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'primaryKey', type:'checkbox', checked: !!form.primaryKey } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Uniqueÿü' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'unique', type:'checkbox', checked: !!form.unique } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`col-span-full flex flex-col gap-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['ÿπŸÑÿßŸÇÿ© ŸÖÿ±ÿ¨ÿπŸäÿ© ÿßÿÆÿ™Ÿäÿßÿ±Ÿäÿ©']),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'table',
                  value: selectedReferenceTable
                },
                options:[{ value:'', label:'ÿ®ÿØŸàŸÜ ÿπŸÑÿßŸÇÿ©' }, ...tableOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'column',
                  value: selectedReferenceField
                },
                options:[{ value:'', label:'ÿßÿÆÿ™ÿ± ÿßŸÑÿ≠ŸÇŸÑ' }, ...referenceFieldOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onDelete',
                  value: form.references?.onDelete || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onUpdate',
                  value: form.references?.onUpdate || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:field:create', variant:'solid', size:'sm' }}, ['ÿ•ÿ∂ÿßŸÅÿ©']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['ÿ•ŸÑÿ∫ÿßÿ°'])
        ]
      });
    }

    function ModalRelation(db){
      const open = db.ui?.modals?.relation;
      const form = db.ui?.form?.relation || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} ‚Äî ${table.label}`
          : formatIdentifier(table.name)
      }));
      const sourceTableValue = form.sourceTable && registry.get(form.sourceTable)
        ? form.sourceTable
        : '';
      const sourceTableEntity = sourceTableValue ? registry.get(sourceTableValue) : null;
      const sourceFieldOptions = sourceTableEntity
        ? sourceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const sourceFieldValue = sourceFieldOptions.some(opt => opt.value === form.sourceField)
        ? form.sourceField
        : '';
      const targetTableValue = form.targetTable && registry.get(form.targetTable)
        ? form.targetTable
        : '';
      const targetTableEntity = targetTableValue ? registry.get(targetTableValue) : null;
      const targetFieldOptions = targetTableEntity
        ? targetTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const targetFieldValue = targetFieldOptions.some(opt => opt.value === form.targetField)
        ? form.targetField
        : '';
      return UI.Modal({
        open,
        size:'md',
        title:'ÿ•ŸÜÿ¥ÿßÿ° ÿπŸÑÿßŸÇÿ© ÿ®ŸäŸÜ ÿßŸÑÿ¨ÿØÿßŸàŸÑ',
        description:'ÿ≠ÿØÿØ ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑŸÖÿµÿØÿ± ŸàÿßŸÑŸáÿØŸÅ Ÿàÿ£ÿ≥ŸÑŸàÿ® ÿßŸÑÿ™ÿ≠ÿØŸäÿ´.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceTable', value: sourceTableValue },
              options:[{ value:'', label:'ÿßÿÆÿ™ÿ± ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑŸÖÿµÿØÿ±' }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceField', value: sourceFieldValue },
              options:[{ value:'', label:'ÿßÿÆÿ™ÿ± ÿßŸÑÿ≠ŸÇŸÑ ÿßŸÑŸÖÿµÿØÿ±' }, ...sourceFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetTable', value: targetTableValue },
              options:[{ value:'', label:'ÿßÿÆÿ™ÿ± ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑŸáÿØŸÅ' }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetField', value: targetFieldValue },
              options:[{ value:'', label:'ÿßÿÆÿ™ÿ± ÿßŸÑÿ≠ŸÇŸÑ ÿßŸÑŸáÿØŸÅ' }, ...targetFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onDelete', value: form.onDelete || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onUpdate', value: form.onUpdate || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:relation:create', variant:'solid', size:'sm' }}, ['ÿ≠ŸÅÿ∏ ÿßŸÑÿπŸÑÿßŸÇÿ©']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['ÿ•ŸÑÿ∫ÿßÿ°'])
        ]
      });
    }

    function Modals(db){
      return [
        ModalImport(db),
        ModalExportJson(db),
        ModalExportSql(db),
        ModalSchemaMeta(db),
        ModalAddTable(db),
        ModalAddField(db),
        ModalRelation(db)
      ];
    }

    function AppView(db){
      return D.Containers.Div({ attrs:{ class: tw`flex h-screen w-full bg-[var(--surface-0)] text-[var(--foreground)]` }}, [
        SchemaLibraryPanel(db),
        D.Containers.Div({ attrs:{ class: tw`flex flex-1 flex-col` }}, [
          Toolbar(db),
          SchemaCanvas(db)
        ]),
        InspectorPanel(db),
        ...Modals(db)
      ]);
    }

    const erdOrders = {
      'erd.zoom.in':{
        on:['click'],
        gkeys:['erd:zoom:in'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.min(2, (s.data.canvas?.zoom || 1) + 0.1);
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas:{ zoom },
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas:{ zoom },
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.out':{
        on:['click'],
        gkeys:['erd:zoom:out'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.max(0.2, (s.data.canvas?.zoom || 1) - 0.1);
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas:{ zoom },
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas:{ zoom },
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.reset':{
        on:['click'],
        gkeys:['erd:zoom:reset'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas:{ zoom:1 },
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas:{ zoom:1 },
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.table.select':{
        on:['click'],
        gkeys:['erd:table:select'],
        handler:(e,ctx)=>{
          const card = e.target.closest('[data-table-name]');
          if(!card) return;
          const tableName = card.getAttribute('data-table-name');
          ctx.setState(s => withTableSelection(s, tableName));
          ctx.rebuild();
        }
      },
      'erd.field.select':{
        on:['click'],
        gkeys:['erd:field:select'],
        handler:(e,ctx)=>{
          const row = e.target.closest('[data-field-name]');
          if(!row) return;
          const tableName = row.getAttribute('data-table-name');
          const fieldName = row.getAttribute('data-field-name');
          ctx.setState(s => withFieldSelection(s, tableName, fieldName));
          ctx.rebuild();
        }
      },
      'erd.import.open':{
        on:['click'],
        gkeys:['erd:import:open'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), import:true },
              form:{ ...(s.ui?.form || {}), import:{ name: payload.name, title: payload.title, targetId: s.data.schemaId || '', text: JSON.stringify(payload, null, 2) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.export.json':{
        on:['click'],
        gkeys:['erd:export:json'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas,
            createdAt: state.data.schemaCreatedAt,
            updatedAt: state.data.schemaUpdatedAt
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), exportJson:true },
              form:{ ...(s.ui?.form || {}), export:{ text: JSON.stringify(payload, null, 2) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.export.sql':{
        on:['click'],
        gkeys:['erd:export:sql'],
        handler:(e,ctx)=>{
          const registry = getRegistry(ctx.getState());
          const sql = registry.generateSQL({ schemaName:'public' });
          ctx.setState(s=>({
            ...s,
            data:{ ...s.data, sqlPreview: sql },
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), exportSql:true },
              form:{ ...(s.ui?.form || {}), sql:{ text: sql } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.modal.close':{
        on:['click'],
        gkeys:['erd:modal:close','ui:modal:close'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false } }
          }));
          ctx.rebuild();
        }
      },
      'erd.form.update':{
        on:['input','change'],
        gkeys:['erd:form:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          const parent = input.getAttribute('data-parent');
          if(!formKey) return;
          const value = input.value;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            if(formKey === 'fieldRef' || formKey === 'fieldRefColumn' || parent === 'field'){
              const current = currentForms.field || {};
              let nextRef = { ...(current.references || {}) };
              if(fieldKey){
                nextRef[fieldKey] = value;
              }
              if(fieldKey === 'table'){
                nextRef = { ...nextRef, table: value, column: '' };
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...current, references: nextRef } } } };
            }
            if(formKey === 'table' && fieldKey === 'label'){
              const registry = getRegistry(s);
              const targetForm = currentForms.table || {};
              const slug = computeTableIdentifier(registry, value);
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, table:{ ...targetForm, label:value, name: slug } } } };
            }
            if(formKey === 'field' && fieldKey === 'label'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = targetForm.table ? registry.get(targetForm.table) : null;
              const slug = computeFieldIdentifier(table, value);
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...targetForm, label:value, name: slug, columnName: slug } } } };
            }
            if(formKey === 'field' && fieldKey === 'table'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = value ? registry.get(value) : null;
              let slug = targetForm.name || '';
              if(targetForm.label){
                slug = computeFieldIdentifier(table, targetForm.label);
              }
              const currentRefs = targetForm.references || {};
              const references = currentRefs.table === value
                ? currentRefs
                : { table:'', column:'', onDelete: currentRefs.onDelete || 'CASCADE', onUpdate: currentRefs.onUpdate || 'CASCADE' };
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...targetForm, table:value, name: slug, columnName: slug, references } } } };
            }
            if(formKey === 'relation' && fieldKey === 'sourceTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, sourceTable: value, sourceField:'' } } }
              };
            }
            if(formKey === 'relation' && fieldKey === 'targetTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, targetTable: value, targetField:'' } } }
              };
            }
            if(fieldKey){
              const targetForm = currentForms[formKey] || {};
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: value } } } };
            }
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: value } } };
          });
          ctx.rebuild();
        }
      },
      'erd.form.toggle':{
        on:['change'],
        gkeys:['erd:form:toggle'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          if(!formKey || !fieldKey) return;
          const checked = input.checked;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            const targetForm = currentForms[formKey] || {};
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: checked } } } };
          });
          ctx.rebuild();
        }
      },
      'erd.table.add':{
        on:['click'],
        gkeys:['erd:table:add'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), table:true } }
          }));
          ctx.rebuild();
        }
      },
      'erd.table.create':{
        on:['click'],
        gkeys:['erd:table:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.table || {};
          const registry = getRegistry(state);
          const label = (form.label || '').trim();
          if(!label){
            UI.pushToast(ctx, { title:'Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿßŸÑŸÖÿ≥ŸÖŸâ ÿßŸÑÿπÿ±ÿ®Ÿä ŸÑŸÑÿ¨ÿØŸàŸÑ', icon:'‚ö†Ô∏è' });
            return;
          }
          const name = computeTableIdentifier(registry, label);
          try{
            const tableConfig = {
              name,
              label: label,
              comment: form.comment || '',
              layout:{ x: 160 + registry.list().length * 120, y: 120 + registry.list().length * 60 },
              fields: []
            };
            if(form.includeId){
              tableConfig.fields.push({ name:'id', columnName:'id', type:'uuid', primaryKey:true, nullable:false });
            }
            registry.register(tableConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const layout = ensureLayout({ data:{ layout: s.data.layout } }, name);
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                head:{ ...(s.head || {}), title: record.title || (s.head?.title || 'ŸÖÿÆÿ∑ÿ∑ ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ¥ŸÉÿßÿ©') },
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  layout,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), table:false },
                  form:{
                    ...(s.ui?.form || {}),
                    table:{ name:'', label:'', comment:'', includeId:true },
                    field:{ ...(s.ui?.form?.field || {}), table: name, label:'', name:'', columnName:'' },
                    layout:{ x: layout[name].x, y: layout[name].y }
                  }
                }
              };
              draft = withTableSelection(draft, name);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create table', error);
            UI.pushToast(ctx, { title:'ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ÿØŸàŸÑ', message:String(error), icon:'üõë' });
          }
        }
      },
      'erd.field.add':{
        on:['click'],
        gkeys:['erd:field:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const first = registry.list()[0]?.name || '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), field:true },
              form:{
                ...(s.ui?.form || {}),
                field:{
                  table: s.data.selection?.table || first,
                  label:'',
                  name:'',
                  columnName:'',
                  type:'string',
                  nullable:true,
                  primaryKey:false,
                  unique:false,
                  defaultValue:'',
                  references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
                }
              }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.field.create':{
        on:['click'],
        gkeys:['erd:field:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.field || {};
          const tableName = (form.table || '').trim();
          const label = (form.label || '').trim();
          if(!tableName || !label){
            UI.pushToast(ctx, { title:'ÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸàŸÑ ŸàÿßŸÑŸÖÿ≥ŸÖŸâ ÿßŸÑÿπÿ±ÿ®Ÿä ŸÑŸÑÿ≠ŸÇŸÑ ŸÖÿ∑ŸÑŸàÿ®ÿßŸÜ', icon:'‚ö†Ô∏è' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:'ÿßŸÑÿ¨ÿØŸàŸÑ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ', icon:'‚ö†Ô∏è' });
            return;
          }
          try{
            const fieldName = computeFieldIdentifier(table, label);
            const fieldConfig = {
              name: fieldName,
              columnName: form.columnName ? Schema.utils.toSnakeCase(form.columnName) : fieldName,
              type: form.type || 'string',
              nullable: form.nullable !== false,
              primaryKey: !!form.primaryKey,
              unique: !!form.unique,
              comment: label
            };
            if(form.defaultValue){
              const val = form.defaultValue;
              if(['integer','number','decimal','float'].includes(fieldConfig.type)){
                const num = Number(val);
                if(!Number.isNaN(num)) fieldConfig.defaultValue = num;
              } else if(fieldConfig.type === 'boolean'){
                fieldConfig.defaultValue = ['true','1','yes','on'].includes(String(val).toLowerCase());
              } else {
                fieldConfig.defaultValue = val;
              }
            }
            if(form.references && form.references.table && form.references.column){
              fieldConfig.references = {
                table: form.references.table,
                column: form.references.column,
                onDelete: form.references.onDelete || 'CASCADE',
                onUpdate: form.references.onUpdate || 'CASCADE'
              };
            }
            table.addField(fieldConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), field:false },
                  form:{ ...(s.ui?.form || {}), field:{ ...form, label:'', name:'', columnName:'', defaultValue:'', primaryKey:false, unique:false } }
                }
              };
              draft = withFieldSelection(draft, tableName, fieldName);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to add field', error);
            UI.pushToast(ctx, { title:'ŸÅÿ¥ŸÑ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ≠ŸÇŸÑ', message:String(error), icon:'üõë' });
          }
        }
      },
      'erd.relation.add':{
        on:['click'],
        gkeys:['erd:relation:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), relation:true },
              form:{ ...(s.ui?.form || {}), relation:{ sourceTable: selection.table || '', sourceField: selection.field || '', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.relation.create':{
        on:['click'],
        gkeys:['erd:relation:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.relation || {};
          if(!form.sourceTable || !form.sourceField || !form.targetTable || !form.targetField){
            UI.pushToast(ctx, { title:'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿµÿØÿ± ŸàÿßŸÑŸáÿØŸÅ', icon:'‚ö†Ô∏è' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(form.sourceTable);
          if(!table){
            UI.pushToast(ctx, { title:'ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑŸÖÿµÿØÿ± ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ', icon:'‚ö†Ô∏è' });
            return;
          }
          try{
            table.updateField(form.sourceField, {
              references:{
                table: form.targetTable,
                column: form.targetField,
                onDelete: form.onDelete || 'CASCADE',
                onUpdate: form.onUpdate || 'CASCADE'
              }
            });
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), relation:false } }
              };
              draft = withFieldSelection(draft, form.sourceTable, form.sourceField);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create relation', error);
            UI.pushToast(ctx, { title:'ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿπŸÑÿßŸÇÿ©', message:String(error), icon:'üõë' });
          }
        }
      },
      'erd.import.apply':{
        on:['click'],
        gkeys:['erd:import:apply'],
        handler:async (e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.import || {};
          const raw = form.text || '';
          try{
            const parsed = JSON.parse(raw);
            const schemaPayload = parsed.schema && parsed.schema.tables ? parsed.schema : parsed;
            const registry = Schema.Registry.fromJSON(schemaPayload);
            const normalizedSchema = registry.toJSON();
            const layout = computeLayout(registry, parsed.layout);
            const targetId = form.targetId || '';
            let existing = null;
            if(targetId){ existing = await SchemaLibrary.get(targetId); }
            const now = Date.now();
            const recordInput = {
              id: targetId || undefined,
              name: form.name || parsed.name || schemaPayload.name || `schema_${now}`,
              title: form.title || parsed.title || form.name || `ŸÖÿÆÿ∑ÿ∑ ${now}`,
              description: parsed.description || '',
              schema: normalizedSchema,
              layout,
              canvas: parsed.canvas || existing?.canvas || state.data.canvas,
              createdAt: existing?.createdAt,
              updatedAt: now
            };
            const saved = await SchemaLibrary.save(recordInput);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: saved.title || 'ŸÖÿÆÿ∑ÿ∑ ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ¥ŸÉÿßÿ©' },
              data:{
                ...s.data,
                schemaId: saved.id,
                schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' },
                schemaCreatedAt: saved.createdAt,
                schemaUpdatedAt: saved.updatedAt,
                schema: normalizedSchema,
                layout,
                selection:{ table:first, field:null },
                canvas: saved.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), import:false },
                form:{
                  ...(s.ui?.form || {}),
                  import:{ name:'', title:'', targetId:'', text:'' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'ÿ™ŸÖ ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿßŸÑŸÖÿÆÿ∑ÿ∑ Ÿàÿ™ÿÆÿ≤ŸäŸÜŸá', icon:'‚úÖ' });
          } catch(error){
            console.warn('[Mishkah][ERD] import failed', error);
            UI.pushToast(ctx, { title:'ÿ™ÿπÿ∞ÿ± ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ JSON', message:String(error), icon:'üõë' });
          }
        }
      },
      'erd.layout.input':{
        on:['input','change'],
        gkeys:['erd:layout:input'],
        handler:(e,ctx)=>{
          const axis = e.target.getAttribute('data-axis');
          if(!axis) return;
          const value = Number(e.target.value);
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), form:{ ...(s.ui?.form || {}), layout:{ ...(s.ui?.form?.layout || {}), [axis]: Number.isFinite(value) ? value : 0 } } }
          }));
          ctx.rebuild();
        }
      },
      'erd.layout.apply':{
        on:['click'],
        gkeys:['erd:layout:apply'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          if(!selection.table){
            UI.pushToast(ctx, { title:'ÿßÿÆÿ™ÿ± ÿ¨ÿØŸàŸÑÿßŸã ŸÑÿ™ÿ≠ÿØŸäÿ´ ŸÖŸàŸÇÿπŸá', icon:'‚ö†Ô∏è' });
            return;
          }
          const formLayout = state.ui?.form?.layout || { x:120, y:120 };
          let next;
          ctx.setState(s=>{
            const layout = Object.assign({}, s.data.layout || {});
            layout[selection.table] = { x: Number(formLayout.x) || 0, y: Number(formLayout.y) || 0 };
            const now = Date.now();
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              data:{
                ...s.data,
                layout,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.library.new':{
        on:['click'],
        gkeys:['erd:library:new'],
        handler:async (e,ctx)=>{
          try{
            const record = await SchemaLibrary.createBlank({ title:'ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸäÿØ' });
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'ŸÖÿÆÿ∑ÿ∑ ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ¥ŸÉÿßÿ©' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: record.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  table:{ name:'', label:'', comment:'', includeId:true },
                  field:{ table:first || '', name:'', columnName:'', type:'string', nullable:true, primaryKey:false, unique:false, defaultValue:'', references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' } },
                  relation:{ sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸäÿØ', icon:'‚ú®' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create new schema', error);
            UI.pushToast(ctx, { title:'ÿ™ÿπÿ∞ÿ± ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖÿÆÿ∑ÿ∑', message:String(error), icon:'üõë' });
          }
        }
      },
      'erd.library.select':{
        on:['click'],
        gkeys:['erd:library:select'],
        handler:async (e,ctx)=>{
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId || schemaId === state.data.schemaId) return;
          try{
            const record = await SchemaLibrary.get(schemaId);
            if(!record){
              UI.pushToast(ctx, { title:'ÿ™ÿπÿ∞ÿ± ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿÆÿ∑ÿ∑', icon:'üõë' });
              return;
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'ŸÖÿÆÿ∑ÿ∑ ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ¥ŸÉÿßÿ©' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: record.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
          } catch(error){
            console.warn('[Mishkah][ERD] failed to select schema', error);
            UI.pushToast(ctx, { title:'ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿÆÿ∑ÿ∑', message:String(error), icon:'üõë' });
          }
        }
      },
      'erd.library.delete':{
        on:['click'],
        gkeys:['erd:library:delete'],
        handler:async (e,ctx)=>{
          e.preventDefault();
          e.stopPropagation();
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId) return;
          const count = state.data.library?.items?.length || 0;
          if(count <= 1){
            UI.pushToast(ctx, { title:'ŸÑÿß ŸäŸÖŸÉŸÜ ÿ≠ÿ∞ŸÅ ÿ¢ÿÆÿ± ŸÖÿÆÿ∑ÿ∑', icon:'‚ö†Ô∏è' });
            return;
          }
          try{
            await SchemaLibrary.remove(schemaId);
            let list = await SchemaLibrary.list();
            if(!list.length){
              const blank = await SchemaLibrary.createBlank({ title:'ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸäÿØ' });
              list = [blank];
            }
            let record = null;
            if(schemaId === state.data.schemaId){
              record = list[0];
            } else {
              record = await SchemaLibrary.get(state.data.schemaId) || list[0];
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'ŸÖÿÆÿ∑ÿ∑ ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ¥ŸÉÿßÿ©' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: record.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿÆÿ∑ÿ∑', icon:'üóëÔ∏è' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to delete schema', error);
            UI.pushToast(ctx, { title:'ÿ™ÿπÿ∞ÿ± ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿÆÿ∑ÿ∑', message:String(error), icon:'üõë' });
          }
        }
      },
      'erd.schema.meta.open':{
        on:['click'],
        gkeys:['erd:schema:meta:open'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), schemaMeta:true },
              form:{ ...(s.ui?.form || {}), schemaMeta:{ ...(s.data.schemaMeta || {}) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.schema.meta.save':{
        on:['click'],
        gkeys:['erd:schema:meta:save'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const form = s.ui?.form?.schemaMeta || {};
            const now = Date.now();
            const meta = {
              name: (form.name || s.data.schemaMeta?.name || '').trim() || `schema_${s.data.schemaId?.slice(-4) || 'new'}`,
              title: (form.title || form.name || s.data.schemaMeta?.title || '').trim() || 'ŸÖÿÆÿ∑ÿ∑ ÿ¨ÿØŸäÿØ',
              description: (form.description || '').trim()
            };
            const record = {
              id: s.data.schemaId,
              name: meta.name,
              title: meta.title,
              description: meta.description,
              schema: s.data.schema,
              layout: s.data.layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              head:{ ...(s.head || {}), title: meta.title || 'ŸÖÿÆÿ∑ÿ∑ ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ¥ŸÉÿßÿ©' },
              data:{
                ...s.data,
                schemaMeta: meta,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), schemaMeta:false },
                form:{ ...(s.ui?.form || {}), schemaMeta: meta }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      }
    };

    const app = M.app.createApp(erdState, {});
    const auto = U.twcss.auto(erdState, app, { pageScaffold:true });

    M.app.setBody(AppView);

    app.setOrders(Object.assign({}, UI.orders, auto.orders, erdOrders));
    app.mount('#app');
  })();
  </script>
</body>
</html>
