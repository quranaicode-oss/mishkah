<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>مخطط قاعدة بيانات مشكاة</title>
  <style>
    :root {
      color-scheme: light dark;
      --background: #f8fafc;
      --surface-0: #f8fafc;
      --surface-1: #ffffff;
      --surface-2: #eef2ff;
      --card: #ffffff;
      --card-foreground: #0f172a;
      --foreground: #0f172a;
      --muted: #475569;
      --muted-foreground: #475569;
      --border: #cfd8ea;
      --input: #dbe3f8;
      --accent: #eaf2ff;
      --accent-foreground: #102341;
      --primary: #2563eb;
      --primary-foreground: #f8fafc;
      --secondary: #d8e1ff;
      --secondary-foreground: #102341;
      --destructive: #ef4444;
      --destructive-foreground: #ffffff;
      --ring: #2563eb;
      --shadow: 0 28px 60px -28px rgba(15, 23, 42, 0.35);
      --radius: 16px;
    }
    :root.dark {
      color-scheme: dark;
      --background: #0b1220;
      --surface-0: #0b1220;
      --surface-1: #101a2c;
      --surface-2: #16243a;
      --card: #111d30;
      --card-foreground: #e2e8f0;
      --foreground: #f8fafc;
      --muted: #94a3b8;
      --muted-foreground: #94a3b8;
      --border: #1f2a3d;
      --input: #223044;
      --accent: #1e2a3f;
      --accent-foreground: #e2e8f0;
      --primary: #60a5fa;
      --primary-foreground: #0b1220;
      --secondary: #27364e;
      --secondary-foreground: #e2e8f0;
      --destructive: #f87171;
      --destructive-foreground: #0b1220;
      --ring: #60a5fa;
      --shadow: 0 30px 70px -36px rgba(8, 15, 30, 0.75);
      --radius: 16px;
    }
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      height: 100%;
      min-height: 100vh;
      margin: 0;
      background: var(--background, #0f1115);
      color: var(--foreground, #f8fafc);
      font-family: "Tajawal", "Cairo", system-ui, sans-serif;
      transition: background-color 160ms ease, color 160ms ease;
    }
    body {
      display: flex;
      min-height: 100vh;
      width: 100vw;
      overflow-x: hidden;
    }
    #app { flex: 1 1 auto; display: flex; }
    textarea[readonly] { user-select: all; }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/@antv/x6@1.35.3/dist/x6.css"/>
  <script src="./mishkah-utils.js"></script>
  <script src="./mishkah.core.js"></script>
  <script src="./mishkah-ui.js"></script>
  <script src="./mishkah-schema.js"></script>
</head>
<body>
  <div id="app"></div>
  <script>
  (async function(){
    const M = Mishkah;
    const UI = M.UI;
    const U = M.utils;
    const D = M.DSL;
    const Schema = M.schema;
    const { tw } = U.twcss;
    const Text = U.Text || {};

    const X6_CDN_SOURCES = [
      'https://unpkg.com/@antv/x6@1.35.3/dist/x6.js',
      'https://cdn.jsdelivr.net/npm/@antv/x6@1.35.3/dist/x6.js'
    ];

    function loadScriptOnce(url){
      return new Promise((resolve, reject)=>{
        if(typeof document === 'undefined'){
          reject(new Error('document unavailable'));
          return;
        }
        const existing = document.querySelector(`script[data-mishkah-loader="${url}"]`);
        if(existing){
          if(existing.getAttribute('data-loaded') === 'true'){
            resolve();
            return;
          }
          existing.addEventListener('load', ()=> resolve(), { once:true });
          existing.addEventListener('error', ()=> reject(new Error(`Failed to load script: ${url}`)), { once:true });
          return;
        }
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.setAttribute('data-mishkah-loader', url);
        script.addEventListener('load', ()=>{
          script.setAttribute('data-loaded', 'true');
          resolve();
        }, { once:true });
        script.addEventListener('error', ()=>{
          script.remove();
          reject(new Error(`Failed to load script: ${url}`));
        }, { once:true });
        document.head.appendChild(script);
      });
    }

    async function ensureX6Library(){
      if(typeof window === 'undefined') return false;
      if(window.X6?.Graph) return true;
      if(window.__mishkahX6Loading){
        try { await window.__mishkahX6Loading; }
        catch(error){ console.warn('[Mishkah][ERD] X6 preload failed', error); }
        return !!(window.X6?.Graph);
      }
      window.__mishkahX6Loading = (async ()=>{
        for(const url of X6_CDN_SOURCES){
          try {
            await loadScriptOnce(url);
            if(window.X6?.Graph) return true;
          } catch(error){
            console.warn('[Mishkah][ERD] failed to load X6 source', url, error);
          }
        }
        return !!(window.X6?.Graph);
      })();
      try {
        const ready = await window.__mishkahX6Loading;
        return ready;
      } catch(error){
        console.warn('[Mishkah][ERD] X6 loader encountered an error', error);
        return !!(window.X6?.Graph);
      }
    }

    const x6Available = await ensureX6Library();
    if(!x6Available){
      console.warn('[Mishkah][ERD] AntV X6 library is not available, diagram will use fallback driver.');
    }

    let erdAppInstance = null;
    let erdDriver = null;
    let activeDriverName = null;
    let pendingDiagramFrame = false;
    let lastDiagramState = null;
    let applyingAutoZoom = false;

    function applyAutoZoom(targetZoom){
      if(!erdAppInstance) return;
      const zoom = Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, Number(targetZoom) || 1));
      if(applyingAutoZoom) return;
      const state = erdAppInstance.getState();
      const currentZoom = state?.data?.canvas?.zoom || 1;
      if(Math.abs(currentZoom - zoom) < 0.01) return;
      applyingAutoZoom = true;
      try {
        erdAppInstance.setState(s => ({
          ...s,
          data:{
            ...s.data,
            canvas:{ ...(s.data.canvas || {}), zoom, mode:'auto' },
          },
        }));
        erdAppInstance.rebuild();
      } finally {
        applyingAutoZoom = false;
      }
    }

    const TABLE_WIDTH = 280;
    const HEADER_HEIGHT = 48;
    const ROW_HEIGHT = 28;
    const AUTO_LAYOUT_ORIGIN_X = 120;
    const AUTO_LAYOUT_ORIGIN_Y = 120;
    const AUTO_LAYOUT_COLUMN_GAP = TABLE_WIDTH + 80;
    const AUTO_LAYOUT_ROW_GAP = 220;
    const MIN_CANVAS_ZOOM = 0.2;
    const MAX_CANVAS_ZOOM = 1;

    function computeTableHeight(fieldCount){
      const rows = Math.max(1, Number(fieldCount) || 0);
      return Math.max(HEADER_HEIGHT + rows * ROW_HEIGHT, HEADER_HEIGHT + ROW_HEIGHT);
    }

    function computeGridPosition(index, total){
      const columns = Math.max(1, Math.ceil(Math.sqrt(Math.max(1, total || 1))));
      const col = index % columns;
      const row = Math.floor(index / columns);
      return {
        x: AUTO_LAYOUT_ORIGIN_X + col * AUTO_LAYOUT_COLUMN_GAP,
        y: AUTO_LAYOUT_ORIGIN_Y + row * AUTO_LAYOUT_ROW_GAP,
      };
    }

    function normalisePoint(point, fallback){
      if(point && Number.isFinite(Number(point.x)) && Number.isFinite(Number(point.y))){
        return { x: Number(point.x), y: Number(point.y) };
      }
      return { x: fallback.x, y: fallback.y };
    }

    function computeLayoutBounds(nodes){
      if(!Array.isArray(nodes) || !nodes.length){
        return { width: 0, height: 0, minX: 0, minY: 0, maxX: 0, maxY: 0 };
      }
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      nodes.forEach(node => {
        const x = Number(node.x) || 0;
        const y = Number(node.y) || 0;
        const width = Number(node.width) || 0;
        const height = Number(node.height) || 0;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + width);
        maxY = Math.max(maxY, y + height);
      });
      return { minX, minY, maxX, maxY, width: Math.max(0, maxX - minX), height: Math.max(0, maxY - minY) };
    }

    function recommendZoomForBounds(bounds, viewportWidth, viewportHeight){
      if(!bounds || bounds.width <= 0 || bounds.height <= 0){
        return 1;
      }
      const width = Math.max(1, viewportWidth || 0);
      const height = Math.max(1, viewportHeight || 0);
      const paddedWidth = bounds.width + AUTO_LAYOUT_COLUMN_GAP;
      const paddedHeight = bounds.height + AUTO_LAYOUT_ROW_GAP;
      const scaleX = width ? width / paddedWidth : 1;
      const scaleY = height ? height / paddedHeight : 1;
      const zoom = Math.min(1, scaleX, scaleY);
      return Math.max(MIN_CANVAS_ZOOM, Number.isFinite(zoom) ? zoom : 1);
    }

    function normaliseCanvas(canvas){
      const source = canvas || {};
      const rawZoom = Number(source.zoom);
      const zoom = Number.isFinite(rawZoom) ? Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, rawZoom)) : 1;
      const mode = source.mode === 'manual' ? 'manual' : 'auto';
      return { ...source, zoom, mode };
    }

    function layoutsDiffer(current, computed){
      const currentMap = current || {};
      const computedMap = computed || {};
      const currentKeys = Object.keys(currentMap);
      const computedKeys = Object.keys(computedMap);
      if(currentKeys.length !== computedKeys.length) return true;
      return computedKeys.some(key => {
        const a = currentMap[key];
        const b = computedMap[key];
        if(!a || !b) return true;
        return Number(a.x) !== Number(b.x) || Number(a.y) !== Number(b.y);
      });
    }

    const FIELD_TYPE_OPTIONS = [
      { value:'string', label:'String (varchar)' },
      { value:'text', label:'Text' },
      { value:'integer', label:'Integer' },
      { value:'number', label:'Numeric (precision/scale)' },
      { value:'decimal', label:'Decimal' },
      { value:'float', label:'Float / double precision' },
      { value:'boolean', label:'Boolean' },
      { value:'date', label:'Date' },
      { value:'datetime', label:'Datetime' },
      { value:'timestamp', label:'Timestamp with timezone' },
      { value:'json', label:'JSONB' },
      { value:'uuid', label:'UUID' }
    ];

    const RELATION_ACTION_OPTIONS = ['CASCADE','RESTRICT','SET NULL','NO ACTION'];

    const clone = (U.JSON && U.JSON.clone) ? U.JSON.clone : (obj => JSON.parse(JSON.stringify(obj)));

    const FIELD_BADGE_MAP = {
      pk: '⦿',
      fk: '↗',
      uk: '☆',
      nullable: '∅',
      index: '#'
    };

    function truncateText(value, maxLength){
      const text = String(value ?? '').trim();
      if(!text) return '';
      const limit = Math.max(4, Number(maxLength) || 32);
      if(text.length <= limit) return text;
      return `${text.slice(0, limit - 1)}…`;
    }

    function fieldBadges(field){
      const badges = [];
      if(field.pk) badges.push(FIELD_BADGE_MAP.pk);
      if(field.unique && !field.pk) badges.push(FIELD_BADGE_MAP.uk);
      if(field.references) badges.push(FIELD_BADGE_MAP.fk);
      if(field.index && !field.unique && !field.pk) badges.push(FIELD_BADGE_MAP.index);
      if(field.nullable) badges.push(FIELD_BADGE_MAP.nullable);
      return badges.join(' ');
    }

    function buildFieldDisplay(field){
      const badges = fieldBadges(field);
      const label = truncateText(field.name || '', 22);
      const type = truncateText(field.type || '', 18);
      return {
        badges,
        label,
        type
      };
    }

    function buildColumnsFormRows(table){
      if(!table || !Array.isArray(table.fields)) return [];
      return table.fields.map(field => ({
        key: field.name,
        originalName: field.name,
        name: field.name,
        type: field.type || 'string',
        length: field.maxLength != null ? String(field.maxLength) : '',
        precision: field.precision != null ? String(field.precision) : '',
        scale: field.scale != null ? String(field.scale) : '',
        nullable: field.nullable !== false,
        defaultValue: field.defaultValue != null ? String(field.defaultValue) : '',
        primaryKey: !!field.primaryKey,
        unique: !!field.unique,
        index: !!field.index,
        references: field.references ? {
          table: field.references.table || '',
          column: field.references.column || '',
          onDelete: field.references.onDelete || 'CASCADE',
          onUpdate: field.references.onUpdate || 'CASCADE'
        } : { table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
      }));
    }

    function defaultLengthForType(type){
      if(type === 'string' || type === 'text') return '4000';
      return '';
    }

    function defaultPrecisionForType(type){
      if(type === 'decimal' || type === 'number') return { precision:'18', scale:'2' };
      return { precision:'', scale:'' };
    }

    function typeSupportsLength(type){
      return ['string', 'text'].includes(type);
    }

    function typeSupportsPrecision(type){
      return ['decimal', 'number'].includes(type);
    }

    class SvgDriver {
      constructor(){
        this.container = null;
        this.hooks = {};
        this.svg = null;
        this.viewport = null;
        this.wrapper = null;
        this.defs = null;
        this.lastState = null;
        this.baseBBox = null;
        this.overrideFitPadding = null;
        this.dragContext = null;
        this.nodeCache = new Map();
        this.edgeCache = new Map();
      }

      init(container, hooks){
        this.container = container;
        this.hooks = hooks || {};
        if(container) container.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'm-erd-svg-wrapper';
        Object.assign(wrapper.style, {
          position: 'relative',
          width: '100%',
          height: '100%',
          overflow: 'hidden'
        });
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.setAttribute('class', 'm-erd-svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        const defs = document.createElementNS(svgNS, 'defs');
        const marker = document.createElementNS(svgNS, 'marker');
        marker.setAttribute('id', 'm-erd-arrow');
        marker.setAttribute('viewBox', '0 0 12 12');
        marker.setAttribute('refX', '10');
        marker.setAttribute('refY', '6');
        marker.setAttribute('markerUnits', 'strokeWidth');
        marker.setAttribute('markerWidth', '8');
        marker.setAttribute('markerHeight', '8');
        marker.setAttribute('orient', 'auto');
        const markerPath = document.createElementNS(svgNS, 'path');
        markerPath.setAttribute('d', 'M 0 0 L 12 6 L 0 12 z');
        markerPath.setAttribute('fill', 'currentColor');
        marker.appendChild(markerPath);
        defs.appendChild(marker);
        svg.appendChild(defs);
        const viewport = document.createElementNS(svgNS, 'g');
        viewport.setAttribute('class', 'm-erd-viewport');
        svg.appendChild(viewport);
        wrapper.appendChild(svg);
        if(container) container.appendChild(wrapper);
        this.wrapper = wrapper;
        this.svg = svg;
        this.viewport = viewport;
        this.defs = defs;
        this.baseBBox = null;
        this.lastState = null;
        this.overrideFitPadding = null;
      }

      clear(){
        if(!this.viewport) return;
        while(this.viewport.firstChild){
          this.viewport.removeChild(this.viewport.firstChild);
        }
        this.nodeCache.clear();
        this.edgeCache.clear();
        this.edgeCache.clear();
      }

      clientPointToSvg(clientX, clientY){
        if(!this.svg) return null;
        const point = this.svg.createSVGPoint();
        point.x = clientX;
        point.y = clientY;
        const ctm = this.svg.getScreenCTM();
        if(!ctm) return null;
        const transformed = point.matrixTransform(ctm.inverse());
        return { x: transformed.x, y: transformed.y };
      }

      attachNodeInteractions(group, node){
        if(!group) return;
        group.style.cursor = 'move';
        group.style.touchAction = 'none';
        const handlePointerDown = event => {
          if(event.button && event.button !== 0) return;
          event.preventDefault();
          event.stopPropagation();
          const origin = this.clientPointToSvg(event.clientX, event.clientY);
          if(!origin) return;
          const pointerId = event.pointerId;
          if(group.setPointerCapture && pointerId != null){
            try { group.setPointerCapture(pointerId); }
            catch(_){}
          }
          this.dragContext = {
            node,
            group,
            pointerId,
            offsetX: origin.x - node.x,
            offsetY: origin.y - node.y,
          };
          const target = this.svg?.ownerDocument || document;
          target.addEventListener('pointermove', handlePointerMove);
          target.addEventListener('pointerup', handlePointerUp);
          target.addEventListener('pointercancel', handlePointerUp);
        };

        const handlePointerMove = event => {
          if(!this.dragContext || (event.pointerId != null && this.dragContext.pointerId != null && event.pointerId !== this.dragContext.pointerId)){
            return;
          }
          event.preventDefault();
          const point = this.clientPointToSvg(event.clientX, event.clientY);
          if(!point) return;
          const nextX = point.x - this.dragContext.offsetX;
          const nextY = point.y - this.dragContext.offsetY;
          this.dragContext.node.x = nextX;
          this.dragContext.node.y = nextY;
          this.dragContext.group.setAttribute('transform', `translate(${nextX} ${nextY})`);
          this.updateEdgePaths(this.dragContext.node.id);
        };

        const handlePointerUp = event => {
          if(!this.dragContext || (event.pointerId != null && this.dragContext.pointerId != null && event.pointerId !== this.dragContext.pointerId)){
            return;
          }
          const context = this.dragContext;
          this.dragContext = null;
          const target = this.svg?.ownerDocument || document;
          target.removeEventListener('pointermove', handlePointerMove);
          target.removeEventListener('pointerup', handlePointerUp);
          target.removeEventListener('pointercancel', handlePointerUp);
          if(context.group.releasePointerCapture && context.pointerId != null){
            try { context.group.releasePointerCapture(context.pointerId); }
            catch(_){}
          }
          const roundedX = Math.round(context.node.x);
          const roundedY = Math.round(context.node.y);
          context.group.setAttribute('transform', `translate(${roundedX} ${roundedY})`);
          context.node.x = roundedX;
          context.node.y = roundedY;
          this.hooks?.onNodeMove?.({ id: String(context.node.id), x: roundedX, y: roundedY });
          this.updateEdgePaths(context.node.id);
        };

        group.addEventListener('pointerdown', handlePointerDown);
      }

      computeBoundingBox(nodes){
        if(!nodes.length){
          return {
            minX: 0,
            minY: 0,
            maxX: 640,
            maxY: 480
          };
        }
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        nodes.forEach(node => {
          minX = Math.min(minX, node.x);
          minY = Math.min(minY, node.y);
          maxX = Math.max(maxX, node.x + node.width);
          maxY = Math.max(maxY, node.y + node.height);
        });
        return { minX, minY, maxX, maxY };
      }

      setViewBox(bbox, zoom, padding){
        if(!this.svg) return;
        const baseWidth = Math.max(1, (bbox.maxX - bbox.minX));
        const baseHeight = Math.max(1, (bbox.maxY - bbox.minY));
        const pad = Math.max(16, padding != null ? padding : 120);
        const centerX = bbox.minX + baseWidth / 2;
        const centerY = bbox.minY + baseHeight / 2;
        let viewWidth = baseWidth + pad * 2;
        let viewHeight = baseHeight + pad * 2;
        let viewX = centerX - viewWidth / 2;
        let viewY = centerY - viewHeight / 2;
        if(this.overrideFitPadding != null){
          const fitPad = Math.max(16, this.overrideFitPadding);
          viewWidth = baseWidth + fitPad * 2;
          viewHeight = baseHeight + fitPad * 2;
          viewX = bbox.minX - fitPad;
          viewY = bbox.minY - fitPad;
          this.overrideFitPadding = null;
        } else if(zoom && Number.isFinite(zoom) && zoom !== 1){
          const safeZoom = Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, zoom));
          viewWidth = viewWidth / safeZoom;
          viewHeight = viewHeight / safeZoom;
          viewX = centerX - viewWidth / 2;
          viewY = centerY - viewHeight / 2;
        }
        this.svg.setAttribute('viewBox', `${viewX} ${viewY} ${viewWidth} ${viewHeight}`);
        this.baseBBox = Object.assign({}, bbox, { pad });
      }

      updateEdgePaths(nodeId){
        if(!nodeId || !this.edgeCache.size) return;
        this.edgeCache.forEach(meta => {
          if(meta.sourceNode !== nodeId && meta.targetNode !== nodeId) return;
          const geometry = this.computeEdgeGeometry(meta);
          if(!geometry) return;
          meta.path.setAttribute('d', geometry.path);
          if(meta.label){
            meta.label.setAttribute('x', String(geometry.labelX));
            meta.label.setAttribute('y', String(geometry.labelY));
          }
        });
      }

      computeEdgeGeometry(meta){
        if(!meta) return null;
        const sourceNode = this.nodeCache.get(meta.sourceNode);
        const targetNode = this.nodeCache.get(meta.targetNode);
        if(!sourceNode || !targetNode) return null;
        const sourceFieldY = sourceNode.fieldMap.get(meta.sourceField) || sourceNode.height / 2;
        const targetFieldY = targetNode.fieldMap.get(meta.targetField) || targetNode.height / 2;
        const sourceSide = meta.sourceSide === 'left' ? 'left' : 'right';
        const targetSide = meta.targetSide === 'right' ? 'right' : 'left';
        const startX = sourceSide === 'left' ? sourceNode.x : sourceNode.x + sourceNode.width;
        const endX = targetSide === 'right' ? targetNode.x + targetNode.width : targetNode.x;
        const startY = sourceNode.y + sourceFieldY;
        const endY = targetNode.y + targetFieldY;
        const margin = 36;
        const segments = [`M ${startX} ${startY}`];
        const forward = startX <= endX;
        if(forward){
          const exitX = sourceSide === 'left' ? sourceNode.x - margin : sourceNode.x + sourceNode.width + margin;
          const entryX = targetSide === 'right' ? targetNode.x + targetNode.width + margin : targetNode.x - margin;
          const midY = startY + (endY - startY) / 2;
          segments.push(`L ${exitX} ${startY}`);
          segments.push(`L ${exitX} ${midY}`);
          segments.push(`L ${entryX} ${midY}`);
          segments.push(`L ${entryX} ${endY}`);
        } else {
          const verticalDirection = endY >= startY ? 1 : -1;
          const exitY = verticalDirection > 0
            ? Math.max(startY + margin, sourceNode.y + sourceNode.height + margin)
            : Math.min(startY - margin, sourceNode.y - margin);
          const entryY = verticalDirection > 0
            ? Math.min(endY - margin, targetNode.y - margin)
            : Math.max(endY + margin, targetNode.y + targetNode.height + margin);
          const midX = startX + (endX - startX) / 2;
          segments.push(`L ${startX} ${exitY}`);
          segments.push(`L ${midX} ${exitY}`);
          segments.push(`L ${midX} ${entryY}`);
          segments.push(`L ${endX} ${entryY}`);
        }
        segments.push(`L ${endX} ${endY}`);
        const path = segments.join(' ');
        const labelX = (startX + endX) / 2;
        const labelY = (startY + endY) / 2 - 6;
        return { path, labelX, labelY };
      }

      render(state){
        if(!this.svg || !this.viewport) return;
        this.lastState = state;
        const tables = Array.isArray(state?.tables) ? state.tables : [];
        const relations = Array.isArray(state?.relations) ? state.relations : [];
        const layout = state?.layout || {};
        const selection = state?.selection || {};
        const palette = state?.palette || {};
        const zoom = state?.zoom;

        this.clear();
        console.debug('[Mishkah][ERD] SVG driver render', tables.length, 'tables');

        const svgNS = 'http://www.w3.org/2000/svg';
        if(this.defs && typeof this.defs.querySelectorAll === 'function'){
          const dynamicDefs = Array.from(this.defs.querySelectorAll('clipPath[data-m-erd-dynamic="true"]'));
          dynamicDefs.forEach(def => def.remove());
        }
        const nodes = tables.map((table, index)=>{
          const total = Math.max(1, tables.length);
          const fallback = computeGridPosition(index, total);
          const source = layout[table.id] || layout[table.name];
          const { x, y } = normalisePoint(source, fallback);
          const fields = Array.isArray(table.fields) ? table.fields : [];
          const width = TABLE_WIDTH;
          const height = computeTableHeight(fields.length);
          const fieldMap = new Map();
          fields.forEach((field, idx)=>{
            const centerY = HEADER_HEIGHT + ROW_HEIGHT * idx + ROW_HEIGHT / 2;
            fieldMap.set(field.name, centerY);
          });
          return {
            id: table.id,
            table,
            x,
            y,
            width,
            height,
            fields,
            fieldMap
          };
        });

        const bbox = this.computeBoundingBox(nodes);
        this.setViewBox(bbox, zoom, 120);

        const edgesGroup = document.createElementNS(svgNS, 'g');
        edgesGroup.setAttribute('class', 'm-erd-edges');
        const nodesGroup = document.createElementNS(svgNS, 'g');
        nodesGroup.setAttribute('class', 'm-erd-nodes');

        const colors = {
          tableStroke: palette.border || '#1f2a3d',
          tableFill: palette.card || '#111d30',
          headerFill: palette.primary || '#2563eb',
          headerText: palette.primaryForeground || '#f8fafc',
          headerSubtle: palette.primaryForeground ? `${palette.primaryForeground}cc` : '#e2e8f0cc',
          fieldText: palette.foreground || '#f8fafc',
          fieldType: palette.muted || '#94a3b8',
          rowEven: palette.surface || '#0f172a',
          rowOdd: palette.card || '#111d30',
          badge: palette.accentForeground || '#102341',
          edge: palette.accentForeground || '#60a5fa',
          background: palette.surface || '#101a2c'
        };

        const nodeLookup = new Map();

        this.nodeCache.clear();

        nodes.forEach(node => {
          nodeLookup.set(node.id, node);
          this.nodeCache.set(node.id, node);
          const group = document.createElementNS(svgNS, 'g');
          group.setAttribute('data-node-id', node.id);
          group.setAttribute('transform', `translate(${node.x} ${node.y})`);

          const body = document.createElementNS(svgNS, 'rect');
          body.setAttribute('x', '0');
          body.setAttribute('y', '0');
          body.setAttribute('width', String(node.width));
          body.setAttribute('height', String(node.height));
          body.setAttribute('rx', '18');
          body.setAttribute('ry', '18');
          body.setAttribute('fill', colors.tableFill);
          body.setAttribute('stroke', selection.table === node.id ? (palette.primary || '#60a5fa') : colors.tableStroke);
          body.setAttribute('stroke-width', selection.table === node.id ? '2.6' : '1.8');

          const headerHeight = Math.max(HEADER_HEIGHT, 48);
          const header = document.createElementNS(svgNS, 'rect');
          header.setAttribute('x', '0');
          header.setAttribute('y', '0');
          header.setAttribute('width', String(node.width));
          header.setAttribute('height', String(headerHeight));
          header.setAttribute('rx', '18');
          header.setAttribute('ry', '18');
          header.setAttribute('fill', colors.headerFill);

          const headerClip = document.createElementNS(svgNS, 'clipPath');
          const clipId = `m-erd-clip-${String(node.id).replace(/[^a-zA-Z0-9_-]/g, '_')}`;
          if(this.defs){
            headerClip.setAttribute('id', clipId);
            headerClip.setAttribute('data-m-erd-dynamic', 'true');
            const clipRect = document.createElementNS(svgNS, 'rect');
            clipRect.setAttribute('x', '0');
            clipRect.setAttribute('y', '0');
            clipRect.setAttribute('width', String(node.width));
            clipRect.setAttribute('height', String(node.height));
            clipRect.setAttribute('rx', '18');
            clipRect.setAttribute('ry', '18');
            headerClip.appendChild(clipRect);
            this.defs.appendChild(headerClip);
          }

          const tableMeta = node.table || {};
          const title = document.createElementNS(svgNS, 'text');
          title.setAttribute('x', '20');
          title.setAttribute('y', '28');
          title.setAttribute('fill', colors.headerText);
          title.setAttribute('font-size', '14');
          title.setAttribute('font-weight', '700');
          title.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
          title.textContent = truncateText(tableMeta.displayName || tableMeta.label || tableMeta.name || node.id, 26);
          title.setAttribute('clip-path', `url(#${clipId})`);

          let subtitleNode = null;
          if(tableMeta.label && tableMeta.label !== tableMeta.name){
            subtitleNode = document.createElementNS(svgNS, 'text');
            subtitleNode.setAttribute('x', '20');
            subtitleNode.setAttribute('y', '44');
            subtitleNode.setAttribute('fill', colors.headerSubtle);
            subtitleNode.setAttribute('font-size', '11');
            subtitleNode.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            subtitleNode.setAttribute('clip-path', `url(#${clipId})`);
            subtitleNode.textContent = truncateText(tableMeta.label, 32);
          }

          const contentTop = headerHeight;
          const rowsGroup = document.createElementNS(svgNS, 'g');

          node.fields.forEach((field, idx)=>{
            const rowTop = contentTop + ROW_HEIGHT * idx;
            const rowRect = document.createElementNS(svgNS, 'rect');
            rowRect.setAttribute('x', '0');
            rowRect.setAttribute('y', String(rowTop));
            rowRect.setAttribute('width', String(node.width));
            rowRect.setAttribute('height', String(ROW_HEIGHT));
            rowRect.setAttribute('fill', idx % 2 === 0 ? colors.rowEven : colors.rowOdd);

            const display = field.display || buildFieldDisplay(field);
            const baseY = rowTop + ROW_HEIGHT / 2 + 1;

            const nameText = document.createElementNS(svgNS, 'text');
            nameText.setAttribute('x', display.badges ? '40' : '20');
            nameText.setAttribute('y', String(baseY));
            nameText.setAttribute('fill', colors.fieldText);
            nameText.setAttribute('font-size', '12');
            nameText.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            nameText.setAttribute('dominant-baseline', 'middle');
            nameText.setAttribute('font-weight', field.pk ? '700' : '500');
            nameText.textContent = display.label || field.name;

            if(display.badges){
              const badgeText = document.createElementNS(svgNS, 'text');
              badgeText.setAttribute('x', '20');
              badgeText.setAttribute('y', String(baseY));
              badgeText.setAttribute('fill', colors.badge);
              badgeText.setAttribute('font-size', '11');
              badgeText.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
              badgeText.setAttribute('dominant-baseline', 'middle');
              badgeText.textContent = display.badges;
              rowsGroup.appendChild(badgeText);
            }

            const typeText = document.createElementNS(svgNS, 'text');
            typeText.setAttribute('x', String(node.width - 20));
            typeText.setAttribute('y', String(baseY));
            typeText.setAttribute('fill', colors.fieldType);
            typeText.setAttribute('font-size', '11');
            typeText.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            typeText.setAttribute('dominant-baseline', 'middle');
            typeText.setAttribute('text-anchor', 'end');
            typeText.textContent = display.type || field.type || '';

            rowsGroup.appendChild(rowRect);
            rowsGroup.appendChild(nameText);
            rowsGroup.appendChild(typeText);
          });

          group.appendChild(body);
          group.appendChild(header);
          group.appendChild(title);
          if(subtitleNode) group.appendChild(subtitleNode);
          group.appendChild(rowsGroup);
          this.attachNodeInteractions(group, node);
          nodesGroup.appendChild(group);
        });

        relations.forEach(rel => {
          const sourceNode = nodeLookup.get(rel.from?.table || rel.source?.table || '');
          const targetNode = nodeLookup.get(rel.to?.table || rel.target?.table || '');
          if(!sourceNode || !targetNode) return;
          const sourceFieldName = rel.from?.field || rel.source?.field;
          const targetFieldName = rel.to?.field || rel.target?.field;
          const edgeId = rel.id || `${sourceNode.id}:${sourceFieldName}→${targetNode.id}:${targetFieldName}`;
          const meta = {
            id: edgeId,
            path: null,
            label: null,
            sourceNode: sourceNode.id,
            targetNode: targetNode.id,
            sourceField: sourceFieldName,
            targetField: targetFieldName,
            sourceSide: rel.from?.side || (rel.from?.port?.endsWith(':left') ? 'left' : 'right'),
            targetSide: rel.to?.side || (rel.to?.port?.endsWith(':right') ? 'right' : 'left')
          };
          const geometry = this.computeEdgeGeometry(meta);
          const path = document.createElementNS(svgNS, 'path');
          path.setAttribute('d', geometry ? geometry.path : `M ${sourceNode.x} ${sourceNode.y} L ${targetNode.x} ${targetNode.y}`);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', colors.edge);
          path.setAttribute('stroke-width', '1.8');
          path.setAttribute('marker-end', 'url(#m-erd-arrow)');
          path.setAttribute('style', `color:${colors.edge}`);
          path.setAttribute('data-edge-id', edgeId);
          edgesGroup.appendChild(path);

          if(rel.cardinality){
            const label = document.createElementNS(svgNS, 'text');
            const labelX = geometry ? geometry.labelX : (sourceNode.x + targetNode.x) / 2;
            const labelY = geometry ? geometry.labelY : (sourceNode.y + targetNode.y) / 2 - 6;
            label.setAttribute('x', String(labelX));
            label.setAttribute('y', String(labelY));
            label.setAttribute('fill', colors.fieldText);
            label.setAttribute('font-size', '11');
            label.setAttribute('font-weight', '600');
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            label.textContent = rel.cardinality;
            edgesGroup.appendChild(label);
            meta.label = label;
          } else {
            meta.label = null;
          }
          meta.path = path;
          this.edgeCache.set(edgeId, meta);
        });

        this.viewport.appendChild(edgesGroup);
        this.viewport.appendChild(nodesGroup);
      }

      fitToScreen(padding = 16){
        this.overrideFitPadding = padding;
        if(this.lastState){
          this.render(this.lastState);
        }
      }

      undo(){}
      redo(){}

      async exportSVG(){
        if(!this.svg) return '<svg />';
        const serializer = new XMLSerializer();
        return serializer.serializeToString(this.svg);
      }

      async exportPNG(opts = {}){
        if(!this.svg) return new Blob();
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(this.svg);
        const svgBlob = new Blob([svgString], { type:'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);
        try {
          const image = new Image();
          const width = opts.width || this.wrapper?.clientWidth || 1600;
          const height = opts.height || this.wrapper?.clientHeight || 900;
          await new Promise((resolve, reject)=>{
            image.onload = resolve;
            image.onerror = reject;
            image.src = url;
          });
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          if(opts.background){
            ctx.fillStyle = opts.background;
            ctx.fillRect(0, 0, width, height);
          }
          ctx.drawImage(image, 0, 0, width, height);
          const blob = await new Promise((resolve, reject)=>{
            canvas.toBlob(result => {
              if(result) resolve(result);
              else reject(new Error('Failed to export PNG'));
            });
          });
          return blob;
        } finally {
          URL.revokeObjectURL(url);
        }
      }

      destroy(){
        if(this.container) this.container.innerHTML = '';
        this.container = null;
        this.svg = null;
        this.viewport = null;
        this.wrapper = null;
        this.defs = null;
        this.lastState = null;
        this.baseBBox = null;
        this.overrideFitPadding = null;
        this.nodeCache.clear();
        this.edgeCache.clear();
      }
    }

    class X6Driver {
      constructor(){
        this.graph = null;
        this.hooks = null;
        this.initialized = false;
      }

      init(container, hooks){
        this.hooks = hooks || {};
        const Graph = window?.X6?.Graph;
        if(!Graph){
          console.warn('[Mishkah][ERD] AntV X6 Graph not available, falling back to FakeDriver');
          throw new Error('X6 not available');
        }
        this.graph = new Graph({
          container,
          grid: true,
          scroller: { enabled: true, pannable: true, minScale: MIN_CANVAS_ZOOM, maxScale: MAX_CANVAS_ZOOM },
          mousewheel: { enabled: true, modifiers: ['ctrl','meta'], minScale: MIN_CANVAS_ZOOM, maxScale: MAX_CANVAS_ZOOM },
          history: { enabled: true },
          selecting: { enabled: true, multiple: true, rubberband: true },
          keyboard: { enabled: true },
          clipboard: { enabled: true },
          snapline: { enabled: true },
          connecting: {
            allowBlank: false,
            allowLoop: false,
            snap: true,
            router: { name: 'manhattan' },
            connector: { name: 'rounded' },
            validateConnection: ({ sourceMagnet, targetMagnet }) => !!(sourceMagnet && targetMagnet),
          },
        });

        this.graph.on('node:change:position', ({ node }) => {
          const { x, y } = node.getPosition();
          this.hooks?.onNodeMove?.({ id: String(node.id), x, y });
        });

        this.graph.on('selection:changed', ({ selected }) => {
          if(!selected) return;
          const ids = selected
            .filter(cell => cell && typeof cell.isNode === 'function' && cell.isNode())
            .map(cell => String(cell.id));
          this.hooks?.onSelect?.(ids);
        });

        this.graph.on('edge:connected', ({ edge, isNew }) => {
          if(!edge) return;
          const meta = edge.getData ? edge.getData() : null;
          if(meta?.hydrated){
            edge.setData({ ...meta, hydrated: false });
            return;
          }
          if(isNew === false) return;
          const source = edge.getSource();
          const target = edge.getTarget();
          if(!source || !target) return;
          this.hooks?.onEdgeConnect?.({
            source: { id: String(source.cell), port: String(source.port) },
            target: { id: String(target.cell), port: String(target.port) },
          });
        });
      }

      render(state){
        if(!this.graph) return;
        const layout = state?.layout || {};
        const tables = Array.isArray(state?.tables) ? state.tables : [];
        const relations = Array.isArray(state?.relations) ? state.relations : [];
        const nodes = tables.map((tbl, index) => {
          const total = Math.max(1, tables.length);
          const fallback = computeGridPosition(index, total);
          const { x, y } = normalisePoint(layout[tbl.id], fallback);
          const position = { x, y };
          const fields = Array.isArray(tbl.fields) ? tbl.fields : [];
          const headerLabel = tbl.displayName || tbl.label || tbl.name || tbl.id;
          const subtitle = tbl.label && tbl.label !== tbl.name ? ` (${tbl.label})` : '';
          const headerLine = truncateText(`${headerLabel}${subtitle}`, 42);
          const fieldLines = fields.map(field => {
            const display = field.display || buildFieldDisplay(field);
            const badges = display.badges ? `${display.badges} ` : '';
            const type = display.type ? ` · ${display.type}` : '';
            return `${badges}${display.label || field.name}${type}`;
          });
          const bodyText = [headerLine, ...fieldLines].join('\n');
          const height = computeTableHeight(fields.length);
          const portItems = fields.flatMap((field, idx) => {
            const yOffset = HEADER_HEIGHT + ROW_HEIGHT * idx + ROW_HEIGHT / 2;
            const portBase = `${tbl.id}:${field.name}`;
            return [
              {
                id: `${portBase}:left`,
                group: 'in',
                attrs: {
                  circle: {
                    title: `${field.name}${field.type ? ` (${field.type})` : ''}`,
                  },
                },
                args: { x: 0, y: yOffset },
              },
              {
                id: `${portBase}:right`,
                group: 'out',
                attrs: {
                  circle: {
                    title: `${field.name}${field.type ? ` (${field.type})` : ''}`,
                  },
                },
                args: { x: TABLE_WIDTH, y: yOffset },
              },
            ];
          });
          return {
            id: tbl.id,
            shape: 'rect',
            x: position.x,
            y: position.y,
            width: TABLE_WIDTH,
            height,
            data: { hydrated: true },
            attrs: {
              body: {
                fill: '#111d30',
                stroke: '#1f2a3d',
                rx: 18,
                ry: 18,
              },
              label: {
                text: bodyText,
                fill: '#f8fafc',
                fontSize: 12,
                fontWeight: 500,
                lineHeight: 1.35,
                textAnchor: 'start',
                refX: 16,
                refY: 22,
                textWrap: {
                  width: TABLE_WIDTH - 32,
                  height: height - 32,
                  ellipsis: true,
                  breakWord: true,
                },
              },
            },
            ports: {
              groups: {
                in: {
                  position: { name: 'absolute' },
                  attrs: { circle: { r: 4, magnet: true, stroke: 'transparent', fill: 'transparent' } },
                },
                out: {
                  position: { name: 'absolute' },
                  attrs: { circle: { r: 4, magnet: true, stroke: 'transparent', fill: 'transparent' } },
                },
              },
              items: portItems,
            },
          };
        });

        const edges = relations.map(rel => ({
          id: rel.id || `${rel.from.table}:${rel.from.field}→${rel.to.table}:${rel.to.field}`,
          shape: 'edge',
          source: { cell: rel.from.table, port: rel.from.port || `${rel.from.table}:${rel.from.field}:right` },
          target: { cell: rel.to.table, port: rel.to.port || `${rel.to.table}:${rel.to.field}:left` },
          router: { name: 'manhattan' },
          connector: { name: 'rounded' },
          attrs: { line: { stroke: '#0284c7', strokeWidth: 1.6 } },
          labels: rel.cardinality || rel.onDelete || rel.onUpdate ? [
            {
              attrs: {
                label: {
                  text: rel.cardinality || '1..*',
                  fill: '#0f172a',
                  background: {
                    fill: '#f8fafc',
                    stroke: '#94a3b8',
                    padding: 2,
                  },
                },
              },
            },
          ] : [],
          data: { hydrated: true },
        }));

        this.graph.fromJSON({ cells: [...nodes, ...edges] });

        const selection = state?.selection;
        if(selection?.table){
          const node = this.graph.getCellById(selection.table);
          if(node){
            this.graph.resetSelection(node);
          }
        }

        if(typeof state?.zoom === 'number' && Number.isFinite(state.zoom)){
          const safeZoom = Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, state.zoom));
          try { this.graph.zoomTo(safeZoom); }
          catch(error){ console.warn('[Mishkah][ERD] zoomTo failed', error); }
        }

        if(state?.canvasMode !== 'manual'){
          try { this.graph.centerContent(); }
          catch(error){ console.warn('[Mishkah][ERD] centerContent failed', error); }
        }

        if(!this.initialized){
          this.initialized = true;
        }
      }

      fitToScreen(padding = 16){
        if(!this.graph) return;
        this.graph.scaleContentToFit({ padding });
      }

      undo(){
        if(!this.graph) return;
        this.graph.history?.undo();
      }

      redo(){
        if(!this.graph) return;
        this.graph.history?.redo();
      }

      async exportSVG(){
        if(!this.graph) return '<svg />';
        return this.graph.toSVG({ preserveDimensions: true });
      }

      async exportPNG(opts = {}){
        if(!this.graph) return new Blob();
        const dataUrl = await this.graph.toPNG({
          backgroundColor: opts.background || '#ffffff',
          padding: 16,
          quality: 1,
        });
        const response = await fetch(dataUrl);
        return await response.blob();
      }

      destroy(){
        if(this.graph){
          this.graph.dispose();
          this.graph = null;
        }
      }
    }

    const DiagramDrivers = {
      fake: SvgDriver,
      x6: X6Driver,
    };

    function sanitizeSqlIdentifier(value){
      if(!value) return '';
      const snake = Schema.utils.toSnakeCase(value || '') || '';
      return snake
        .replace(/[^a-z0-9_]/g, '')
        .replace(/_{2,}/g, '_')
        .replace(/^_+|_+$/g, '')
        .slice(0, 64);
    }

    function identifierFromLabel(label, fallback){
      const sanitized = sanitizeSqlIdentifier(label || '');
      if(sanitized) return sanitized;
      if(Text && typeof Text.identifierFromArabic === 'function'){
        const derived = sanitizeSqlIdentifier(Text.identifierFromArabic(label, { fallback }));
        if(derived) return derived;
      }
      const fallbackBase = sanitizeSqlIdentifier(fallback || 'item');
      return fallbackBase || (fallback || 'item');
    }

    function formatIdentifier(value){
      if(!value) return '';
      return value
        .replace(/_/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/(^|\s)([a-z])/g, (_, space, ch)=> space + ch.toUpperCase());
    }

    function ensureUniqueTableName(registry, base){
      const clean = base || 'table';
      let candidate = clean;
      let index = 1;
      while(registry.get(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function ensureUniqueFieldName(table, base){
      const clean = base || 'field';
      if(!table) return clean;
      let candidate = clean;
      let index = 1;
      while(table.getField(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function computeTableIdentifier(registry, source){
      const fallback = `table_${registry.list().length + 1}`;
      const base = sanitizeSqlIdentifier(source || '') || identifierFromLabel(source, fallback);
      return ensureUniqueTableName(registry, base);
    }

    function computeFieldIdentifier(table, label){
      const fallback = `field_${(table?.fields?.length || 0) + 1}`;
      const base = identifierFromLabel(label, fallback);
      return ensureUniqueFieldName(table, base);
    }

    function currentPalette(){
      if(typeof window === 'undefined') return {};
      const computed = getComputedStyle(document.documentElement);
      const read = key => (computed.getPropertyValue(key) || '').trim();
      return {
        background: read('--background') || '#f8fafc',
        surface: read('--surface-2') || '#eef2ff',
        border: read('--border') || '#d7deed',
        foreground: read('--foreground') || '#0f172a',
        muted: read('--muted-foreground') || '#475569',
        accent: read('--accent') || '#eaf2ff',
        accentForeground: read('--accent-foreground') || '#102341',
        primary: read('--primary') || '#2563eb',
        primaryForeground: read('--primary-foreground') || '#f8fafc'
      };
    }

    function buildDriverStateSnapshot(state, host){
      const registry = getRegistry(state);
      const layout = computeLayout(registry, state.data.layout);
      const tables = registry.list().map(table => ({
        id: table.name,
        name: table.name,
        label: table.label || '',
        displayName: formatIdentifier(table.name),
        fields: (table.fields || []).map(field => ({
          name: field.name,
          type: field.type,
          pk: !!field.primaryKey,
          unique: !!field.unique,
          nullable: field.nullable !== false,
          default: field.defaultValue,
          references: field.references || null,
          index: !!field.index,
          display: buildFieldDisplay({
            name: field.name,
            type: field.type,
            pk: !!field.primaryKey,
            unique: !!field.unique,
            nullable: field.nullable !== false,
            references: field.references,
            index: !!field.index
          }),
        })),
      }));
      const relations = [];
      registry.list().forEach(table => {
        (table.fields || []).forEach(field => {
          if(field.references && field.references.table){
            relations.push({
              id: `${table.name}:${field.name}→${field.references.table}:${field.references.column || field.references.field || 'id'}`,
              from: {
                table: table.name,
                field: field.name,
                port: `${table.name}:${field.name}:right`,
                side: 'right'
              },
              to: {
                table: field.references.table,
                field: field.references.column || field.references.field || 'id',
                port: `${field.references.table}:${field.references.column || field.references.field || 'id'}:left`,
                side: 'left'
              },
              cardinality: field.references.cardinality || '',
              onDelete: field.references.onDelete,
              onUpdate: field.references.onUpdate,
            });
          }
        });
      });
      const nodesMeta = tables.map((table, index) => {
        const total = Math.max(1, tables.length);
        const fallback = computeGridPosition(index, total);
        const point = layout[table.id] || layout[table.name];
        const { x, y } = normalisePoint(point, fallback);
        return {
          id: table.id,
          x,
          y,
          width: TABLE_WIDTH,
          height: computeTableHeight(table.fields.length),
        };
      });
      const bounds = computeLayoutBounds(nodesMeta);
      const canvasState = normaliseCanvas(state.data.canvas);
      const canvasMode = canvasState.mode || 'auto';
      const storedZoom = canvasState.zoom || 1;
      let zoom = storedZoom;
      if(canvasMode !== 'manual'){
        const viewportWidth = host?.clientWidth || (typeof window !== 'undefined' ? window.innerWidth : 0);
        const viewportHeight = host?.clientHeight || (typeof window !== 'undefined' ? window.innerHeight : 0);
        zoom = recommendZoomForBounds(bounds, viewportWidth, viewportHeight);
      }
      return {
        tables,
        relations,
        layout,
        selection: state.data.selection || {},
        zoom,
        canvasMode,
        storedZoom,
        bounds,
      };
    }

    function scheduleDiagramRender(state){
      lastDiagramState = state;
      if(pendingDiagramFrame) return;
      pendingDiagramFrame = true;
      requestAnimationFrame(()=>{
        pendingDiagramFrame = false;
        const snapshot = erdAppInstance ? erdAppInstance.getState() : lastDiagramState;
        if(snapshot) renderDiagram(snapshot);
      });
    }

    function ensureDriverInstance(state){
      if(typeof window === 'undefined') return null;
      const host = document.getElementById('erd-diagram');
      if(!host) return null;
      const driverKey = (state?.env?.graph?.driver || 'fake').toLowerCase();
      if(erdDriver && activeDriverName === driverKey){
        return erdDriver;
      }
      if(erdDriver){
        try { erdDriver.destroy(); }
        catch(error){ console.warn('[Mishkah][ERD] driver destroy failed', error); }
        erdDriver = null;
      }
      const DriverCtor = DiagramDrivers[driverKey] || DiagramDrivers.fake;
      try {
        const instance = new DriverCtor();
        instance.init(host, {
          onNodeMove: handleDriverNodeMove,
          onSelect: handleDriverSelect,
          onEdgeConnect: handleDriverEdgeConnect,
        });
        erdDriver = instance;
        activeDriverName = driverKey;
        host.setAttribute('data-driver', driverKey);
        return erdDriver;
      } catch(error){
        console.warn('[Mishkah][ERD] failed to initialise driver', driverKey, error);
        if(driverKey !== 'fake'){
          try {
            const fallback = new SvgDriver();
            fallback.init(host, {
              onNodeMove: handleDriverNodeMove,
              onSelect: handleDriverSelect,
              onEdgeConnect: handleDriverEdgeConnect,
            });
            erdDriver = fallback;
            activeDriverName = 'fake';
            host.setAttribute('data-driver', 'fake');
            return erdDriver;
          } catch(fallbackError){
            console.error('[Mishkah][ERD] failed to initialise FakeDriver', fallbackError);
          }
        }
        return null;
      }
    }

    function renderDiagram(state){
      if(!state || typeof window === 'undefined') return;
      const host = document.getElementById('erd-diagram');
      if(!host) return;
      const driver = ensureDriverInstance(state);
      if(!driver) return;
      const payload = buildDriverStateSnapshot(state, host);
      if(layoutsDiffer(state.data.layout, payload.layout)){
        erdAppInstance.setState(s => ({
          ...s,
          data:{
            ...s.data,
            layout: payload.layout,
          },
        }));
        erdAppInstance.rebuild();
      }
      const palette = currentPalette();
      payload.palette = palette;
      host.style.background = palette.background || '#f8fafc';
      if(payload.canvasMode !== 'manual' && Math.abs(payload.zoom - (payload.storedZoom || 0)) > 0.01){
        applyAutoZoom(payload.zoom);
      }
      try {
        driver.render(payload);
      } catch(error){
        console.warn('[Mishkah][ERD] driver render failed', error);
      }
    }

    function extractFieldFromPort(portId){
      if(!portId) return '';
      const parts = String(portId).split(':');
      if(parts.length <= 1) return parts[0] || '';
      const fieldParts = parts.slice(1);
      if(fieldParts.length > 1){
        const last = fieldParts[fieldParts.length - 1];
        if(last === 'left' || last === 'right') fieldParts.pop();
      }
      return fieldParts.join(':');
    }

    function handleDriverNodeMove(position){
      if(!erdAppInstance || !position) return;
      const id = String(position.id || '');
      if(!id) return;
      const x = Math.round(Number(position.x) || 0);
      const y = Math.round(Number(position.y) || 0);
      let persistRecord = null;
      erdAppInstance.setState(s => {
        const layout = Object.assign({}, s.data.layout || {});
        const current = layout[id] || {};
        if(current.x === x && current.y === y){
          return s;
        }
        layout[id] = { x, y };
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: s.data.schema,
          layout,
          canvas: s.data.canvas,
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now,
        };
        persistRecord = record;
        return {
          ...s,
          data:{
            ...s.data,
            layout,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) },
          },
          ui:{
            ...(s.ui || {}),
            form:{
              ...(s.ui?.form || {}),
              layout:{ x, y },
            },
          },
        };
      });
      erdAppInstance.rebuild();
      if(persistRecord){
        schedulePersist(persistRecord);
      }
    }

    function handleDriverSelect(ids){
      if(!erdAppInstance) return;
      const list = Array.isArray(ids) ? ids : [];
      if(!list.length) return;
      const tableName = list[0];
      if(!tableName) return;
      erdAppInstance.setState(s => withTableSelection(s, tableName));
      erdAppInstance.rebuild();
    }

    function handleDriverEdgeConnect(connection){
      if(!erdAppInstance || !connection) return;
      const sourceTable = connection.source?.id ? String(connection.source.id) : '';
      const targetTable = connection.target?.id ? String(connection.target.id) : '';
      const sourceField = extractFieldFromPort(connection.source?.port);
      const targetField = extractFieldFromPort(connection.target?.port);
      if(!sourceTable || !sourceField || !targetTable || !targetField) return;
      let persistRecord = null;
      erdAppInstance.setState(s => {
        const registry = Schema.Registry.fromJSON(s.data.schema);
        const table = registry.get(sourceTable);
        if(!table) return s;
        const field = table.getField(sourceField);
        if(!field) return s;
        const currentRefs = field.references || {};
        try {
          table.updateField(sourceField, {
            references:{
              table: targetTable,
              column: targetField,
              onDelete: currentRefs.onDelete || 'CASCADE',
              onUpdate: currentRefs.onUpdate || 'CASCADE',
              cardinality: currentRefs.cardinality,
            },
          });
        } catch(error){
          console.warn('[Mishkah][ERD] failed to apply edge connection', error);
          return s;
        }
        const schemaJSON = registry.toJSON();
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: schemaJSON,
          layout: s.data.layout,
          canvas: s.data.canvas,
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now,
        };
        persistRecord = record;
        let draft = {
          ...s,
          data:{
            ...s.data,
            schema: schemaJSON,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) },
          },
        };
        draft = withFieldSelection(draft, sourceTable, sourceField);
        return draft;
      });
      erdAppInstance.rebuild();
      if(persistRecord){
        schedulePersist(persistRecord);
      }
    }


    const SchemaLibrary = (function(){
      const storeName = 'schemas';
      const AdapterClass = (U && (U.IndexedDBX || U.IndexedDB)) || null;
      const hasIndexedDB = typeof indexedDB !== 'undefined' && !!AdapterClass;
      const adapter = hasIndexedDB ? new AdapterClass({
        name:'mishkah-erd',
        version:1,
        schema:{
          stores:{
            [storeName]:{
              keyPath:'id',
              autoIncrement:false,
              indexes:{
                by_name:{ keyPath:'name', unique:true },
                by_updatedAt:{ keyPath:'updatedAt' },
                by_createdAt:{ keyPath:'createdAt' }
              }
            }
          }
        }
      }) : null;
      const memory = new Map();
      const status = hasIndexedDB ? 'indexeddb' : 'memory';

      const SEED_SCHEMA = {
        id:'schema_seed',
        name:'commerce_schema',
        title:'مخطط متجر إلكتروني',
        description:'مخطط افتراضي يوضح علاقة العملاء بالطلبات والمخزون والمدفوعات.',
        tables:[
          {
            name:'customers',
            label:'العملاء',
            layout:{ x:120, y:160 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'full_name', type:'string', nullable:false, maxLength:180, comment:'اسم العميل الكامل' },
              { name:'email', type:'string', nullable:false, unique:true, comment:'بريد إلكتروني فريد لكل عميل' },
              { name:'phone_number', type:'string', nullable:true, comment:'رقم للتواصل' },
              { name:'created_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'orders',
            label:'الطلبات',
            layout:{ x:420, y:160 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_number', type:'string', nullable:false, unique:true, comment:'رقم الطلب الظاهر للعميل' },
              { name:'customer_id', type:'uuid', nullable:false, references:{ table:'customers', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'status', type:'string', nullable:false, defaultValue:'pending', enum:['pending','processing','shipped','completed','cancelled'] },
              { name:'total_amount', type:'decimal', nullable:false, precision:12, scale:2 },
              { name:'placed_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'order_items',
            label:'بنود الطلبات',
            layout:{ x:720, y:200 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_id', type:'uuid', nullable:false, references:{ table:'orders', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'product_id', type:'uuid', nullable:false, references:{ table:'products', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'quantity', type:'integer', nullable:false, defaultValue:1 },
              { name:'unit_price', type:'decimal', nullable:false, precision:10, scale:2 },
              { name:'line_total', type:'decimal', nullable:false, precision:12, scale:2 }
            ]
          },
          {
            name:'products',
            label:'المنتجات',
            layout:{ x:420, y:360 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'name', type:'string', nullable:false, maxLength:160 },
              { name:'sku', type:'string', nullable:false, unique:true, comment:'معرّف فريد للمخزون' },
              { name:'price', type:'decimal', nullable:false, precision:10, scale:2 },
              { name:'stock_quantity', type:'integer', nullable:false, defaultValue:0 },
              { name:'category_id', type:'uuid', nullable:true, references:{ table:'categories', column:'id', onDelete:'SET NULL', onUpdate:'CASCADE' } },
              { name:'created_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'categories',
            label:'التصنيفات',
            layout:{ x:120, y:360 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'name', type:'string', nullable:false, unique:true },
              { name:'description', type:'text', nullable:true }
            ]
          },
          {
            name:'payments',
            label:'المدفوعات',
            layout:{ x:720, y:360 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_id', type:'uuid', nullable:false, references:{ table:'orders', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'payment_method', type:'string', nullable:false },
              { name:'paid_amount', type:'decimal', nullable:false, precision:12, scale:2 },
              { name:'paid_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          }
        ]
      };

      function buildSeedRecord(){
        const registry = new Schema.Registry({ tables: SEED_SCHEMA.tables });
        const tables = registry.list();
        const layout = {};
        tables.forEach((table, index) => {
          const fallback = computeGridPosition(index, tables.length);
          const source = table.layout || {};
          layout[table.name] = normalisePoint(source, fallback);
        });
        const now = Date.now();
        return {
          id: SEED_SCHEMA.id,
          name: SEED_SCHEMA.name,
          title: SEED_SCHEMA.title,
          description: SEED_SCHEMA.description,
          schema: registry.toJSON(),
          layout,
          canvas:{ zoom:1, mode:'auto' },
          createdAt: now,
          updatedAt: now
        };
      }

      function normalize(input, { bumpUpdatedAt=true }={}){
        const now = Date.now();
        const id = input.id || U.Id.uid('schema');
        const name = (input.name || '').trim() || `schema_${id.slice(-4)}`;
        const title = (input.title || '').trim() || name;
        const description = (input.description || '').trim();
        const schema = clone(input.schema || { tables: [] });
        const layout = clone(input.layout || {});
        const canvas = normaliseCanvas(clone(input.canvas || {}));
        const createdAt = input.createdAt || now;
        const updatedAt = bumpUpdatedAt ? now : (input.updatedAt || now);
        return { id, name, title, description, schema, layout, canvas, createdAt, updatedAt };
      }

      async function ready(){
        if(adapter && adapter.ensureSchema){
          try { await adapter.ensureSchema(); }
          catch(error){ console.warn('[Mishkah][ERD] failed to ensure schema store', error); }
        }
        return true;
      }

      async function save(input, opts={}){
        const record = normalize(input, opts);
        if(adapter){
          try { await adapter.put(storeName, record); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB save failed', error); }
        }
        memory.set(record.id, clone(record));
        return clone(record);
      }

      async function get(id){
        if(!id) return null;
        if(adapter){
          try {
            const row = await adapter.get(storeName, id);
            if(row){
              memory.set(row.id, clone(row));
              return clone(row);
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB get failed', error);
          }
        }
        const existing = memory.get(id);
        return existing ? clone(existing) : null;
      }

      async function list(){
        if(adapter){
          try {
            const rows = await adapter.getAll(storeName);
            if(Array.isArray(rows)){
              rows.forEach(row => memory.set(row.id, clone(row)));
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB list failed', error);
          }
        }
        const out = Array.from(memory.values()).map(item => clone(item));
        out.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
        return out;
      }

      async function remove(id){
        if(!id) return false;
        if(adapter){
          try { await adapter.delete(storeName, id); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB delete failed', error); }
        }
        memory.delete(id);
        return true;
      }

      async function createBlank(meta={}){
        return save({
          id: meta.id,
          name: meta.name || '',
          title: meta.title || meta.name || 'مخطط جديد',
          description: meta.description || '',
          schema: new Schema.Registry().toJSON(),
          layout:{},
          canvas:{ zoom:1, mode:'auto' },
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
      }

      async function createSeed(){
        const seed = buildSeedRecord();
        return save(seed, { bumpUpdatedAt:false });
      }

      return { status, available:true, ready, save, get, list, remove, createBlank, createSeed };
    })();

    await SchemaLibrary.ready();

    let libraryItems = await SchemaLibrary.list();
    if(!libraryItems.length){
      const seedRecord = await SchemaLibrary.createSeed();
      libraryItems = [seedRecord];
    }

    const activeRecord = libraryItems[0];
    const activeRegistry = Schema.Registry.fromJSON(activeRecord.schema || { tables: [] });

    function computeLayout(registry, layout){
      const map = Object.assign({}, layout || {});
      const tables = registry.list();
      const total = Math.max(1, tables.length);
      tables.forEach((table, index)=>{
        const fallback = computeGridPosition(index, total);
        if(map[table.name]){
          map[table.name] = normalisePoint(map[table.name], fallback);
        } else if(table.layout){
          map[table.name] = normalisePoint(table.layout, fallback);
        } else {
          map[table.name] = fallback;
        }
      });
      return map;
    }

    const initialLayout = computeLayout(activeRegistry, activeRecord.layout);
    const firstTable = activeRegistry.list()[0]?.name || null;
    const initialLayoutPoint = firstTable ? (initialLayout[firstTable] || { x:120, y:120 }) : { x:120, y:120 };

    const erdState = {
      head:{ title: activeRecord.title || 'مخطط قاعدة بيانات مشكاة' },
      env:{ theme:'dark', lang:'ar', dir:'rtl', graph:{ driver:'x6' } },
      data:{
        schemaId: activeRecord.id,
        schemaMeta:{
          name: activeRecord.name,
          title: activeRecord.title,
          description: activeRecord.description || ''
        },
        schemaCreatedAt: activeRecord.createdAt,
        schemaUpdatedAt: activeRecord.updatedAt,
        schema: activeRegistry.toJSON(),
        layout: initialLayout,
        selection:{ table:firstTable, field:null },
        canvas: normaliseCanvas(activeRecord.canvas),
        sqlPreview:'',
        error:null,
        library:{ items: libraryItems, status: SchemaLibrary.status }
      },
      ui:{
        modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false, columns:false },
        template:{ open:true },
        form:{
          table:{ name:'', nameInput:'', label:'', comment:'', includeId:true },
          field:{
            table:firstTable || '',
            name:'',
            nameInput:'',
            nameManual:false,
            columnName:'',
            type:'string',
            nullable:true,
            primaryKey:false,
            unique:false,
            defaultValue:'',
            references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
          },
          relation:{
            sourceTable:firstTable || '',
            sourceField:'',
            targetTable:'',
            targetField:'',
            onDelete:'CASCADE',
            onUpdate:'CASCADE'
          },
          import:{ name: activeRecord.name || '', title: activeRecord.title || '', targetId: activeRecord.id || '', text:'' },
          export:{ text:'' },
          sql:{ text:'' },
          layout:{ x: initialLayoutPoint.x, y: initialLayoutPoint.y },
          schemaMeta:{
            name: activeRecord.name || '',
            title: activeRecord.title || '',
            description: activeRecord.description || ''
          },
          columns:{ table:firstTable || '', rows: buildColumnsFormRows(activeRegistry.get(firstTable || '')) }
        },
        toolbar:{ exportOpen:false }
      }
    };

    function getRegistry(db){
      try {
        return Schema.Registry.fromJSON(db.data.schema);
      } catch(error){
        console.warn('[Mishkah][ERD] schema parse failed', error);
        return new Schema.Registry();
      }
    }

    function ensureLayout(db, tableName, options = {}){
      const registry = options.registry || getRegistry(db);
      const layout = computeLayout(registry, db.data.layout);
      if(tableName && !layout[tableName]){
        const tables = registry.list();
        const index = Math.max(tables.findIndex(tbl => tbl.name === tableName), tables.length);
        const fallback = computeGridPosition(index, Math.max(1, tables.length + 1));
        layout[tableName] = fallback;
      }
      return layout;
    }

    function withTableSelection(state, tableName){
      if(!tableName) return state;
      const registry = getRegistry(state);
      const layout = ensureLayout(state, tableName, { registry });
      const tablePos = layout[tableName] || { x: 120, y: 120 };
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field:null }, layout },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            field:{ ...(state.ui?.form?.field || {}), table: tableName },
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName },
            layout:{ x: tablePos.x, y: tablePos.y }
          }
        }
      };
    }

    function withFieldSelection(state, tableName, fieldName){
      if(!tableName || !fieldName) return state;
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field: fieldName } },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName, sourceField: fieldName }
          }
        }
      };
    }

    function mergeLibraryItems(list, record){
      const items = Array.isArray(list) ? list.slice() : [];
      const entry = clone(record);
      const idx = items.findIndex(item => item.id === record.id);
      if(idx >= 0) items[idx] = entry; else items.push(entry);
      items.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
      return items;
    }

    const schedulePersist = (function(){
      if(!SchemaLibrary.available) return ()=>{};
      const debounced = U.Control.debounce(async (record)=>{
        try{
          await SchemaLibrary.save(record, { bumpUpdatedAt:false });
        } catch(error){
          console.warn('[Mishkah][ERD] persist failed', error);
        }
      }, 600);
      return record => debounced(clone(record));
    })();

    function recordFromState(state){
      const meta = state.data.schemaMeta || {};
      return {
        id: state.data.schemaId,
        name: meta.name || '',
        title: meta.title || '',
        description: meta.description || '',
        schema: state.data.schema,
        layout: state.data.layout,
        canvas: state.data.canvas,
        createdAt: state.data.schemaCreatedAt,
        updatedAt: state.data.schemaUpdatedAt
      };
    }

    function SchemaLibraryPanel(db){
      const library = db.data.library || {};
      const items = library.items || [];
      const activeId = db.data.schemaId;
      const listContent = items.length
        ? D.Lists.Ul({ attrs:{ class: tw`flex flex-col gap-2 list-none m-0 p-0` } },
            items.map(item=> D.Lists.Li({ attrs:{ class: tw`rounded-xl border border-[var(--border)]/60 bg-[var(--surface-1)]/70 px-3 py-2 transition ${item.id === activeId ? 'ring-2 ring-[var(--primary)]/60' : 'hover:border-[var(--primary)]/50'}`, gkey:'erd:library:select', 'data-schema-id': item.id } }, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2` }}, [
                D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-0.5` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [item.title || item.name]),
                  D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [item.name])
                ]),
                D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-[10px] text-[var(--muted)]` }}, [U.Time.fmt(item.updatedAt || item.createdAt || Date.now())]),
                  UI.Button({ attrs:{ gkey:'erd:library:delete', 'data-schema-id': item.id, title:'حذف المخطط', class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, ['🗑️'])
                ])
              ])
            ])))
        : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['لم يتم حفظ أي مخططات بعد.']);
      return D.Containers.Aside({ attrs:{ class: tw`hidden lg:flex w-72 flex-col border-l border-[var(--border)] bg-[var(--surface-2)]/70 backdrop-blur` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between px-4 py-3 border-b border-[var(--border)]` }}, [
          D.Text.Span({ attrs:{ class: tw`text-base font-semibold` }}, ['مكتبة المخططات']),
          D.Text.Span({ attrs:{ class: tw`text-[10px] uppercase tracking-wide text-[var(--muted)]` }}, [library.status === 'indexeddb' ? 'IndexedDB' : 'ذاكرة مؤقتة'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`px-4 py-3 flex flex-col gap-2` }}, [
          UI.Button({ attrs:{ gkey:'erd:library:new' }, variant:'solid', size:'sm' }, ['➕ مخطط جديد']),
          UI.Button({ attrs:{ gkey:'erd:import:open' }, variant:'ghost', size:'sm' }, ['⬆️ استيراد JSON'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`flex-1 overflow-y-auto px-3 pb-4` }}, [listContent])
      ]);
    }

    function TemplateOverlay(db, tables){
      const templateState = db.ui?.template || {};
      if(templateState.open === false) return null;
      const registryTables = Array.isArray(tables) ? tables : getRegistry(db).list();
      const previewTables = registryTables.slice(0, 6);
      const cards = previewTables.length
        ? previewTables.map(table => {
            const fieldCount = (table.fields || []).length;
            const relationCount = (table.fields || []).filter(field => field.references).length;
            return D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)]/70 bg-[var(--surface-2)]/60 px-4 py-3 flex flex-col gap-2 shadow-sm` }}, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2` }}, [
                D.Containers.Div({ attrs:{ class: tw`flex flex-col` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [formatIdentifier(table.name)]),
                  table.label ? D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [table.label]) : null
                ].filter(Boolean)),
                UI.Button({ attrs:{ gkey:'erd:field:add:table', 'data-table': table.name, title:'إضافة عمود جديد لهذا الجدول' }, variant:'ghost', size:'sm' }, ['➕ عمود'])
              ]),
              D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [`Fields: ${fieldCount} · Relations: ${relationCount}`])
            ].filter(Boolean));
          })
        : [
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, ['ابدأ بإضافة جدول لإنشاء قالب المخطط.'])
          ];
      return D.Containers.Div({ attrs:{ class: tw`absolute bottom-4 left-4 z-20 w-80 max-w-full pointer-events-auto` }}, [
        D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)] bg-[var(--surface-1)]/95 shadow-xl backdrop-blur flex flex-col` }}, [
          D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between px-4 py-3 border-b border-[var(--border)]/80` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-semibold flex items-center gap-2` }}, ['🧩 ملخص القالب الحالي']),
            UI.Button({ attrs:{ gkey:'erd:template:toggle', title:'إخفاء الملخص', class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, ['إخفاء'])
          ]),
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2 px-4 py-3 max-h-60 overflow-y-auto` }}, cards),
          D.Containers.Div({ attrs:{ class: tw`px-4 py-2 border-t border-[var(--border)]/60` }}, [
            D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)] leading-relaxed` }}, ['هذا الملخص يوضح الجداول النشطة وعدد الحقول والعلاقات، مما يساعدك على فهم شكل المخطط بسرعة.'])
          ])
        ])
      ]);
    }

    function SchemaCanvas(db){
      const registry = getRegistry(db);
      const tables = registry.list();
      scheduleDiagramRender(db);
      const hasTables = tables.length > 0;
      const emptyState = !hasTables
        ? D.Containers.Div({ attrs:{ class: tw`absolute inset-0 flex items-center justify-center pointer-events-none` }}, [
            D.Containers.Div({ attrs:{ class: tw`rounded-3xl border border-dashed border-[var(--border)] bg-[var(--surface-2)]/70 px-6 py-5 text-center text-sm text-[var(--muted)] max-w-md` }}, ['أضف جدولًا جديدًا لبدء بناء المخطط.'])
          ])
        : null;
      const overlay = TemplateOverlay(db, tables);
      return D.Containers.Div({ attrs:{ class: tw`relative flex-1 bg-[var(--surface-1)]` }}, [
        D.Containers.Div({ attrs:{ id:'erd-diagram', class: tw`absolute inset-0` }}, []),
        overlay,
        emptyState
      ].filter(Boolean));
    }

    function ToolbarExportMenu(db){
      const open = db.ui?.toolbar?.exportOpen;
      const toggle = UI.Button({
        attrs:{
          gkey:'erd:toolbar:export',
          'data-state': open ? 'open' : 'closed',
          class: tw`!gap-2 !px-4 min-w-max`
        },
        variant: open ? 'soft' : 'ghost',
        size:'sm'
      }, [
        D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, ['تصدير']),
        D.Text.Span({ attrs:{ class: tw`text-xs opacity-70` }}, ['⯆'])
      ]);
      if(!open){
        return D.Containers.Div({ attrs:{ class: tw`relative` }}, [toggle]);
      }
      const formats = [
        { id:'sql:postgres', label:'SQL — Postgres', format:'sql', dialect:'postgres' },
        { id:'sql:mysql', label:'SQL — MySQL', format:'sql', dialect:'mysql' },
        { id:'sql:sqlserver', label:'SQL — SQL Server', format:'sql', dialect:'sqlserver' },
        { id:'json', label:'JSON', format:'json' },
        { id:'png', label:'PNG', format:'png' },
        { id:'svg', label:'SVG', format:'svg' }
      ];
      const list = D.Lists.Ul({ attrs:{ class: tw`flex flex-col gap-1 p-2` }}, formats.map(item =>
        D.Lists.Li({ attrs:{ class: tw`list-none` }}, [
          UI.Button({
            attrs:{
              gkey:'erd:export:run',
              'data-format': item.format,
              'data-dialect': item.dialect || '',
              'data-option-id': item.id,
              class: tw`w-full justify-start text-sm`
            },
            variant:'ghost',
            size:'sm'
          }, [item.label])
        ])
      ));
      return D.Containers.Div({ attrs:{ class: tw`relative` }}, [
        toggle,
        D.Containers.Div({ attrs:{ class: tw`absolute right-0 top-full z-50 mt-2 min-w-[220px] rounded-2xl border border-[var(--border)] bg-[var(--surface-1)]/95 shadow-xl backdrop-blur-md` }}, [list])
      ]);
    }

    function Toolbar(db){
      const zoom = db.data.canvas?.zoom || 1;
      const metaTitle = db.data.schemaMeta?.title || 'مخطط بدون اسم';
      const schemaIdentifier = db.data.schemaMeta?.name ? formatIdentifier(db.data.schemaMeta.name) : '';
      const lang = db.env?.lang || db.i18n?.lang || 'ar';
      const theme = db.env?.theme || 'dark';
      const templateOpen = db.ui?.template?.open !== false;
      const exportMenu = ToolbarExportMenu(db);
      const metaGroup = UI.ToolbarGroup({ attrs:{ class: tw`items-start gap-3` }, label:'المخطط' }, [
        D.Containers.Div({ attrs:{ class: tw`flex flex-col` }}, [
          D.Text.Span({ attrs:{ class: tw`text-xl font-bold` }}, [metaTitle]),
          schemaIdentifier ? D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--accent-foreground)]/80` }}, [schemaIdentifier]) : null
        ].filter(Boolean)),
        UI.Button({ attrs:{ gkey:'erd:schema:meta:open', class: tw`!px-3` }, variant:'ghost', size:'sm' }, ['✏️ خصائص المخطط'])
      ]);
      const structureGroup = UI.ToolbarGroup({ label:'العناصر' }, [
        UI.Button({ attrs:{ gkey:'erd:table:add' }, variant:'soft', size:'sm' }, ['➕ جدول']),
        UI.Button({ attrs:{ gkey:'erd:field:add' }, variant:'ghost', size:'sm' }, ['➕ حقل']),
        UI.Button({ attrs:{ gkey:'erd:relation:add' }, variant:'ghost', size:'sm' }, ['🔗 علاقة']),
        UI.Button({ attrs:{ gkey:'erd:columns:open' }, variant:'ghost', size:'sm' }, ['🗂️ الأعمدة'])
      ]);
      const templateGroup = UI.ToolbarGroup({ label:'القوالب' }, [
        UI.Button({ attrs:{ gkey:'erd:template:toggle' }, variant: templateOpen ? 'soft' : 'ghost', size:'sm' }, [templateOpen ? '🧩 إخفاء القالب' : '🧩 عرض القالب'])
      ]);

      const uiGroup = UI.ToolbarGroup({ label:'الواجهة' }, [
        UI.LanguageSwitch({ lang }),
        UI.ThemeToggleIcon({ theme })
      ]);
      const historyGroup = UI.ToolbarGroup({ label:'التاريخ' }, [
        UI.Button({ attrs:{ gkey:'erd:undo', title:'تراجع' }, variant:'ghost', size:'sm' }, ['↺']),
        UI.Button({ attrs:{ gkey:'erd:redo', title:'إعادة' }, variant:'ghost', size:'sm' }, ['↻']),
        UI.Button({ attrs:{ gkey:'erd:fit', title:'ملاءمة المخطط للشاشة' }, variant:'ghost', size:'sm' }, ['🗺️'])
      ]);
      const exportGroup = UI.ToolbarGroup({ label:'التصدير' }, [exportMenu]);
      const zoomGroup = UI.ToolbarGroup({ label:'الحجم' }, [
        UI.Button({ attrs:{ gkey:'erd:zoom:out', title:'تصغير' }, variant:'ghost', size:'sm' }, ['➖']),
        D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, [`${Math.round(zoom * 100)}%`]),
        UI.Button({ attrs:{ gkey:'erd:zoom:reset', title:'إعادة الحجم' }, variant:'ghost', size:'sm' }, ['⟳']),
        UI.Button({ attrs:{ gkey:'erd:zoom:in', title:'تكبير' }, variant:'ghost', size:'sm' }, ['➕'])
      ]);

      return UI.Toolbar({
        left:[metaGroup, structureGroup, templateGroup],
        right:[uiGroup, historyGroup, exportGroup, zoomGroup]
      });
    }

    function ModalImport(db){
      const open = db.ui?.modals?.import;
      const form = db.ui?.form?.import || { name:'', title:'', targetId:'', text:'' };
      const library = db.data.library || {};
      const items = library.items || [];
      return UI.Modal({
        open,
        size:'lg',
        title:'استيراد مخطط JSON',
        description:'ألصق بيانات المخطط أو استبدل مخططًا موجودًا.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'name', value: form.name || '', placeholder:'المعرف الفريد للمخطط (name)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'title', value: form.title || '', placeholder:'العنوان المعروض' } }),
            UI.Select({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'targetId', value: form.targetId || '' }, options:[
              { value:'', label:'إنشاء مخطط جديد' },
              ...items.map(item=> ({ value:item.id, label:`استبدال: ${item.title || item.name}` }))
            ] }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'text', value: form.text || '', rows:12, class: tw`w-full font-mono text-xs`, placeholder:'{"schema":{...}}' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:import:apply', variant:'solid', size:'sm' }}, ['استيراد وتخزين']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إغلاق'])
        ]
      });
    }

    function ModalExportJson(db){
      const open = db.ui?.modals?.exportJson;
      const text = db.ui?.form?.export?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'مخطط JSON',
        description:'انسخ المحتوى للاستخدام في أماكن أخرى.',
        closeGkey:'erd:modal:close',
        content:[
          UI.Textarea({ attrs:{ readonly:true, value: text, rows:14, class: tw`w-full font-mono text-xs` } })
        ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['تم']) ]
      });
    }

    function ModalExportSql(db){
      const open = db.ui?.modals?.exportSql;
      const text = db.ui?.form?.sql?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'نص SQL',
        description:'هذا النص يمثل أوامر إنشاء الجداول PostgreSQL.',
        closeGkey:'erd:modal:close',
        content:[ UI.Textarea({ attrs:{ readonly:true, value: text, rows:16, class: tw`w-full font-mono text-xs` } }) ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['تم']) ]
      });
    }

    function ModalSchemaMeta(db){
      const open = db.ui?.modals?.schemaMeta;
      const form = db.ui?.form?.schemaMeta || { name:'', title:'', description:'' };
      return UI.Modal({
        open,
        size:'md',
        title:'خصائص المخطط',
        description:'قم بتحديث اسم التعريف والعنوان والوصف.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'name', value: form.name || '', placeholder:'Name (snake_case)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'title', value: form.title || '', placeholder:'Title' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'description', value: form.description || '', rows:4, placeholder:'وصف مختصر للمخطط' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:schema:meta:save', variant:'solid', size:'sm' }}, ['حفظ التعديلات']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalAddTable(db){
      const open = db.ui?.modals?.table;
      const form = db.ui?.form?.table || { name:'', nameInput:'', label:'', comment:'', includeId:true };
      const registry = getRegistry(db);
      const sanitizedName = form.name || '';
      const suggestedName = sanitizedName || (form.label ? sanitizeSqlIdentifier(form.label) : '');
      const helperText = suggestedName
        ? `سيتم حفظ الجدول في قاعدة البيانات بالاسم: ${suggestedName} مع ضمان عدم تكرار المعرف داخل المخطط.`
        : 'اكتب اسمًا إنجليزيًا، وسيتم تحويل المسافات والمحارف الخاصة تلقائيًا إلى صيغة SQL سليمة.';
      return UI.Modal({
        open,
        size:'md',
        title:'إنشاء جدول جديد',
        description:'الاسم الإنجليزي مطلوب وسيُستخدم كاسم الجدول في قاعدة البيانات. يمكنك إضافة مسمى بلغة أخرى اختياريًا.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'name', value: form.nameInput || '', placeholder:'English name (مثال: Sales Orders)' } }),
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [helperText]),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'label', value: form.label || '', placeholder:'اسم الجدول بلغة ثانية (اختياري)' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'comment', value: form.comment || '', rows:3, placeholder:'ملاحظات' } }),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-2` }}, [
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'table', 'data-field':'includeId', type:'checkbox', checked: form.includeId !== false } }),
              UI.Label({ text:'إنشاء حقل id افتراضي؟' })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:table:create', variant:'solid', size:'sm' }}, ['إنشاء']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalAddField(db){
      const open = db.ui?.modals?.field;
      const form = db.ui?.form?.field || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} — ${table.label}`
          : formatIdentifier(table.name)
      }));
      const selectedTable = form.table && registry.get(form.table)
        ? form.table
        : (tableOptions[0]?.value || '');
      const currentTable = selectedTable ? registry.get(selectedTable) : null;
      const previewFieldName = form.name || (form.label ? computeFieldIdentifier(currentTable, form.label) : '');
      const englishInputValue = form.nameInput != null ? form.nameInput : (form.name || '');
      const selectedReferenceTable = form.references?.table && registry.get(form.references.table)
        ? form.references.table
        : '';
      const referenceTableEntity = selectedReferenceTable ? registry.get(selectedReferenceTable) : null;
      const referenceFieldOptions = referenceTableEntity
        ? referenceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const selectedReferenceField = referenceFieldOptions.some(opt => opt.value === form.references?.column)
        ? form.references?.column
        : '';
      return UI.Modal({
        open,
        size:'lg',
        title:'إضافة حقل',
        description:'حدد تفاصيل الحقل الجديد مع اسم إنجليزي متوافق مع SQL ومسمى عربي اختياري.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{
                gkey:'erd:form:update',
                'data-form':'field',
                'data-field':'table',
                value: selectedTable || ''
              },
              options:[{ value:'', label:'اختر الجدول' }, ...tableOptions]
            }),
            UI.Input({
              attrs:{
                gkey:'erd:form:update',
                'data-form':'field',
                'data-field':'name',
                value: englishInputValue,
                placeholder:'English column name (snake_case)'
              }
            }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'label', value: form.label || '', placeholder:'المسمى العربي للحقل' } }),
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--accent-foreground)]/80 md:col-span-2` }}, [previewFieldName ? `المعرف النهائي: ${previewFieldName}` : 'سيتم توليد المعرف تلقائيًا عند الكتابة.']),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'type', value: form.type || 'string' },
              options: FIELD_TYPE_OPTIONS
            }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'defaultValue', value: form.defaultValue || '', placeholder:'قيمة افتراضية' } }),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Nullable؟' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'nullable', type:'checkbox', checked: form.nullable !== false } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Primary Key؟' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'primaryKey', type:'checkbox', checked: !!form.primaryKey } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Unique؟' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'unique', type:'checkbox', checked: !!form.unique } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`col-span-full flex flex-col gap-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['علاقة مرجعية اختيارية']),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'table',
                  value: selectedReferenceTable
                },
                options:[{ value:'', label:'بدون علاقة' }, ...tableOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'column',
                  value: selectedReferenceField
                },
                options:[{ value:'', label:'اختر الحقل' }, ...referenceFieldOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onDelete',
                  value: form.references?.onDelete || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onUpdate',
                  value: form.references?.onUpdate || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:field:create', variant:'solid', size:'sm' }}, ['إضافة']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalRelation(db){
      const open = db.ui?.modals?.relation;
      const form = db.ui?.form?.relation || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} — ${table.label}`
          : formatIdentifier(table.name)
      }));
      const sourceTableValue = form.sourceTable && registry.get(form.sourceTable)
        ? form.sourceTable
        : '';
      const sourceTableEntity = sourceTableValue ? registry.get(sourceTableValue) : null;
      const sourceFieldOptions = sourceTableEntity
        ? sourceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const sourceFieldValue = sourceFieldOptions.some(opt => opt.value === form.sourceField)
        ? form.sourceField
        : '';
      const targetTableValue = form.targetTable && registry.get(form.targetTable)
        ? form.targetTable
        : '';
      const targetTableEntity = targetTableValue ? registry.get(targetTableValue) : null;
      const targetFieldOptions = targetTableEntity
        ? targetTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const targetFieldValue = targetFieldOptions.some(opt => opt.value === form.targetField)
        ? form.targetField
        : '';
      return UI.Modal({
        open,
        size:'md',
        title:'إنشاء علاقة بين الجداول',
        description:'حدد الجدول المصدر والهدف وأسلوب التحديث.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceTable', value: sourceTableValue },
              options:[{ value:'', label:'اختر الجدول المصدر' }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceField', value: sourceFieldValue },
              options:[{ value:'', label:'اختر الحقل المصدر' }, ...sourceFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetTable', value: targetTableValue },
              options:[{ value:'', label:'اختر الجدول الهدف' }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetField', value: targetFieldValue },
              options:[{ value:'', label:'اختر الحقل الهدف' }, ...targetFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onDelete', value: form.onDelete || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onUpdate', value: form.onUpdate || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:relation:create', variant:'solid', size:'sm' }}, ['حفظ العلاقة']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalColumnsManager(db){
      const open = db.ui?.modals?.columns;
      if(!open) return null;
      const registry = getRegistry(db);
      const tables = registry.list();
      if(!tables.length){
        return UI.Modal({
          open,
          size:'lg',
          title:'محرر الأعمدة',
          description:'لا توجد جداول في المخطط بعد. قم بإضافة جدول لبدء إدارة الأعمدة.',
          closeGkey:'erd:modal:close',
          content:[ D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['أضف جدولًا جديدًا من شريط الأدوات ثم عد إلى هنا.']) ],
          actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إغلاق']) ]
        });
      }
      const form = db.ui?.form?.columns || {};
      const currentTableName = form.table && registry.get(form.table)
        ? form.table
        : (tables[0]?.name || '');
      const currentTable = currentTableName ? registry.get(currentTableName) : null;
      const rows = Array.isArray(form.rows) && form.rows.length ? form.rows : buildColumnsFormRows(currentTable);
      const tableNav = D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-1` }},
        tables.map(table => UI.Button({
          attrs:{
            gkey:'erd:columns:select-table',
            'data-table': table.name,
            class: tw`${table.name === currentTableName ? '!bg-[var(--accent)] !text-[var(--accent-foreground)]' : ''}`
          },
          variant: table.name === currentTableName ? 'soft' : 'ghost',
          size:'sm'
        }, [formatIdentifier(table.name)]))
      );

      const rowElements = rows.length
        ? rows.map((row, index) => {
            const key = row.key || row.originalName || `${currentTableName}:${index}`;
            const typeOptions = FIELD_TYPE_OPTIONS;
            const supportsLength = typeSupportsLength(row.type);
            const supportsPrecision = typeSupportsPrecision(row.type);
            const lengthControl = supportsLength
              ? UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'length', value: row.length || '', placeholder:'الطول', class: tw`w-full`, type:'number', min:'1' } })
              : null;
            const precisionControls = supportsPrecision
              ? D.Containers.Div({ attrs:{ class: tw`grid grid-cols-2 gap-2` }}, [
                  UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'precision', value: row.precision || '', placeholder:'الدقة', class: tw`w-full`, type:'number', min:'1' } }),
                  UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'scale', value: row.scale || '', placeholder:'المقياس', class: tw`w-full`, type:'number', min:'0' } })
                ])
              : null;
            const toggleControls = D.Containers.Div({ attrs:{ class: tw`flex flex-wrap items-center gap-3 text-xs` }}, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'nullable', type:'checkbox', checked: row.nullable !== false } }),
                UI.Label({ text:'NULL?' })
              ]),
              D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'primaryKey', type:'checkbox', checked: !!row.primaryKey } }),
                UI.Label({ text:'PK' })
              ]),
              D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'unique', type:'checkbox', checked: !!row.unique } }),
                UI.Label({ text:'Unique' })
              ]),
              D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'index', type:'checkbox', checked: !!row.index } }),
                UI.Label({ text:'Index' })
              ])
            ]);

            const quickActions = D.Containers.Div({ attrs:{ class: tw`flex items-center gap-2` }}, [
              UI.Button({ attrs:{ gkey:'erd:columns:open-relation', 'data-row': key, 'data-table': currentTableName, class: tw`!px-2 !py-1 text-xs` }, variant:'ghost', size:'xs' }, ['FK']),
              UI.Button({ attrs:{ gkey:'erd:columns:focus', 'data-row': key, 'data-table': currentTableName, class: tw`!px-2 !py-1 text-xs` }, variant:'ghost', size:'xs' }, ['انتقال'])
            ]);

            return D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)]/70 bg-[var(--surface-1)]/80 p-4 flex flex-col gap-3` }}, [
              D.Containers.Div({ attrs:{ class: tw`flex flex-col md:flex-row md:items-start md:justify-between gap-3` }}, [
                D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3 flex-1` }}, [
                  UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'name', value: row.name || '', placeholder:'اسم العمود (snake_case)' } }),
                  UI.Select({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'type', value: row.type || 'string' }, options: typeOptions }),
                  lengthControl,
                  precisionControls,
                  UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'defaultValue', value: row.defaultValue || '', placeholder:'القيمة الافتراضية' } })
                ].filter(Boolean)),
                D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [toggleControls, quickActions])
              ]),
              D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-2` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'refTable', value: row.references?.table || '', placeholder:'جدول المرجع (FK)' } }),
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'refColumn', value: row.references?.column || '', placeholder:'حقل المرجع (FK)' } })
              ])
            ]);
          })
        : [D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['لا توجد أعمدة بعد لهذا الجدول.'])];

      return UI.Modal({
        open,
        size:'xl',
        title:'محرر الأعمدة',
        description:'تحكم في أعمدة الجدول المحدد بسرعة عبر واجهة واحدة.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-[200px_minmax(0,1fr)] gap-4` }}, [
            D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)]/70 bg-[var(--surface-2)]/60 p-3 flex flex-col gap-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, ['الجداول']),
              tableNav
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3 max-h-[60vh] overflow-y-auto pr-1` }}, rowElements)
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:columns:save', variant:'solid', size:'sm' }}, ['حفظ الأعمدة']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إغلاق'])
        ]
      });
    }

    function Modals(db){
      return [
        ModalImport(db),
        ModalExportJson(db),
        ModalExportSql(db),
        ModalSchemaMeta(db),
        ModalAddTable(db),
        ModalAddField(db),
        ModalRelation(db),
        ModalColumnsManager(db)
      ];
    }

    function AppView(db){
      return D.Containers.Div({ attrs:{ class: tw`flex h-screen w-full bg-[var(--surface-0)] text-[var(--foreground)]` }}, [
        SchemaLibraryPanel(db),
        D.Containers.Div({ attrs:{ class: tw`flex flex-1 flex-col` }}, [
          Toolbar(db),
          SchemaCanvas(db)
        ]),
        ...Modals(db)
      ]);
    }

    const erdOrders = {
      'erd.fit':{
        on:['click'],
        gkeys:['erd:fit'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.fitToScreen === 'function'){
            try { driver.fitToScreen(16); }
            catch(error){ console.warn('[Mishkah][ERD] fit failed', error); }
          } else {
            UI.pushToast(ctx, { title:'لم يتم تفعيل أداة الرسم بعد', icon:'⚠️' });
          }
        }
      },
      'erd.undo':{
        on:['click'],
        gkeys:['erd:undo'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.undo === 'function'){
            try { driver.undo(); }
            catch(error){ console.warn('[Mishkah][ERD] undo failed', error); }
          }
        }
      },
      'erd.redo':{
        on:['click'],
        gkeys:['erd:redo'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.redo === 'function'){
            try { driver.redo(); }
            catch(error){ console.warn('[Mishkah][ERD] redo failed', error); }
          }
        }
      },
      'erd.zoom.in':{
        on:['click'],
        gkeys:['erd:zoom:in'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.min(MAX_CANVAS_ZOOM, (s.data.canvas?.zoom || 1) + 0.1);
            const canvas = { ...(s.data.canvas || {}), zoom, mode:'manual' };
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.out':{
        on:['click'],
        gkeys:['erd:zoom:out'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.max(MIN_CANVAS_ZOOM, (s.data.canvas?.zoom || 1) - 0.1);
            const canvas = { ...(s.data.canvas || {}), zoom, mode:'manual' };
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.reset':{
        on:['click'],
        gkeys:['erd:zoom:reset'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const canvas = { ...(s.data.canvas || {}), zoom:1, mode:'auto' };
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.toolbar.export.toggle':{
        on:['click'],
        gkeys:['erd:toolbar:export'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              toolbar:{
                ...(s.ui?.toolbar || {}),
                exportOpen: !(s.ui?.toolbar?.exportOpen)
              }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.export.run':{
        on:['click'],
        gkeys:['erd:export:run'],
        handler: async (e,ctx)=>{
          const target = e.target.closest('[data-format]');
          if(!target) return;
          const format = target.getAttribute('data-format') || '';
          const dialect = target.getAttribute('data-dialect') || '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              toolbar:{ ...(s.ui?.toolbar || {}), exportOpen:false }
            }
          }));
          ctx.rebuild();
          const state = ctx.getState();
          if(format === 'svg'){
            const driver = ensureDriverInstance(state);
            if(!driver || typeof driver.exportSVG !== 'function'){
              UI.pushToast(ctx, { title:'سائق الرسم لا يدعم تصدير SVG', icon:'⚠️' });
              return;
            }
            try{
              const svg = await driver.exportSVG();
              const blob = svg instanceof Blob ? svg : new Blob([svg], { type:'image/svg+xml' });
              const url = URL.createObjectURL(blob);
              const link = document.createElement('a');
              const name = state.data?.schemaMeta?.name || 'schema';
              link.href = url;
              link.download = `${name}.svg`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);
              UI.pushToast(ctx, { title:'تم تصدير الرسم بصيغة SVG', icon:'✅' });
            } catch(error){
              console.warn('[Mishkah][ERD] export SVG failed', error);
              UI.pushToast(ctx, { title:'تعذر تصدير SVG', message:String(error), icon:'🛑' });
            }
            return;
          }
          if(format === 'png'){
            const driver = ensureDriverInstance(state);
            if(!driver || typeof driver.exportPNG !== 'function'){
              UI.pushToast(ctx, { title:'سائق الرسم لا يدعم تصدير PNG', icon:'⚠️' });
              return;
            }
            try{
              const blob = await driver.exportPNG({ background: currentPalette().background || '#ffffff' });
              const url = URL.createObjectURL(blob);
              const link = document.createElement('a');
              const name = state.data?.schemaMeta?.name || 'schema';
              link.href = url;
              link.download = `${name}.png`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);
              UI.pushToast(ctx, { title:'تم تصدير الرسم بصيغة PNG', icon:'✅' });
            } catch(error){
              console.warn('[Mishkah][ERD] export PNG failed', error);
              UI.pushToast(ctx, { title:'تعذر تصدير PNG', message:String(error), icon:'🛑' });
            }
            return;
          }
          if(format === 'json'){
            const payload = {
              name: state.data.schemaMeta?.name || '',
              title: state.data.schemaMeta?.title || '',
              description: state.data.schemaMeta?.description || '',
              schema: state.data.schema,
              layout: state.data.layout,
              canvas: state.data.canvas,
              createdAt: state.data.schemaCreatedAt,
              updatedAt: state.data.schemaUpdatedAt,
            };
            ctx.setState(s=>({
              ...s,
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), exportJson:true },
                form:{ ...(s.ui?.form || {}), export:{ text: JSON.stringify(payload, null, 2) } }
              }
            }));
            ctx.rebuild();
            return;
          }
          if(format === 'sql'){
            const registry = getRegistry(state);
            let sql = '';
            try {
              sql = registry.generateSQL({ schemaName:'public', dialect: dialect || 'postgres' });
            } catch(error){
              console.warn('[Mishkah][ERD] generateSQL failed', error);
              sql = registry.generateSQL({ schemaName:'public' });
            }
            ctx.setState(s=>({
              ...s,
              data:{ ...s.data, sqlPreview: sql },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), exportSql:true },
                form:{ ...(s.ui?.form || {}), sql:{ text: sql } }
              }
            }));
            ctx.rebuild();
            return;
          }
        }
      },
      'erd.table.select':{
        on:['click'],
        gkeys:['erd:table:select'],
        handler:(e,ctx)=>{
          const card = e.target.closest('[data-table-name]');
          if(!card) return;
          const tableName = card.getAttribute('data-table-name');
          ctx.setState(s => withTableSelection(s, tableName));
          ctx.rebuild();
        }
      },
      'erd.field.select':{
        on:['click'],
        gkeys:['erd:field:select'],
        handler:(e,ctx)=>{
          const row = e.target.closest('[data-field-name]');
          if(!row) return;
          const tableName = row.getAttribute('data-table-name');
          const fieldName = row.getAttribute('data-field-name');
          ctx.setState(s => withFieldSelection(s, tableName, fieldName));
          ctx.rebuild();
        }
      },
      'erd.import.open':{
        on:['click'],
        gkeys:['erd:import:open'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), import:true },
              form:{ ...(s.ui?.form || {}), import:{ name: payload.name, title: payload.title, targetId: s.data.schemaId || '', text: JSON.stringify(payload, null, 2) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.modal.close':{
        on:['click'],
        gkeys:['erd:modal:close','ui:modal:close'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false, columns:false } }
          }));
          ctx.rebuild();
        }
      },
      'erd.template.toggle':{
        on:['click'],
        gkeys:['erd:template:toggle'],
        handler:(e,ctx)=>{
          ctx.setState(s=>{
            const currentOpen = s.ui?.template?.open !== false;
            const nextOpen = !currentOpen;
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                template:{ ...(s.ui?.template || {}), open: nextOpen }
              }
            };
          });
          ctx.rebuild();
        }
      },
      'erd.form.update':{
        on:['input','change'],
        gkeys:['erd:form:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          const parent = input.getAttribute('data-parent');
          if(!formKey) return;
          const value = input.value;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            if(formKey === 'fieldRef' || formKey === 'fieldRefColumn' || parent === 'field'){
              const current = currentForms.field || {};
              let nextRef = { ...(current.references || {}) };
              if(fieldKey){
                nextRef[fieldKey] = value;
              }
              if(fieldKey === 'table'){
                nextRef = { ...nextRef, table: value, column: '' };
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...current, references: nextRef } } } };
            }
            if(formKey === 'table' && fieldKey === 'name'){
              const targetForm = currentForms.table || {};
              const normalized = sanitizeSqlIdentifier(value);
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    table:{ ...targetForm, name: normalized, nameInput: value }
                  }
                }
              };
            }
            if(formKey === 'table' && fieldKey === 'label'){
              const targetForm = currentForms.table || {};
              const hasNameInput = !!(targetForm.nameInput && targetForm.nameInput.trim());
              const suggestion = sanitizeSqlIdentifier(value);
              const nextTable = { ...targetForm, label: value };
              if(!hasNameInput){
                nextTable.name = suggestion;
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, table: nextTable } } };
            }
            if(formKey === 'field' && fieldKey === 'label'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = targetForm.table ? registry.get(targetForm.table) : null;
              const nextField = { ...targetForm, label:value };
              if(!targetForm.nameManual){
                const slug = computeFieldIdentifier(table, value);
                nextField.name = slug;
                nextField.nameInput = slug;
                nextField.columnName = slug;
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field: nextField } } };
            }
            if(formKey === 'field' && fieldKey === 'name'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = targetForm.table ? registry.get(targetForm.table) : null;
              const normalized = sanitizeSqlIdentifier(value);
              let nextName = normalized;
              if(!nextName && targetForm.label){
                nextName = computeFieldIdentifier(table, targetForm.label);
              }
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    field:{
                      ...targetForm,
                      name: nextName,
                      nameInput: value,
                      columnName: nextName || '',
                      nameManual: !!normalized
                    }
                  }
                }
              };
            }
            if(formKey === 'field' && fieldKey === 'table'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = value ? registry.get(value) : null;
              let slug = targetForm.name || '';
              let nameInput = targetForm.nameInput || '';
              if(!targetForm.nameManual && targetForm.label){
                slug = computeFieldIdentifier(table, targetForm.label);
                nameInput = slug;
              }
              const currentRefs = targetForm.references || {};
              const references = currentRefs.table === value
                ? currentRefs
                : { table:'', column:'', onDelete: currentRefs.onDelete || 'CASCADE', onUpdate: currentRefs.onUpdate || 'CASCADE' };
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    field:{
                      ...targetForm,
                      table:value,
                      name: slug,
                      nameInput,
                      columnName: slug,
                      references
                    }
                  }
                }
              };
            }
            if(formKey === 'relation' && fieldKey === 'sourceTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, sourceTable: value, sourceField:'' } } }
              };
            }
            if(formKey === 'relation' && fieldKey === 'targetTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, targetTable: value, targetField:'' } } }
              };
            }
            if(fieldKey){
              const targetForm = currentForms[formKey] || {};
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: value } } } };
            }
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: value } } };
          });
          ctx.rebuild();
        }
      },
      'erd.form.toggle':{
        on:['change'],
        gkeys:['erd:form:toggle'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          if(!formKey || !fieldKey) return;
          const checked = input.checked;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            const targetForm = currentForms[formKey] || {};
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: checked } } } };
          });
          ctx.rebuild();
        }
      },
      'erd.table.add':{
        on:['click'],
        gkeys:['erd:table:add'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), table:true } }
          }));
          ctx.rebuild();
        }
      },
      'erd.table.create':{
        on:['click'],
        gkeys:['erd:table:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.table || {};
          const registry = getRegistry(state);
          const englishInput = (form.name || '').trim();
          if(!englishInput){
            UI.pushToast(ctx, { title:'يرجى إدخال الاسم الإنجليزي للجدول', icon:'⚠️' });
            return;
          }
          const name = computeTableIdentifier(registry, englishInput);
          const label = (form.label || '').trim();
          try{
            const currentTables = registry.list();
            const fallbackPosition = computeGridPosition(currentTables.length, currentTables.length + 1);
            const tableConfig = {
              name,
              label: label || '',
              comment: form.comment || '',
              layout: fallbackPosition,
              fields: []
            };
            if(form.includeId){
              tableConfig.fields.push({ name:'id', columnName:'id', type:'uuid', primaryKey:true, nullable:false });
            }
            registry.register(tableConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const layout = ensureLayout({ data:{ layout: s.data.layout, schema: s.data.schema } }, name, { registry });
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                head:{ ...(s.head || {}), title: record.title || (s.head?.title || 'مخطط قاعدة بيانات مشكاة') },
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  layout,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), table:false },
                  form:{
                    ...(s.ui?.form || {}),
                    table:{ name:'', nameInput:'', label:'', comment:'', includeId:true },
                    field:{ ...(s.ui?.form?.field || {}), table: name, label:'', name:'', nameInput:'', nameManual:false, columnName:'' },
                    layout:{ x: layout[name].x, y: layout[name].y }
                  }
                }
              };
              draft = withTableSelection(draft, name);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create table', error);
            UI.pushToast(ctx, { title:'فشل إنشاء الجدول', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.field.add':{
        on:['click'],
        gkeys:['erd:field:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const first = registry.list()[0]?.name || '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), field:true },
              form:{
                ...(s.ui?.form || {}),
                field:{
                  table: s.data.selection?.table || first,
                  label:'',
                  name:'',
                  nameInput:'',
                  nameManual:false,
                  columnName:'',
                  type:'string',
                  nullable:true,
                  primaryKey:false,
                  unique:false,
                  defaultValue:'',
                  references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
                }
              }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.field.add.table':{
        on:['click'],
        gkeys:['erd:field:add:table'],
        handler:(event, ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const target = (event?.target && typeof event.target.closest === 'function')
            ? event.target.closest('[data-m-gkey="erd:field:add:table"]')
            : null;
          const button = target || event.currentTarget;
          const requestedTable = button?.getAttribute ? button.getAttribute('data-table') : '';
          const fallbackTable = state.data.selection?.table || registry.list()[0]?.name || '';
          const tableName = requestedTable && registry.get(requestedTable) ? requestedTable : fallbackTable;
          ctx.setState(s=>{
            const nextState = {
              ...s,
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), field:true },
                form:{
                  ...(s.ui?.form || {}),
                  field:{
                    table: tableName,
                    label:'',
                    name:'',
                    nameInput:'',
                    nameManual:false,
                    columnName:'',
                    type:'string',
                    nullable:true,
                    primaryKey:false,
                    unique:false,
                    defaultValue:'',
                    references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
                  }
                }
              }
            };
            return tableName ? withTableSelection(nextState, tableName) : nextState;
          });
          ctx.rebuild();
        }
      },
      'erd.field.create':{
        on:['click'],
        gkeys:['erd:field:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.field || {};
          const tableName = (form.table || '').trim();
          const label = (form.label || '').trim();
          const englishSource = (form.name || '').trim();
          if(!tableName || (!label && !englishSource)){
            UI.pushToast(ctx, { title:'يرجى تحديد الجدول واسم الحقل باللغتين على الأقل', icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:'الجدول غير موجود', icon:'⚠️' });
            return;
          }
          try{
            let fieldName = sanitizeSqlIdentifier(englishSource);
            if(!fieldName && label){
              fieldName = computeFieldIdentifier(table, label);
            }
            if(!fieldName){
              UI.pushToast(ctx, { title:'الاسم الإنجليزي للحقل غير صالح', icon:'⚠️' });
              return;
            }
            if(typeof table.getField === 'function' && table.getField(fieldName)){
              UI.pushToast(ctx, { title:'اسم الحقل مستخدم مسبقًا داخل الجدول', icon:'⚠️' });
              return;
            }
            const fieldConfig = {
              name: fieldName,
              columnName: fieldName,
              type: form.type || 'string',
              nullable: form.nullable !== false,
              primaryKey: !!form.primaryKey,
              unique: !!form.unique,
              comment: label
            };
            if(form.defaultValue){
              const val = form.defaultValue;
              if(['integer','number','decimal','float'].includes(fieldConfig.type)){
                const num = Number(val);
                if(!Number.isNaN(num)) fieldConfig.defaultValue = num;
              } else if(fieldConfig.type === 'boolean'){
                fieldConfig.defaultValue = ['true','1','yes','on'].includes(String(val).toLowerCase());
              } else {
                fieldConfig.defaultValue = val;
              }
            }
            if(form.references && form.references.table && form.references.column){
              fieldConfig.references = {
                table: form.references.table,
                column: form.references.column,
                onDelete: form.references.onDelete || 'CASCADE',
                onUpdate: form.references.onUpdate || 'CASCADE'
              };
            }
            table.addField(fieldConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), field:false },
                  form:{
                    ...(s.ui?.form || {}),
                    field:{
                      ...form,
                      label:'',
                      name:'',
                      nameInput:'',
                      nameManual:false,
                      columnName:'',
                      defaultValue:'',
                      primaryKey:false,
                      unique:false
                    }
                  }
                }
              };
              draft = withFieldSelection(draft, tableName, fieldName);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to add field', error);
            UI.pushToast(ctx, { title:'فشل إضافة الحقل', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.columns.open':{
        on:['click'],
        gkeys:['erd:columns:open'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const selection = state.data.selection || {};
          const tables = registry.list();
          const defaultTable = selection.table && registry.get(selection.table)
            ? selection.table
            : (tables[0]?.name || '');
          const tableEntity = defaultTable ? registry.get(defaultTable) : null;
          const rows = buildColumnsFormRows(tableEntity);
          ctx.setState(s=>{
            const nextState = {
              ...s,
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), columns:true },
                form:{ ...(s.ui?.form || {}), columns:{ table: defaultTable, rows } }
              }
            };
            return defaultTable ? withTableSelection(nextState, defaultTable) : nextState;
          });
          ctx.rebuild();
        }
      },
      'erd.columns.select-table':{
        on:['click'],
        gkeys:['erd:columns:select-table'],
        handler:(e,ctx)=>{
          const button = e.target.closest('[data-table]');
          if(!button) return;
          const tableName = button.getAttribute('data-table');
          const state = ctx.getState();
          const registry = getRegistry(state);
          if(!tableName || !registry.get(tableName)) return;
          const rows = buildColumnsFormRows(registry.get(tableName));
          ctx.setState(s=>{
            const draft = {
              ...s,
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), columns:true },
                form:{ ...(s.ui?.form || {}), columns:{ table: tableName, rows } }
              }
            };
            return withTableSelection(draft, tableName);
          });
          ctx.rebuild();
        }
      },
      'erd.columns.update':{
        on:['input','change'],
        gkeys:['erd:columns:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const rowKey = input.getAttribute('data-row');
          const fieldKey = input.getAttribute('data-field');
          if(!rowKey || !fieldKey) return;
          const isCheckbox = input.type === 'checkbox';
          const value = isCheckbox ? input.checked : input.value;
          ctx.setState(s=>{
            const columnsForm = s.ui?.form?.columns || { table:'', rows:[] };
            const rows = Array.isArray(columnsForm.rows) ? columnsForm.rows.map(row => {
              if((row.key || row.originalName || row.name) !== rowKey) return row;
              const next = { ...row };
              switch(fieldKey){
                case 'name':
                  next.name = value;
                  break;
                case 'type':{
                  next.type = value || 'string';
                  if(typeSupportsLength(next.type)){
                    if(!next.length) next.length = defaultLengthForType(next.type);
                  } else {
                    next.length = '';
                  }
                  if(typeSupportsPrecision(next.type)){
                    const defaults = defaultPrecisionForType(next.type);
                    if(!next.precision) next.precision = defaults.precision;
                    if(!next.scale) next.scale = defaults.scale;
                  } else {
                    next.precision = '';
                    next.scale = '';
                  }
                  break;
                }
                case 'length':
                  next.length = value;
                  break;
                case 'precision':
                  next.precision = value;
                  break;
                case 'scale':
                  next.scale = value;
                  break;
                case 'defaultValue':
                  next.defaultValue = value;
                  break;
                case 'nullable':
                  next.nullable = !!value;
                  break;
                case 'primaryKey':
                  next.primaryKey = !!value;
                  if(next.primaryKey) next.nullable = false;
                  break;
                case 'unique':
                  next.unique = !!value;
                  break;
                case 'index':
                  next.index = !!value;
                  break;
                case 'refTable':{
                  const refs = Object.assign({ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }, next.references || {});
                  refs.table = value;
                  if(!value) refs.column = '';
                  next.references = refs;
                  break;
                }
                case 'refColumn':{
                  const refs = Object.assign({ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }, next.references || {});
                  refs.column = value;
                  next.references = refs;
                  break;
                }
                default:
                  break;
              }
              return next;
            }) : [];
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                form:{ ...(s.ui?.form || {}), columns:{ table: columnsForm.table || '', rows } }
              }
            };
          });
          ctx.rebuild();
        }
      },
      'erd.columns.open-relation':{
        on:['click'],
        gkeys:['erd:columns:open-relation'],
        handler:(e,ctx)=>{
          const button = e.target.closest('[data-row]');
          if(!button) return;
          const rowKey = button.getAttribute('data-row');
          const tableName = button.getAttribute('data-table');
          const state = ctx.getState();
          const columnsForm = state.ui?.form?.columns || {};
          const rows = Array.isArray(columnsForm.rows) ? columnsForm.rows : [];
          const row = rows.find(item => (item.key || item.originalName || item.name) === rowKey);
          if(!row) return;
          const sourceField = sanitizeSqlIdentifier(row.name || row.originalName || rowKey) || row.originalName || rowKey;
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), columns:false, relation:true },
              form:{
                ...(s.ui?.form || {}),
                relation:{
                  sourceTable: tableName || columnsForm.table || '',
                  sourceField,
                  targetTable: row.references?.table || '',
                  targetField: row.references?.column || '',
                  onDelete: row.references?.onDelete || 'CASCADE',
                  onUpdate: row.references?.onUpdate || 'CASCADE'
                }
              }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.columns.focus':{
        on:['click'],
        gkeys:['erd:columns:focus'],
        handler:(e,ctx)=>{
          const button = e.target.closest('[data-row]');
          if(!button) return;
          const rowKey = button.getAttribute('data-row');
          const tableName = button.getAttribute('data-table');
          ctx.setState(s=>{
            const columnsForm = s.ui?.form?.columns || {};
            const rows = Array.isArray(columnsForm.rows) ? columnsForm.rows : [];
            const row = rows.find(item => (item.key || item.originalName || item.name) === rowKey);
            const fieldName = row ? (sanitizeSqlIdentifier(row.name || row.originalName || rowKey) || row.originalName || rowKey) : rowKey;
            const draft = {
              ...s,
              ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), columns:false } }
            };
            return withFieldSelection(draft, tableName || columnsForm.table || '', fieldName);
          });
          ctx.rebuild();
        }
      },
      'erd.columns.save':{
        on:['click'],
        gkeys:['erd:columns:save'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.columns || {};
          const tableName = form.table || '';
          const registry = getRegistry(state);
          const table = tableName ? registry.get(tableName) : null;
          if(!table){
            UI.pushToast(ctx, { title:'اختر جدولاً لتحديث أعمدته', icon:'⚠️' });
            return;
          }
          const rows = Array.isArray(form.rows) ? form.rows : [];
          if(!rows.length){
            UI.pushToast(ctx, { title:'لا توجد أعمدة لتحديثها', icon:'⚠️' });
            return;
          }
          const renameMap = new Map();
          try {
            rows.forEach((row, index)=>{
              const original = row.originalName || row.key || row.name;
              if(!original) return;
              let nextName = sanitizeSqlIdentifier(row.name || original || `column_${index+1}`);
              if(!nextName){
                nextName = ensureUniqueFieldName(table, original || 'column');
              }
              if(original !== nextName && typeof table.getField === 'function' && table.getField(nextName)){
                nextName = ensureUniqueFieldName(table, nextName);
              }
              const patch = {
                name: nextName,
                columnName: nextName,
                type: row.type || 'string',
                nullable: row.nullable !== false,
                primaryKey: !!row.primaryKey,
                unique: !!row.unique,
                index: !!row.index,
                defaultValue: undefined,
                maxLength: undefined,
                precision: undefined,
                scale: undefined
              };
              if(typeSupportsLength(patch.type)){
                const lengthValue = Number(row.length);
                patch.maxLength = Number.isFinite(lengthValue) && lengthValue > 0 ? lengthValue : undefined;
              }
              if(typeSupportsPrecision(patch.type)){
                const precisionValue = Number(row.precision);
                const scaleValue = Number(row.scale);
                patch.precision = Number.isFinite(precisionValue) && precisionValue > 0 ? precisionValue : undefined;
                patch.scale = Number.isFinite(scaleValue) && scaleValue >= 0 ? scaleValue : undefined;
              }
              if(row.defaultValue != null && row.defaultValue !== ''){
                if(['integer','number','decimal','float'].includes(patch.type)){
                  const num = Number(row.defaultValue);
                  patch.defaultValue = Number.isNaN(num) ? row.defaultValue : num;
                } else if(patch.type === 'boolean'){
                  patch.defaultValue = ['true','1','yes','on'].includes(String(row.defaultValue).toLowerCase());
                } else {
                  patch.defaultValue = row.defaultValue;
                }
              }
              if(row.references && row.references.table && row.references.column){
                patch.references = {
                  table: row.references.table,
                  column: row.references.column,
                  onDelete: row.references.onDelete || 'CASCADE',
                  onUpdate: row.references.onUpdate || 'CASCADE'
                };
              } else {
                patch.references = null;
              }
              table.updateField(original, patch);
              if(original !== nextName) renameMap.set(original, nextName);
            });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to save columns', error);
            UI.pushToast(ctx, { title:'تعذر تحديث الأعمدة', message:String(error), icon:'🛑' });
            return;
          }
          const schemaJSON = registry.toJSON();
          let persistRecord = null;
          let nextState = null;
          ctx.setState(s=>{
            const now = Date.now();
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: schemaJSON,
              layout: s.data.layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            persistRecord = record;
            const refreshedTable = registry.get(tableName);
            const refreshedRows = buildColumnsFormRows(refreshedTable);
            let draft = {
              ...s,
              data:{
                ...s.data,
                schema: schemaJSON,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), columns:true },
                form:{ ...(s.ui?.form || {}), columns:{ table: tableName, rows: refreshedRows } }
              }
            };
            if(renameMap.size){
              const currentSelection = draft.data.selection || {};
              if(currentSelection.table === tableName && currentSelection.field && renameMap.has(currentSelection.field)){
                draft = withFieldSelection(draft, tableName, renameMap.get(currentSelection.field));
              }
            }
            nextState = draft;
            return draft;
          });
          ctx.rebuild();
          if(persistRecord) schedulePersist(recordFromState(nextState));
          UI.pushToast(ctx, { title:'تم حفظ الأعمدة بنجاح', icon:'✅' });
        }
      },
      'erd.relation.add':{
        on:['click'],
        gkeys:['erd:relation:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), relation:true },
              form:{ ...(s.ui?.form || {}), relation:{ sourceTable: selection.table || '', sourceField: selection.field || '', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.relation.create':{
        on:['click'],
        gkeys:['erd:relation:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.relation || {};
          if(!form.sourceTable || !form.sourceField || !form.targetTable || !form.targetField){
            UI.pushToast(ctx, { title:'الرجاء اختيار الحقول المصدر والهدف', icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(form.sourceTable);
          if(!table){
            UI.pushToast(ctx, { title:'الجدول المصدر غير موجود', icon:'⚠️' });
            return;
          }
          try{
            table.updateField(form.sourceField, {
              references:{
                table: form.targetTable,
                column: form.targetField,
                onDelete: form.onDelete || 'CASCADE',
                onUpdate: form.onUpdate || 'CASCADE'
              }
            });
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), relation:false } }
              };
              draft = withFieldSelection(draft, form.sourceTable, form.sourceField);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create relation', error);
            UI.pushToast(ctx, { title:'فشل إنشاء العلاقة', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.import.apply':{
        on:['click'],
        gkeys:['erd:import:apply'],
        handler:async (e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.import || {};
          const raw = form.text || '';
          try{
            const parsed = JSON.parse(raw);
            const schemaPayload = parsed.schema && parsed.schema.tables ? parsed.schema : parsed;
            const registry = Schema.Registry.fromJSON(schemaPayload);
            const normalizedSchema = registry.toJSON();
            const layout = computeLayout(registry, parsed.layout);
            const targetId = form.targetId || '';
            let existing = null;
            if(targetId){ existing = await SchemaLibrary.get(targetId); }
            const now = Date.now();
            const recordInput = {
              id: targetId || undefined,
              name: form.name || parsed.name || schemaPayload.name || `schema_${now}`,
              title: form.title || parsed.title || form.name || `مخطط ${now}`,
              description: parsed.description || '',
              schema: normalizedSchema,
              layout,
            canvas: normaliseCanvas(parsed.canvas || existing?.canvas || state.data.canvas),
              createdAt: existing?.createdAt,
              updatedAt: now
            };
            const saved = await SchemaLibrary.save(recordInput);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: saved.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: saved.id,
                schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' },
                schemaCreatedAt: saved.createdAt,
                schemaUpdatedAt: saved.updatedAt,
                schema: normalizedSchema,
                layout,
                selection:{ table:first, field:null },
            canvas: normaliseCanvas(saved.canvas || state.data.canvas),
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), import:false },
                form:{
                  ...(s.ui?.form || {}),
                  import:{ name:'', title:'', targetId:'', text:'' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'تم استيراد المخطط وتخزينه', icon:'✅' });
          } catch(error){
            console.warn('[Mishkah][ERD] import failed', error);
            UI.pushToast(ctx, { title:'تعذر استيراد JSON', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.layout.input':{
        on:['input','change'],
        gkeys:['erd:layout:input'],
        handler:(e,ctx)=>{
          const axis = e.target.getAttribute('data-axis');
          if(!axis) return;
          const value = Number(e.target.value);
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), form:{ ...(s.ui?.form || {}), layout:{ ...(s.ui?.form?.layout || {}), [axis]: Number.isFinite(value) ? value : 0 } } }
          }));
          ctx.rebuild();
        }
      },
      'erd.layout.apply':{
        on:['click'],
        gkeys:['erd:layout:apply'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          if(!selection.table){
            UI.pushToast(ctx, { title:'اختر جدولاً لتحديث موقعه', icon:'⚠️' });
            return;
          }
          const formLayout = state.ui?.form?.layout || { x:120, y:120 };
          let next;
          ctx.setState(s=>{
            const layout = Object.assign({}, s.data.layout || {});
            layout[selection.table] = { x: Number(formLayout.x) || 0, y: Number(formLayout.y) || 0 };
            const now = Date.now();
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              data:{
                ...s.data,
                layout,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.library.new':{
        on:['click'],
        gkeys:['erd:library:new'],
        handler:async (e,ctx)=>{
          try{
            const record = await SchemaLibrary.createBlank({ title:'مخطط جديد' });
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: normaliseCanvas(record.canvas),
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  table:{ name:'', nameInput:'', label:'', comment:'', includeId:true },
                  field:{ table:first || '', label:'', name:'', nameInput:'', nameManual:false, columnName:'', type:'string', nullable:true, primaryKey:false, unique:false, defaultValue:'', references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' } },
                  relation:{ sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'تم إنشاء مخطط جديد', icon:'✨' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create new schema', error);
            UI.pushToast(ctx, { title:'تعذر إنشاء المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.library.select':{
        on:['click'],
        gkeys:['erd:library:select'],
        handler:async (e,ctx)=>{
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId || schemaId === state.data.schemaId) return;
          try{
            const record = await SchemaLibrary.get(schemaId);
            if(!record){
              UI.pushToast(ctx, { title:'تعذر تحميل المخطط', icon:'🛑' });
              return;
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: normaliseCanvas(record.canvas),
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
          } catch(error){
            console.warn('[Mishkah][ERD] failed to select schema', error);
            UI.pushToast(ctx, { title:'فشل تحميل المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.library.delete':{
        on:['click'],
        gkeys:['erd:library:delete'],
        handler:async (e,ctx)=>{
          e.preventDefault();
          e.stopPropagation();
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId) return;
          const count = state.data.library?.items?.length || 0;
          if(count <= 1){
            UI.pushToast(ctx, { title:'لا يمكن حذف آخر مخطط', icon:'⚠️' });
            return;
          }
          try{
            await SchemaLibrary.remove(schemaId);
            let list = await SchemaLibrary.list();
            if(!list.length){
              const blank = await SchemaLibrary.createBlank({ title:'مخطط جديد' });
              list = [blank];
            }
            let record = null;
            if(schemaId === state.data.schemaId){
              record = list[0];
            } else {
              record = await SchemaLibrary.get(state.data.schemaId) || list[0];
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: normaliseCanvas(record.canvas),
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'تم حذف المخطط', icon:'🗑️' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to delete schema', error);
            UI.pushToast(ctx, { title:'تعذر حذف المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.schema.meta.open':{
        on:['click'],
        gkeys:['erd:schema:meta:open'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), schemaMeta:true },
              form:{ ...(s.ui?.form || {}), schemaMeta:{ ...(s.data.schemaMeta || {}) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.schema.meta.save':{
        on:['click'],
        gkeys:['erd:schema:meta:save'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const form = s.ui?.form?.schemaMeta || {};
            const now = Date.now();
            const meta = {
              name: (form.name || s.data.schemaMeta?.name || '').trim() || `schema_${s.data.schemaId?.slice(-4) || 'new'}`,
              title: (form.title || form.name || s.data.schemaMeta?.title || '').trim() || 'مخطط جديد',
              description: (form.description || '').trim()
            };
            const record = {
              id: s.data.schemaId,
              name: meta.name,
              title: meta.title,
              description: meta.description,
              schema: s.data.schema,
              layout: s.data.layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              head:{ ...(s.head || {}), title: meta.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaMeta: meta,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), schemaMeta:false },
                form:{ ...(s.ui?.form || {}), schemaMeta: meta }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      }
    };

    const app = M.app.createApp(erdState, {});
    const auto = U.twcss.auto(erdState, app, { pageScaffold:true });

    M.app.setBody(AppView);

    app.setOrders(Object.assign({}, UI.orders, auto.orders, erdOrders));
    app.mount('#app');
  })();
  </script>
</body>
</html>
