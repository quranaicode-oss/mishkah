<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>مخطط قاعدة بيانات مشكاة</title>
  <style>
    :root {
      color-scheme: light dark;
      --background: #f8fafc;
      --surface-0: #f8fafc;
      --surface-1: #ffffff;
      --surface-2: #eef2ff;
      --card: #ffffff;
      --card-foreground: #0f172a;
      --foreground: #0f172a;
      --muted: #475569;
      --muted-foreground: #475569;
      --border: #cfd8ea;
      --input: #dbe3f8;
      --accent: #eaf2ff;
      --accent-foreground: #102341;
      --primary: #2563eb;
      --primary-foreground: #f8fafc;
      --secondary: #d8e1ff;
      --secondary-foreground: #102341;
      --destructive: #ef4444;
      --destructive-foreground: #ffffff;
      --ring: #2563eb;
      --shadow: 0 28px 60px -28px rgba(15, 23, 42, 0.35);
      --radius: 16px;
    }
    :root.dark {
      color-scheme: dark;
      --background: #0b1220;
      --surface-0: #0b1220;
      --surface-1: #101a2c;
      --surface-2: #16243a;
      --card: #111d30;
      --card-foreground: #e2e8f0;
      --foreground: #f8fafc;
      --muted: #94a3b8;
      --muted-foreground: #94a3b8;
      --border: #1f2a3d;
      --input: #223044;
      --accent: #1e2a3f;
      --accent-foreground: #e2e8f0;
      --primary: #60a5fa;
      --primary-foreground: #0b1220;
      --secondary: #27364e;
      --secondary-foreground: #e2e8f0;
      --destructive: #f87171;
      --destructive-foreground: #0b1220;
      --ring: #60a5fa;
      --shadow: 0 30px 70px -36px rgba(8, 15, 30, 0.75);
      --radius: 16px;
    }
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      height: 100%;
      min-height: 100vh;
      margin: 0;
      background: var(--background, #0f1115);
      color: var(--foreground, #f8fafc);
      font-family: "Tajawal", "Cairo", system-ui, sans-serif;
      transition: background-color 160ms ease, color 160ms ease;
    }
    body { display: flex; min-height: 100vh; }
    #app { flex: 1 1 auto; display: flex; }
    textarea[readonly] { user-select: all; }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/@antv/x6@1.35.3/dist/x6.css"/>
  <script src="./mishkah-utils.js"></script>
  <script src="./mishkah.core.js"></script>
  <script src="./mishkah-ui.js"></script>
  <script src="./mishkah-schema.js"></script>
</head>
<body>
  <div id="app"></div>
  <script>
  (async function(){
    const M = Mishkah;
    const UI = M.UI;
    const U = M.utils;
    const D = M.DSL;
    const Schema = M.schema;
    const { tw } = U.twcss;
    const Text = U.Text || {};

    const X6_CDN_SOURCES = [
      'https://unpkg.com/@antv/x6@1.35.3/dist/x6.js',
      'https://cdn.jsdelivr.net/npm/@antv/x6@1.35.3/dist/x6.js'
    ];

    function loadScriptOnce(url){
      return new Promise((resolve, reject)=>{
        if(typeof document === 'undefined'){
          reject(new Error('document unavailable'));
          return;
        }
        const existing = document.querySelector(`script[data-mishkah-loader="${url}"]`);
        if(existing){
          if(existing.getAttribute('data-loaded') === 'true'){
            resolve();
            return;
          }
          existing.addEventListener('load', ()=> resolve(), { once:true });
          existing.addEventListener('error', ()=> reject(new Error(`Failed to load script: ${url}`)), { once:true });
          return;
        }
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.setAttribute('data-mishkah-loader', url);
        script.addEventListener('load', ()=>{
          script.setAttribute('data-loaded', 'true');
          resolve();
        }, { once:true });
        script.addEventListener('error', ()=>{
          script.remove();
          reject(new Error(`Failed to load script: ${url}`));
        }, { once:true });
        document.head.appendChild(script);
      });
    }

    async function ensureX6Library(){
      if(typeof window === 'undefined') return false;
      if(window.X6?.Graph) return true;
      if(window.__mishkahX6Loading){
        try { await window.__mishkahX6Loading; }
        catch(error){ console.warn('[Mishkah][ERD] X6 preload failed', error); }
        return !!(window.X6?.Graph);
      }
      window.__mishkahX6Loading = (async ()=>{
        for(const url of X6_CDN_SOURCES){
          try {
            await loadScriptOnce(url);
            if(window.X6?.Graph) return true;
          } catch(error){
            console.warn('[Mishkah][ERD] failed to load X6 source', url, error);
          }
        }
        return !!(window.X6?.Graph);
      })();
      try {
        const ready = await window.__mishkahX6Loading;
        return ready;
      } catch(error){
        console.warn('[Mishkah][ERD] X6 loader encountered an error', error);
        return !!(window.X6?.Graph);
      }
    }

    const x6Available = await ensureX6Library();
    if(!x6Available){
      console.warn('[Mishkah][ERD] AntV X6 library is not available, diagram will use fallback driver.');
    }

    let erdAppInstance = null;
    let erdDriver = null;
    let activeDriverName = null;
    let pendingDiagramFrame = false;
    let lastDiagramState = null;
    let applyingAutoZoom = false;

    function applyAutoZoom(targetZoom){
      if(!erdAppInstance) return;
      const zoom = Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, Number(targetZoom) || 1));
      if(applyingAutoZoom) return;
      const state = erdAppInstance.getState();
      const currentZoom = state?.data?.canvas?.zoom || 1;
      if(Math.abs(currentZoom - zoom) < 0.01) return;
      applyingAutoZoom = true;
      try {
        erdAppInstance.setState(s => ({
          ...s,
          data:{
            ...s.data,
            canvas:{ ...(s.data.canvas || {}), zoom, mode:'auto' },
          },
        }));
        erdAppInstance.rebuild();
      } finally {
        applyingAutoZoom = false;
      }
    }

    const TABLE_WIDTH = 280;
    const HEADER_HEIGHT = 48;
    const ROW_HEIGHT = 28;
    const AUTO_LAYOUT_ORIGIN_X = 120;
    const AUTO_LAYOUT_ORIGIN_Y = 120;
    const AUTO_LAYOUT_COLUMN_GAP = TABLE_WIDTH + 80;
    const AUTO_LAYOUT_ROW_GAP = 220;
    const MIN_CANVAS_ZOOM = 0.2;
    const MAX_CANVAS_ZOOM = 1;

    function computeTableHeight(fieldCount){
      const rows = Math.max(1, Number(fieldCount) || 0);
      return Math.max(HEADER_HEIGHT + rows * ROW_HEIGHT, HEADER_HEIGHT + ROW_HEIGHT);
    }

    function computeGridPosition(index, total){
      const columns = Math.max(1, Math.ceil(Math.sqrt(Math.max(1, total || 1))));
      const col = index % columns;
      const row = Math.floor(index / columns);
      return {
        x: AUTO_LAYOUT_ORIGIN_X + col * AUTO_LAYOUT_COLUMN_GAP,
        y: AUTO_LAYOUT_ORIGIN_Y + row * AUTO_LAYOUT_ROW_GAP,
      };
    }

    function normalisePoint(point, fallback){
      if(point && Number.isFinite(Number(point.x)) && Number.isFinite(Number(point.y))){
        return { x: Number(point.x), y: Number(point.y) };
      }
      return { x: fallback.x, y: fallback.y };
    }

    function computeLayoutBounds(nodes){
      if(!Array.isArray(nodes) || !nodes.length){
        return { width: 0, height: 0, minX: 0, minY: 0, maxX: 0, maxY: 0 };
      }
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      nodes.forEach(node => {
        const x = Number(node.x) || 0;
        const y = Number(node.y) || 0;
        const width = Number(node.width) || 0;
        const height = Number(node.height) || 0;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + width);
        maxY = Math.max(maxY, y + height);
      });
      return { minX, minY, maxX, maxY, width: Math.max(0, maxX - minX), height: Math.max(0, maxY - minY) };
    }

    function recommendZoomForBounds(bounds, viewportWidth, viewportHeight){
      if(!bounds || bounds.width <= 0 || bounds.height <= 0){
        return 1;
      }
      const width = Math.max(1, viewportWidth || 0);
      const height = Math.max(1, viewportHeight || 0);
      const paddedWidth = bounds.width + AUTO_LAYOUT_COLUMN_GAP;
      const paddedHeight = bounds.height + AUTO_LAYOUT_ROW_GAP;
      const scaleX = width ? width / paddedWidth : 1;
      const scaleY = height ? height / paddedHeight : 1;
      const zoom = Math.min(1, scaleX, scaleY);
      return Math.max(MIN_CANVAS_ZOOM, Number.isFinite(zoom) ? zoom : 1);
    }

    function normaliseCanvas(canvas){
      const source = canvas || {};
      const rawZoom = Number(source.zoom);
      const zoom = Number.isFinite(rawZoom) ? Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, rawZoom)) : 1;
      const mode = source.mode === 'manual' ? 'manual' : 'auto';
      return { ...source, zoom, mode };
    }

    function layoutsDiffer(current, computed){
      const currentMap = current || {};
      const computedMap = computed || {};
      const currentKeys = Object.keys(currentMap);
      const computedKeys = Object.keys(computedMap);
      if(currentKeys.length !== computedKeys.length) return true;
      return computedKeys.some(key => {
        const a = currentMap[key];
        const b = computedMap[key];
        if(!a || !b) return true;
        return Number(a.x) !== Number(b.x) || Number(a.y) !== Number(b.y);
      });
    }

    const FIELD_TYPE_OPTIONS = [
      { value:'string', label:'String (varchar)' },
      { value:'text', label:'Text' },
      { value:'integer', label:'Integer' },
      { value:'number', label:'Numeric (precision/scale)' },
      { value:'decimal', label:'Decimal' },
      { value:'float', label:'Float / double precision' },
      { value:'boolean', label:'Boolean' },
      { value:'date', label:'Date' },
      { value:'datetime', label:'Datetime' },
      { value:'timestamp', label:'Timestamp with timezone' },
      { value:'json', label:'JSONB' },
      { value:'uuid', label:'UUID' }
    ];

    const RELATION_ACTION_OPTIONS = ['CASCADE','RESTRICT','SET NULL','NO ACTION'];

    const clone = (U.JSON && U.JSON.clone) ? U.JSON.clone : (obj => JSON.parse(JSON.stringify(obj)));

    class SvgDriver {
      constructor(){
        this.container = null;
        this.hooks = {};
        this.svg = null;
        this.viewport = null;
        this.wrapper = null;
        this.defs = null;
        this.lastState = null;
        this.baseBBox = null;
        this.overrideFitPadding = null;
        this.dragContext = null;
      }

      init(container, hooks){
        this.container = container;
        this.hooks = hooks || {};
        if(container) container.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'm-erd-svg-wrapper';
        Object.assign(wrapper.style, {
          position: 'relative',
          width: '100%',
          height: '100%',
          overflow: 'hidden'
        });
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.setAttribute('class', 'm-erd-svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        const defs = document.createElementNS(svgNS, 'defs');
        const marker = document.createElementNS(svgNS, 'marker');
        marker.setAttribute('id', 'm-erd-arrow');
        marker.setAttribute('viewBox', '0 0 12 12');
        marker.setAttribute('refX', '10');
        marker.setAttribute('refY', '6');
        marker.setAttribute('markerUnits', 'strokeWidth');
        marker.setAttribute('markerWidth', '8');
        marker.setAttribute('markerHeight', '8');
        marker.setAttribute('orient', 'auto');
        const markerPath = document.createElementNS(svgNS, 'path');
        markerPath.setAttribute('d', 'M 0 0 L 12 6 L 0 12 z');
        markerPath.setAttribute('fill', 'currentColor');
        marker.appendChild(markerPath);
        defs.appendChild(marker);
        svg.appendChild(defs);
        const viewport = document.createElementNS(svgNS, 'g');
        viewport.setAttribute('class', 'm-erd-viewport');
        svg.appendChild(viewport);
        wrapper.appendChild(svg);
        if(container) container.appendChild(wrapper);
        this.wrapper = wrapper;
        this.svg = svg;
        this.viewport = viewport;
        this.defs = defs;
        this.baseBBox = null;
        this.lastState = null;
        this.overrideFitPadding = null;
      }

      clear(){
        if(!this.viewport) return;
        while(this.viewport.firstChild){
          this.viewport.removeChild(this.viewport.firstChild);
        }
      }

      clientPointToSvg(clientX, clientY){
        if(!this.svg) return null;
        const point = this.svg.createSVGPoint();
        point.x = clientX;
        point.y = clientY;
        const ctm = this.svg.getScreenCTM();
        if(!ctm) return null;
        const transformed = point.matrixTransform(ctm.inverse());
        return { x: transformed.x, y: transformed.y };
      }

      attachNodeInteractions(group, node){
        if(!group) return;
        group.style.cursor = 'move';
        group.style.touchAction = 'none';
        const handlePointerDown = event => {
          if(event.button && event.button !== 0) return;
          event.preventDefault();
          event.stopPropagation();
          const origin = this.clientPointToSvg(event.clientX, event.clientY);
          if(!origin) return;
          const pointerId = event.pointerId;
          if(group.setPointerCapture && pointerId != null){
            try { group.setPointerCapture(pointerId); }
            catch(_){}
          }
          this.dragContext = {
            node,
            group,
            pointerId,
            offsetX: origin.x - node.x,
            offsetY: origin.y - node.y,
          };
          const target = this.svg?.ownerDocument || document;
          target.addEventListener('pointermove', handlePointerMove);
          target.addEventListener('pointerup', handlePointerUp);
          target.addEventListener('pointercancel', handlePointerUp);
        };

        const handlePointerMove = event => {
          if(!this.dragContext || (event.pointerId != null && this.dragContext.pointerId != null && event.pointerId !== this.dragContext.pointerId)){
            return;
          }
          event.preventDefault();
          const point = this.clientPointToSvg(event.clientX, event.clientY);
          if(!point) return;
          const nextX = point.x - this.dragContext.offsetX;
          const nextY = point.y - this.dragContext.offsetY;
          this.dragContext.node.x = nextX;
          this.dragContext.node.y = nextY;
          this.dragContext.group.setAttribute('transform', `translate(${nextX} ${nextY})`);
        };

        const handlePointerUp = event => {
          if(!this.dragContext || (event.pointerId != null && this.dragContext.pointerId != null && event.pointerId !== this.dragContext.pointerId)){
            return;
          }
          const context = this.dragContext;
          this.dragContext = null;
          const target = this.svg?.ownerDocument || document;
          target.removeEventListener('pointermove', handlePointerMove);
          target.removeEventListener('pointerup', handlePointerUp);
          target.removeEventListener('pointercancel', handlePointerUp);
          if(context.group.releasePointerCapture && context.pointerId != null){
            try { context.group.releasePointerCapture(context.pointerId); }
            catch(_){}
          }
          const roundedX = Math.round(context.node.x);
          const roundedY = Math.round(context.node.y);
          context.group.setAttribute('transform', `translate(${roundedX} ${roundedY})`);
          context.node.x = roundedX;
          context.node.y = roundedY;
          this.hooks?.onNodeMove?.({ id: String(context.node.id), x: roundedX, y: roundedY });
        };

        group.addEventListener('pointerdown', handlePointerDown);
      }

      computeBoundingBox(nodes){
        if(!nodes.length){
          return {
            minX: 0,
            minY: 0,
            maxX: 640,
            maxY: 480
          };
        }
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        nodes.forEach(node => {
          minX = Math.min(minX, node.x);
          minY = Math.min(minY, node.y);
          maxX = Math.max(maxX, node.x + node.width);
          maxY = Math.max(maxY, node.y + node.height);
        });
        return { minX, minY, maxX, maxY };
      }

      setViewBox(bbox, zoom, padding){
        if(!this.svg) return;
        const baseWidth = Math.max(1, (bbox.maxX - bbox.minX));
        const baseHeight = Math.max(1, (bbox.maxY - bbox.minY));
        const pad = Math.max(16, padding != null ? padding : 120);
        const centerX = bbox.minX + baseWidth / 2;
        const centerY = bbox.minY + baseHeight / 2;
        let viewWidth = baseWidth + pad * 2;
        let viewHeight = baseHeight + pad * 2;
        let viewX = centerX - viewWidth / 2;
        let viewY = centerY - viewHeight / 2;
        if(this.overrideFitPadding != null){
          const fitPad = Math.max(16, this.overrideFitPadding);
          viewWidth = baseWidth + fitPad * 2;
          viewHeight = baseHeight + fitPad * 2;
          viewX = bbox.minX - fitPad;
          viewY = bbox.minY - fitPad;
          this.overrideFitPadding = null;
        } else if(zoom && Number.isFinite(zoom) && zoom !== 1){
          const safeZoom = Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, zoom));
          viewWidth = viewWidth / safeZoom;
          viewHeight = viewHeight / safeZoom;
          viewX = centerX - viewWidth / 2;
          viewY = centerY - viewHeight / 2;
        }
        this.svg.setAttribute('viewBox', `${viewX} ${viewY} ${viewWidth} ${viewHeight}`);
        this.baseBBox = Object.assign({}, bbox, { pad });
      }

      render(state){
        if(!this.svg || !this.viewport) return;
        this.lastState = state;
        const tables = Array.isArray(state?.tables) ? state.tables : [];
        const relations = Array.isArray(state?.relations) ? state.relations : [];
        const layout = state?.layout || {};
        const selection = state?.selection || {};
        const palette = state?.palette || {};
        const zoom = state?.zoom;

        this.clear();
        console.debug('[Mishkah][ERD] SVG driver render', tables.length, 'tables');

        const svgNS = 'http://www.w3.org/2000/svg';
        if(this.defs && typeof this.defs.querySelectorAll === 'function'){
          const dynamicDefs = Array.from(this.defs.querySelectorAll('clipPath[data-m-erd-dynamic="true"]'));
          dynamicDefs.forEach(def => def.remove());
        }
        const nodes = tables.map((table, index)=>{
          const total = Math.max(1, tables.length);
          const fallback = computeGridPosition(index, total);
          const source = layout[table.id] || layout[table.name];
          const { x, y } = normalisePoint(source, fallback);
          const fields = Array.isArray(table.fields) ? table.fields : [];
          const width = TABLE_WIDTH;
          const height = computeTableHeight(fields.length);
          const fieldMap = new Map();
          fields.forEach((field, idx)=>{
            const centerY = HEADER_HEIGHT + ROW_HEIGHT * idx + ROW_HEIGHT / 2;
            fieldMap.set(field.name, centerY);
          });
          return {
            id: table.id,
            table,
            x,
            y,
            width,
            height,
            fields,
            fieldMap
          };
        });

        const bbox = this.computeBoundingBox(nodes);
        this.setViewBox(bbox, zoom, 120);

        const edgesGroup = document.createElementNS(svgNS, 'g');
        edgesGroup.setAttribute('class', 'm-erd-edges');
        const nodesGroup = document.createElementNS(svgNS, 'g');
        nodesGroup.setAttribute('class', 'm-erd-nodes');

        const colors = {
          tableStroke: palette.border || '#1f2a3d',
          tableFill: palette.card || '#111d30',
          headerFill: palette.primary || '#2563eb',
          headerText: palette.primaryForeground || '#f8fafc',
          fieldText: palette.foreground || '#f8fafc',
          edge: palette.accentForeground || '#60a5fa',
          background: palette.surface || '#101a2c'
        };

        const nodeLookup = new Map();

        nodes.forEach(node => {
          nodeLookup.set(node.id, node);
          const group = document.createElementNS(svgNS, 'g');
          group.setAttribute('data-node-id', node.id);
          group.setAttribute('transform', `translate(${node.x} ${node.y})`);

          const body = document.createElementNS(svgNS, 'rect');
          body.setAttribute('x', '0');
          body.setAttribute('y', '0');
          body.setAttribute('width', String(node.width));
          body.setAttribute('height', String(node.height));
          body.setAttribute('rx', '16');
          body.setAttribute('ry', '16');
          body.setAttribute('fill', colors.tableFill);
          body.setAttribute('stroke', selection.table === node.id ? (palette.primary || '#60a5fa') : colors.tableStroke);
          body.setAttribute('stroke-width', selection.table === node.id ? '2.4' : '1.6');

          const header = document.createElementNS(svgNS, 'rect');
          header.setAttribute('x', '0');
          header.setAttribute('y', '0');
          header.setAttribute('width', String(node.width));
          header.setAttribute('height', String(Math.max(HEADER_HEIGHT, 44)));
          header.setAttribute('rx', '16');
          header.setAttribute('ry', '16');
          header.setAttribute('fill', colors.headerFill);

          const title = document.createElementNS(svgNS, 'text');
          title.setAttribute('x', '18');
          title.setAttribute('y', '28');
          title.setAttribute('fill', colors.headerText);
          title.setAttribute('font-size', '14');
          title.setAttribute('font-weight', '700');
          title.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
          const tableMeta = node.table || {};
          title.textContent = tableMeta.displayName || tableMeta.label || tableMeta.name || node.id;

          const fieldTextGroup = document.createElementNS(svgNS, 'g');
          fieldTextGroup.setAttribute('transform', 'translate(0 0)');
          let clipId = null;
          if(this.defs){
            const safeId = String(node.id || tableMeta?.name || '') || `node-${index}`;
            clipId = `m-erd-clip-${safeId.replace(/[^a-zA-Z0-9_-]/g, '_')}`;
            const clipPath = document.createElementNS(svgNS, 'clipPath');
            clipPath.setAttribute('id', clipId);
            clipPath.setAttribute('data-m-erd-dynamic', 'true');
            const clipRect = document.createElementNS(svgNS, 'rect');
            const contentTop = Math.max(HEADER_HEIGHT, 44);
            clipRect.setAttribute('x', '0');
            clipRect.setAttribute('y', String(contentTop));
            clipRect.setAttribute('width', String(node.width));
            clipRect.setAttribute('height', String(Math.max(0, node.height - contentTop)));
            clipPath.appendChild(clipRect);
            this.defs.appendChild(clipPath);
          }
          if(clipId){
            fieldTextGroup.setAttribute('clip-path', `url(#${clipId})`);
          }

          node.fields.forEach((field, idx)=>{
            const fieldY = HEADER_HEIGHT + ROW_HEIGHT * idx + 18;
            const rowText = document.createElementNS(svgNS, 'text');
            rowText.setAttribute('x', '18');
            rowText.setAttribute('y', String(fieldY));
            rowText.setAttribute('fill', colors.fieldText);
            rowText.setAttribute('font-size', '12');
            rowText.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            rowText.textContent = field.type
              ? `${field.name} · ${field.type}`
              : field.name;
            fieldTextGroup.appendChild(rowText);
          });

          group.appendChild(body);
          group.appendChild(header);
          group.appendChild(title);
          group.appendChild(fieldTextGroup);
          this.attachNodeInteractions(group, node);
          nodesGroup.appendChild(group);
        });

        relations.forEach(rel => {
          const sourceNode = nodeLookup.get(rel.from?.table || rel.source?.table || '');
          const targetNode = nodeLookup.get(rel.to?.table || rel.target?.table || '');
          if(!sourceNode || !targetNode) return;
          const sourceFieldName = rel.from?.field || rel.source?.field;
          const targetFieldName = rel.to?.field || rel.target?.field;
          const sourceFieldY = sourceNode.fieldMap.get(sourceFieldName) || sourceNode.height / 2;
          const targetFieldY = targetNode.fieldMap.get(targetFieldName) || targetNode.height / 2;
          const forward = (sourceNode.x + sourceNode.width) <= targetNode.x;
          const backward = targetNode.x + targetNode.width <= sourceNode.x;
          const startX = forward ? sourceNode.x + sourceNode.width : (backward ? sourceNode.x : sourceNode.x + sourceNode.width / 2);
          const endX = forward ? targetNode.x : (backward ? targetNode.x + targetNode.width : targetNode.x + targetNode.width / 2);
          const startY = sourceNode.y + sourceFieldY;
          const endY = targetNode.y + targetFieldY;
          const margin = 32;
          const segments = [`M ${startX} ${startY}`];
          if(forward || backward){
            const exitX = forward ? sourceNode.x + sourceNode.width + margin : sourceNode.x - margin;
            const entryX = forward ? targetNode.x - margin : targetNode.x + targetNode.width + margin;
            const midY = startY + (endY - startY) / 2;
            segments.push(`L ${exitX} ${startY}`);
            segments.push(`L ${exitX} ${midY}`);
            segments.push(`L ${entryX} ${midY}`);
            segments.push(`L ${entryX} ${endY}`);
          } else {
            const verticalDirection = endY >= startY ? 1 : -1;
            const exitY = verticalDirection > 0
              ? Math.max(startY + margin, sourceNode.y + sourceNode.height + margin)
              : Math.min(startY - margin, sourceNode.y - margin);
            const entryY = verticalDirection > 0
              ? Math.min(endY - margin, targetNode.y - margin)
              : Math.max(endY + margin, targetNode.y + targetNode.height + margin);
            const midX = startX + (endX - startX) / 2;
            segments.push(`L ${startX} ${exitY}`);
            segments.push(`L ${midX} ${exitY}`);
            segments.push(`L ${midX} ${entryY}`);
            segments.push(`L ${endX} ${entryY}`);
          }
          segments.push(`L ${endX} ${endY}`);
          const path = document.createElementNS(svgNS, 'path');
          path.setAttribute('d', segments.join(' '));
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', colors.edge);
          path.setAttribute('stroke-width', '1.8');
          path.setAttribute('marker-end', 'url(#m-erd-arrow)');
          path.setAttribute('style', `color:${colors.edge}`);
          edgesGroup.appendChild(path);

          if(rel.cardinality){
            const label = document.createElementNS(svgNS, 'text');
            const labelX = (startX + endX) / 2;
            const labelY = (startY + endY) / 2 - 6;
            label.setAttribute('x', String(labelX));
            label.setAttribute('y', String(labelY));
            label.setAttribute('fill', colors.fieldText);
            label.setAttribute('font-size', '11');
            label.setAttribute('font-weight', '600');
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            label.textContent = rel.cardinality;
            edgesGroup.appendChild(label);
          }
        });

        this.viewport.appendChild(edgesGroup);
        this.viewport.appendChild(nodesGroup);
      }

      fitToScreen(padding = 16){
        this.overrideFitPadding = padding;
        if(this.lastState){
          this.render(this.lastState);
        }
      }

      undo(){}
      redo(){}

      async exportSVG(){
        if(!this.svg) return '<svg />';
        const serializer = new XMLSerializer();
        return serializer.serializeToString(this.svg);
      }

      async exportPNG(opts = {}){
        if(!this.svg) return new Blob();
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(this.svg);
        const svgBlob = new Blob([svgString], { type:'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);
        try {
          const image = new Image();
          const width = opts.width || this.wrapper?.clientWidth || 1600;
          const height = opts.height || this.wrapper?.clientHeight || 900;
          await new Promise((resolve, reject)=>{
            image.onload = resolve;
            image.onerror = reject;
            image.src = url;
          });
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          if(opts.background){
            ctx.fillStyle = opts.background;
            ctx.fillRect(0, 0, width, height);
          }
          ctx.drawImage(image, 0, 0, width, height);
          const blob = await new Promise((resolve, reject)=>{
            canvas.toBlob(result => {
              if(result) resolve(result);
              else reject(new Error('Failed to export PNG'));
            });
          });
          return blob;
        } finally {
          URL.revokeObjectURL(url);
        }
      }

      destroy(){
        if(this.container) this.container.innerHTML = '';
        this.container = null;
        this.svg = null;
        this.viewport = null;
        this.wrapper = null;
        this.defs = null;
        this.lastState = null;
        this.baseBBox = null;
        this.overrideFitPadding = null;
      }
    }

    class X6Driver {
      constructor(){
        this.graph = null;
        this.hooks = null;
        this.initialized = false;
      }

      init(container, hooks){
        this.hooks = hooks || {};
        const Graph = window?.X6?.Graph;
        if(!Graph){
          console.warn('[Mishkah][ERD] AntV X6 Graph not available, falling back to FakeDriver');
          throw new Error('X6 not available');
        }
        this.graph = new Graph({
          container,
          grid: true,
          scroller: { enabled: true, pannable: true, minScale: MIN_CANVAS_ZOOM, maxScale: MAX_CANVAS_ZOOM },
          mousewheel: { enabled: true, modifiers: ['ctrl','meta'], minScale: MIN_CANVAS_ZOOM, maxScale: MAX_CANVAS_ZOOM },
          history: { enabled: true },
          selecting: { enabled: true, multiple: true, rubberband: true },
          keyboard: { enabled: true },
          clipboard: { enabled: true },
          snapline: { enabled: true },
          connecting: {
            allowBlank: false,
            allowLoop: false,
            snap: true,
            router: { name: 'manhattan' },
            connector: { name: 'rounded' },
            validateConnection: ({ sourceMagnet, targetMagnet }) => !!(sourceMagnet && targetMagnet),
          },
        });

        this.graph.on('node:change:position', ({ node }) => {
          const { x, y } = node.getPosition();
          this.hooks?.onNodeMove?.({ id: String(node.id), x, y });
        });

        this.graph.on('selection:changed', ({ selected }) => {
          if(!selected) return;
          const ids = selected
            .filter(cell => cell && typeof cell.isNode === 'function' && cell.isNode())
            .map(cell => String(cell.id));
          this.hooks?.onSelect?.(ids);
        });

        this.graph.on('edge:connected', ({ edge, isNew }) => {
          if(!edge) return;
          const meta = edge.getData ? edge.getData() : null;
          if(meta?.hydrated){
            edge.setData({ ...meta, hydrated: false });
            return;
          }
          if(isNew === false) return;
          const source = edge.getSource();
          const target = edge.getTarget();
          if(!source || !target) return;
          this.hooks?.onEdgeConnect?.({
            source: { id: String(source.cell), port: String(source.port) },
            target: { id: String(target.cell), port: String(target.port) },
          });
        });
      }

      render(state){
        if(!this.graph) return;
        const layout = state?.layout || {};
        const tables = Array.isArray(state?.tables) ? state.tables : [];
        const relations = Array.isArray(state?.relations) ? state.relations : [];
        const nodes = tables.map((tbl, index) => {
          const total = Math.max(1, tables.length);
          const fallback = computeGridPosition(index, total);
          const { x, y } = normalisePoint(layout[tbl.id], fallback);
          const position = { x, y };
          const fields = Array.isArray(tbl.fields) ? tbl.fields : [];
          const lines = fields.map(field => {
            const typeSuffix = field.type ? ` : ${field.type}` : '';
            return `• ${field.name}${typeSuffix}`;
          });
          const title = tbl.displayName || tbl.label || tbl.name || tbl.id;
          const bodyText = lines.length ? `${title}\n${lines.join('\n')}` : title;
          return {
            id: tbl.id,
            shape: 'rect',
            x: position.x,
            y: position.y,
            width: 260,
            height: Math.max(60, 32 + 24 * fields.length),
            data: { hydrated: true },
            attrs: {
              body: { fill: '#0ea5e9', stroke: '#0284c7', rx: 12, ry: 12 },
              label: {
                text: bodyText,
                fill: '#f8fafc',
                fontSize: 12,
                fontWeight: 600,
                lineHeight: 1.4,
                textAnchor: 'start',
                refX: 12,
                refY: 16,
              },
            },
            ports: {
              groups: {
                in: {
                  position: 'left',
                  attrs: { circle: { r: 4, magnet: true, stroke: '#0f172a', fill: '#f8fafc' } },
                },
                out: {
                  position: 'right',
                  attrs: { circle: { r: 4, magnet: true, stroke: '#0f172a', fill: '#f8fafc' } },
                },
              },
              items: fields.map((field, index) => ({
                id: `${tbl.id}:${field.name}`,
                group: index % 2 === 0 ? 'out' : 'in',
                attrs: {
                  circle: {
                    title: `${field.name}${field.type ? ` (${field.type})` : ''}`,
                  },
                },
              })),
            },
          };
        });

        const edges = relations.map(rel => ({
          id: rel.id || `${rel.from.table}:${rel.from.field}→${rel.to.table}:${rel.to.field}`,
          shape: 'edge',
          source: { cell: rel.from.table, port: `${rel.from.table}:${rel.from.field}` },
          target: { cell: rel.to.table, port: `${rel.to.table}:${rel.to.field}` },
          router: { name: 'manhattan' },
          connector: { name: 'rounded' },
          attrs: { line: { stroke: '#0284c7', strokeWidth: 1.6 } },
          labels: rel.cardinality || rel.onDelete || rel.onUpdate ? [
            {
              attrs: {
                label: {
                  text: rel.cardinality || '1..*',
                  fill: '#0f172a',
                  background: {
                    fill: '#f8fafc',
                    stroke: '#94a3b8',
                    padding: 2,
                  },
                },
              },
            },
          ] : [],
          data: { hydrated: true },
        }));

        this.graph.fromJSON({ cells: [...nodes, ...edges] });

        const selection = state?.selection;
        if(selection?.table){
          const node = this.graph.getCellById(selection.table);
          if(node){
            this.graph.resetSelection(node);
          }
        }

        if(typeof state?.zoom === 'number' && Number.isFinite(state.zoom)){
          const safeZoom = Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, state.zoom));
          try { this.graph.zoomTo(safeZoom); }
          catch(error){ console.warn('[Mishkah][ERD] zoomTo failed', error); }
        }

        if(state?.canvasMode !== 'manual'){
          try { this.graph.centerContent(); }
          catch(error){ console.warn('[Mishkah][ERD] centerContent failed', error); }
        }

        if(!this.initialized){
          this.initialized = true;
        }
      }

      fitToScreen(padding = 16){
        if(!this.graph) return;
        this.graph.scaleContentToFit({ padding });
      }

      undo(){
        if(!this.graph) return;
        this.graph.history?.undo();
      }

      redo(){
        if(!this.graph) return;
        this.graph.history?.redo();
      }

      async exportSVG(){
        if(!this.graph) return '<svg />';
        return this.graph.toSVG({ preserveDimensions: true });
      }

      async exportPNG(opts = {}){
        if(!this.graph) return new Blob();
        const dataUrl = await this.graph.toPNG({
          backgroundColor: opts.background || '#ffffff',
          padding: 16,
          quality: 1,
        });
        const response = await fetch(dataUrl);
        return await response.blob();
      }

      destroy(){
        if(this.graph){
          this.graph.dispose();
          this.graph = null;
        }
      }
    }

    const DiagramDrivers = {
      fake: SvgDriver,
      x6: X6Driver,
    };

    function sanitizeSqlIdentifier(value){
      if(!value) return '';
      const snake = Schema.utils.toSnakeCase(value || '') || '';
      return snake
        .replace(/[^a-z0-9_]/g, '')
        .replace(/_{2,}/g, '_')
        .replace(/^_+|_+$/g, '')
        .slice(0, 64);
    }

    function identifierFromLabel(label, fallback){
      const sanitized = sanitizeSqlIdentifier(label || '');
      if(sanitized) return sanitized;
      if(Text && typeof Text.identifierFromArabic === 'function'){
        const derived = sanitizeSqlIdentifier(Text.identifierFromArabic(label, { fallback }));
        if(derived) return derived;
      }
      const fallbackBase = sanitizeSqlIdentifier(fallback || 'item');
      return fallbackBase || (fallback || 'item');
    }

    function formatIdentifier(value){
      if(!value) return '';
      return value
        .replace(/_/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/(^|\s)([a-z])/g, (_, space, ch)=> space + ch.toUpperCase());
    }

    function ensureUniqueTableName(registry, base){
      const clean = base || 'table';
      let candidate = clean;
      let index = 1;
      while(registry.get(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function ensureUniqueFieldName(table, base){
      const clean = base || 'field';
      if(!table) return clean;
      let candidate = clean;
      let index = 1;
      while(table.getField(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function computeTableIdentifier(registry, source){
      const fallback = `table_${registry.list().length + 1}`;
      const base = sanitizeSqlIdentifier(source || '') || identifierFromLabel(source, fallback);
      return ensureUniqueTableName(registry, base);
    }

    function computeFieldIdentifier(table, label){
      const fallback = `field_${(table?.fields?.length || 0) + 1}`;
      const base = identifierFromLabel(label, fallback);
      return ensureUniqueFieldName(table, base);
    }

    function currentPalette(){
      if(typeof window === 'undefined') return {};
      const computed = getComputedStyle(document.documentElement);
      const read = key => (computed.getPropertyValue(key) || '').trim();
      return {
        background: read('--background') || '#f8fafc',
        surface: read('--surface-2') || '#eef2ff',
        border: read('--border') || '#d7deed',
        foreground: read('--foreground') || '#0f172a',
        muted: read('--muted-foreground') || '#475569',
        accent: read('--accent') || '#eaf2ff',
        accentForeground: read('--accent-foreground') || '#102341',
        primary: read('--primary') || '#2563eb',
        primaryForeground: read('--primary-foreground') || '#f8fafc'
      };
    }

    function buildDriverStateSnapshot(state, host){
      const registry = getRegistry(state);
      const layout = computeLayout(registry, state.data.layout);
      const tables = registry.list().map(table => ({
        id: table.name,
        name: table.name,
        label: table.label || '',
        displayName: formatIdentifier(table.name),
        fields: (table.fields || []).map(field => ({
          name: field.name,
          type: field.type,
          pk: !!field.primaryKey,
          unique: !!field.unique,
          nullable: field.nullable !== false,
          default: field.defaultValue,
          references: field.references || null,
        })),
      }));
      const relations = [];
      registry.list().forEach(table => {
        (table.fields || []).forEach(field => {
          if(field.references && field.references.table){
            relations.push({
              id: `${table.name}:${field.name}→${field.references.table}:${field.references.column || field.references.field || 'id'}`,
              from: { table: table.name, field: field.name },
              to: {
                table: field.references.table,
                field: field.references.column || field.references.field || 'id',
              },
              cardinality: field.references.cardinality || '',
              onDelete: field.references.onDelete,
              onUpdate: field.references.onUpdate,
            });
          }
        });
      });
      const nodesMeta = tables.map((table, index) => {
        const total = Math.max(1, tables.length);
        const fallback = computeGridPosition(index, total);
        const point = layout[table.id] || layout[table.name];
        const { x, y } = normalisePoint(point, fallback);
        return {
          id: table.id,
          x,
          y,
          width: TABLE_WIDTH,
          height: computeTableHeight(table.fields.length),
        };
      });
      const bounds = computeLayoutBounds(nodesMeta);
      const canvasState = normaliseCanvas(state.data.canvas);
      const canvasMode = canvasState.mode || 'auto';
      const storedZoom = canvasState.zoom || 1;
      let zoom = storedZoom;
      if(canvasMode !== 'manual'){
        const viewportWidth = host?.clientWidth || (typeof window !== 'undefined' ? window.innerWidth : 0);
        const viewportHeight = host?.clientHeight || (typeof window !== 'undefined' ? window.innerHeight : 0);
        zoom = recommendZoomForBounds(bounds, viewportWidth, viewportHeight);
      }
      return {
        tables,
        relations,
        layout,
        selection: state.data.selection || {},
        zoom,
        canvasMode,
        storedZoom,
        bounds,
      };
    }

    function scheduleDiagramRender(state){
      lastDiagramState = state;
      if(pendingDiagramFrame) return;
      pendingDiagramFrame = true;
      requestAnimationFrame(()=>{
        pendingDiagramFrame = false;
        const snapshot = erdAppInstance ? erdAppInstance.getState() : lastDiagramState;
        if(snapshot) renderDiagram(snapshot);
      });
    }

    function ensureDriverInstance(state){
      if(typeof window === 'undefined') return null;
      const host = document.getElementById('erd-diagram');
      if(!host) return null;
      const driverKey = (state?.env?.graph?.driver || 'fake').toLowerCase();
      if(erdDriver && activeDriverName === driverKey){
        return erdDriver;
      }
      if(erdDriver){
        try { erdDriver.destroy(); }
        catch(error){ console.warn('[Mishkah][ERD] driver destroy failed', error); }
        erdDriver = null;
      }
      const DriverCtor = DiagramDrivers[driverKey] || DiagramDrivers.fake;
      try {
        const instance = new DriverCtor();
        instance.init(host, {
          onNodeMove: handleDriverNodeMove,
          onSelect: handleDriverSelect,
          onEdgeConnect: handleDriverEdgeConnect,
        });
        erdDriver = instance;
        activeDriverName = driverKey;
        host.setAttribute('data-driver', driverKey);
        return erdDriver;
      } catch(error){
        console.warn('[Mishkah][ERD] failed to initialise driver', driverKey, error);
        if(driverKey !== 'fake'){
          try {
            const fallback = new SvgDriver();
            fallback.init(host, {
              onNodeMove: handleDriverNodeMove,
              onSelect: handleDriverSelect,
              onEdgeConnect: handleDriverEdgeConnect,
            });
            erdDriver = fallback;
            activeDriverName = 'fake';
            host.setAttribute('data-driver', 'fake');
            return erdDriver;
          } catch(fallbackError){
            console.error('[Mishkah][ERD] failed to initialise FakeDriver', fallbackError);
          }
        }
        return null;
      }
    }

    function renderDiagram(state){
      if(!state || typeof window === 'undefined') return;
      const host = document.getElementById('erd-diagram');
      if(!host) return;
      const driver = ensureDriverInstance(state);
      if(!driver) return;
      const payload = buildDriverStateSnapshot(state, host);
      if(layoutsDiffer(state.data.layout, payload.layout)){
        erdAppInstance.setState(s => ({
          ...s,
          data:{
            ...s.data,
            layout: payload.layout,
          },
        }));
        erdAppInstance.rebuild();
      }
      const palette = currentPalette();
      payload.palette = palette;
      host.style.background = palette.background || '#f8fafc';
      if(payload.canvasMode !== 'manual' && Math.abs(payload.zoom - (payload.storedZoom || 0)) > 0.01){
        applyAutoZoom(payload.zoom);
      }
      try {
        driver.render(payload);
      } catch(error){
        console.warn('[Mishkah][ERD] driver render failed', error);
      }
    }

    function extractFieldFromPort(portId){
      if(!portId) return '';
      const parts = String(portId).split(':');
      if(parts.length <= 1) return parts[0] || '';
      return parts.slice(1).join(':');
    }

    function handleDriverNodeMove(position){
      if(!erdAppInstance || !position) return;
      const id = String(position.id || '');
      if(!id) return;
      const x = Math.round(Number(position.x) || 0);
      const y = Math.round(Number(position.y) || 0);
      let persistRecord = null;
      erdAppInstance.setState(s => {
        const layout = Object.assign({}, s.data.layout || {});
        const current = layout[id] || {};
        if(current.x === x && current.y === y){
          return s;
        }
        layout[id] = { x, y };
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: s.data.schema,
          layout,
          canvas: s.data.canvas,
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now,
        };
        persistRecord = record;
        return {
          ...s,
          data:{
            ...s.data,
            layout,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) },
          },
          ui:{
            ...(s.ui || {}),
            form:{
              ...(s.ui?.form || {}),
              layout:{ x, y },
            },
          },
        };
      });
      erdAppInstance.rebuild();
      if(persistRecord){
        schedulePersist(persistRecord);
      }
    }

    function handleDriverSelect(ids){
      if(!erdAppInstance) return;
      const list = Array.isArray(ids) ? ids : [];
      if(!list.length) return;
      const tableName = list[0];
      if(!tableName) return;
      erdAppInstance.setState(s => withTableSelection(s, tableName));
      erdAppInstance.rebuild();
    }

    function handleDriverEdgeConnect(connection){
      if(!erdAppInstance || !connection) return;
      const sourceTable = connection.source?.id ? String(connection.source.id) : '';
      const targetTable = connection.target?.id ? String(connection.target.id) : '';
      const sourceField = extractFieldFromPort(connection.source?.port);
      const targetField = extractFieldFromPort(connection.target?.port);
      if(!sourceTable || !sourceField || !targetTable || !targetField) return;
      let persistRecord = null;
      erdAppInstance.setState(s => {
        const registry = Schema.Registry.fromJSON(s.data.schema);
        const table = registry.get(sourceTable);
        if(!table) return s;
        const field = table.getField(sourceField);
        if(!field) return s;
        const currentRefs = field.references || {};
        try {
          table.updateField(sourceField, {
            references:{
              table: targetTable,
              column: targetField,
              onDelete: currentRefs.onDelete || 'CASCADE',
              onUpdate: currentRefs.onUpdate || 'CASCADE',
              cardinality: currentRefs.cardinality,
            },
          });
        } catch(error){
          console.warn('[Mishkah][ERD] failed to apply edge connection', error);
          return s;
        }
        const schemaJSON = registry.toJSON();
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: schemaJSON,
          layout: s.data.layout,
          canvas: s.data.canvas,
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now,
        };
        persistRecord = record;
        let draft = {
          ...s,
          data:{
            ...s.data,
            schema: schemaJSON,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) },
          },
        };
        draft = withFieldSelection(draft, sourceTable, sourceField);
        return draft;
      });
      erdAppInstance.rebuild();
      if(persistRecord){
        schedulePersist(persistRecord);
      }
    }


    const SchemaLibrary = (function(){
      const storeName = 'schemas';
      const AdapterClass = (U && (U.IndexedDBX || U.IndexedDB)) || null;
      const hasIndexedDB = typeof indexedDB !== 'undefined' && !!AdapterClass;
      const adapter = hasIndexedDB ? new AdapterClass({
        name:'mishkah-erd',
        version:1,
        schema:{
          stores:{
            [storeName]:{
              keyPath:'id',
              autoIncrement:false,
              indexes:{
                by_name:{ keyPath:'name', unique:true },
                by_updatedAt:{ keyPath:'updatedAt' },
                by_createdAt:{ keyPath:'createdAt' }
              }
            }
          }
        }
      }) : null;
      const memory = new Map();
      const status = hasIndexedDB ? 'indexeddb' : 'memory';

      const SEED_SCHEMA = {
        id:'schema_seed',
        name:'commerce_schema',
        title:'مخطط متجر إلكتروني',
        description:'مخطط افتراضي يوضح علاقة العملاء بالطلبات والمخزون والمدفوعات.',
        tables:[
          {
            name:'customers',
            label:'العملاء',
            layout:{ x:120, y:160 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'full_name', type:'string', nullable:false, maxLength:180, comment:'اسم العميل الكامل' },
              { name:'email', type:'string', nullable:false, unique:true, comment:'بريد إلكتروني فريد لكل عميل' },
              { name:'phone_number', type:'string', nullable:true, comment:'رقم للتواصل' },
              { name:'created_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'orders',
            label:'الطلبات',
            layout:{ x:420, y:160 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_number', type:'string', nullable:false, unique:true, comment:'رقم الطلب الظاهر للعميل' },
              { name:'customer_id', type:'uuid', nullable:false, references:{ table:'customers', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'status', type:'string', nullable:false, defaultValue:'pending', enum:['pending','processing','shipped','completed','cancelled'] },
              { name:'total_amount', type:'decimal', nullable:false, precision:12, scale:2 },
              { name:'placed_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'order_items',
            label:'بنود الطلبات',
            layout:{ x:720, y:200 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_id', type:'uuid', nullable:false, references:{ table:'orders', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'product_id', type:'uuid', nullable:false, references:{ table:'products', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'quantity', type:'integer', nullable:false, defaultValue:1 },
              { name:'unit_price', type:'decimal', nullable:false, precision:10, scale:2 },
              { name:'line_total', type:'decimal', nullable:false, precision:12, scale:2 }
            ]
          },
          {
            name:'products',
            label:'المنتجات',
            layout:{ x:420, y:360 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'name', type:'string', nullable:false, maxLength:160 },
              { name:'sku', type:'string', nullable:false, unique:true, comment:'معرّف فريد للمخزون' },
              { name:'price', type:'decimal', nullable:false, precision:10, scale:2 },
              { name:'stock_quantity', type:'integer', nullable:false, defaultValue:0 },
              { name:'category_id', type:'uuid', nullable:true, references:{ table:'categories', column:'id', onDelete:'SET NULL', onUpdate:'CASCADE' } },
              { name:'created_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'categories',
            label:'التصنيفات',
            layout:{ x:120, y:360 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'name', type:'string', nullable:false, unique:true },
              { name:'description', type:'text', nullable:true }
            ]
          },
          {
            name:'payments',
            label:'المدفوعات',
            layout:{ x:720, y:360 },
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_id', type:'uuid', nullable:false, references:{ table:'orders', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'payment_method', type:'string', nullable:false },
              { name:'paid_amount', type:'decimal', nullable:false, precision:12, scale:2 },
              { name:'paid_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          }
        ]
      };

      function buildSeedRecord(){
        const registry = new Schema.Registry({ tables: SEED_SCHEMA.tables });
        const tables = registry.list();
        const layout = {};
        tables.forEach((table, index) => {
          const fallback = computeGridPosition(index, tables.length);
          const source = table.layout || {};
          layout[table.name] = normalisePoint(source, fallback);
        });
        const now = Date.now();
        return {
          id: SEED_SCHEMA.id,
          name: SEED_SCHEMA.name,
          title: SEED_SCHEMA.title,
          description: SEED_SCHEMA.description,
          schema: registry.toJSON(),
          layout,
          canvas:{ zoom:1, mode:'auto' },
          createdAt: now,
          updatedAt: now
        };
      }

      function normalize(input, { bumpUpdatedAt=true }={}){
        const now = Date.now();
        const id = input.id || U.Id.uid('schema');
        const name = (input.name || '').trim() || `schema_${id.slice(-4)}`;
        const title = (input.title || '').trim() || name;
        const description = (input.description || '').trim();
        const schema = clone(input.schema || { tables: [] });
        const layout = clone(input.layout || {});
        const canvas = normaliseCanvas(clone(input.canvas || {}));
        const createdAt = input.createdAt || now;
        const updatedAt = bumpUpdatedAt ? now : (input.updatedAt || now);
        return { id, name, title, description, schema, layout, canvas, createdAt, updatedAt };
      }

      async function ready(){
        if(adapter && adapter.ensureSchema){
          try { await adapter.ensureSchema(); }
          catch(error){ console.warn('[Mishkah][ERD] failed to ensure schema store', error); }
        }
        return true;
      }

      async function save(input, opts={}){
        const record = normalize(input, opts);
        if(adapter){
          try { await adapter.put(storeName, record); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB save failed', error); }
        }
        memory.set(record.id, clone(record));
        return clone(record);
      }

      async function get(id){
        if(!id) return null;
        if(adapter){
          try {
            const row = await adapter.get(storeName, id);
            if(row){
              memory.set(row.id, clone(row));
              return clone(row);
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB get failed', error);
          }
        }
        const existing = memory.get(id);
        return existing ? clone(existing) : null;
      }

      async function list(){
        if(adapter){
          try {
            const rows = await adapter.getAll(storeName);
            if(Array.isArray(rows)){
              rows.forEach(row => memory.set(row.id, clone(row)));
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB list failed', error);
          }
        }
        const out = Array.from(memory.values()).map(item => clone(item));
        out.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
        return out;
      }

      async function remove(id){
        if(!id) return false;
        if(adapter){
          try { await adapter.delete(storeName, id); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB delete failed', error); }
        }
        memory.delete(id);
        return true;
      }

      async function createBlank(meta={}){
        return save({
          id: meta.id,
          name: meta.name || '',
          title: meta.title || meta.name || 'مخطط جديد',
          description: meta.description || '',
          schema: new Schema.Registry().toJSON(),
          layout:{},
          canvas:{ zoom:1, mode:'auto' },
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
      }

      async function createSeed(){
        const seed = buildSeedRecord();
        return save(seed, { bumpUpdatedAt:false });
      }

      return { status, available:true, ready, save, get, list, remove, createBlank, createSeed };
    })();

    await SchemaLibrary.ready();

    let libraryItems = await SchemaLibrary.list();
    if(!libraryItems.length){
      const seedRecord = await SchemaLibrary.createSeed();
      libraryItems = [seedRecord];
    }

    const activeRecord = libraryItems[0];
    const activeRegistry = Schema.Registry.fromJSON(activeRecord.schema || { tables: [] });

    function computeLayout(registry, layout){
      const map = Object.assign({}, layout || {});
      const tables = registry.list();
      const total = Math.max(1, tables.length);
      tables.forEach((table, index)=>{
        const fallback = computeGridPosition(index, total);
        if(map[table.name]){
          map[table.name] = normalisePoint(map[table.name], fallback);
        } else if(table.layout){
          map[table.name] = normalisePoint(table.layout, fallback);
        } else {
          map[table.name] = fallback;
        }
      });
      return map;
    }

    const initialLayout = computeLayout(activeRegistry, activeRecord.layout);
    const firstTable = activeRegistry.list()[0]?.name || null;
    const initialLayoutPoint = firstTable ? (initialLayout[firstTable] || { x:120, y:120 }) : { x:120, y:120 };

    const erdState = {
      head:{ title: activeRecord.title || 'مخطط قاعدة بيانات مشكاة' },
      env:{ theme:'dark', lang:'ar', dir:'rtl', graph:{ driver:'x6' } },
      data:{
        schemaId: activeRecord.id,
        schemaMeta:{
          name: activeRecord.name,
          title: activeRecord.title,
          description: activeRecord.description || ''
        },
        schemaCreatedAt: activeRecord.createdAt,
        schemaUpdatedAt: activeRecord.updatedAt,
        schema: activeRegistry.toJSON(),
        layout: initialLayout,
        selection:{ table:firstTable, field:null },
        canvas: normaliseCanvas(activeRecord.canvas),
        sqlPreview:'',
        error:null,
        library:{ items: libraryItems, status: SchemaLibrary.status }
      },
      ui:{
        modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false },
        template:{ open:true },
        form:{
          table:{ name:'', nameInput:'', label:'', comment:'', includeId:true },
          field:{
            table:firstTable || '',
            name:'',
            nameInput:'',
            nameManual:false,
            columnName:'',
            type:'string',
            nullable:true,
            primaryKey:false,
            unique:false,
            defaultValue:'',
            references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
          },
          relation:{
            sourceTable:firstTable || '',
            sourceField:'',
            targetTable:'',
            targetField:'',
            onDelete:'CASCADE',
            onUpdate:'CASCADE'
          },
          import:{ name: activeRecord.name || '', title: activeRecord.title || '', targetId: activeRecord.id || '', text:'' },
          export:{ text:'' },
          sql:{ text:'' },
          layout:{ x: initialLayoutPoint.x, y: initialLayoutPoint.y },
          schemaMeta:{
            name: activeRecord.name || '',
            title: activeRecord.title || '',
            description: activeRecord.description || ''
          }
        }
      }
    };

    function getRegistry(db){
      try {
        return Schema.Registry.fromJSON(db.data.schema);
      } catch(error){
        console.warn('[Mishkah][ERD] schema parse failed', error);
        return new Schema.Registry();
      }
    }

    function ensureLayout(db, tableName, options = {}){
      const registry = options.registry || getRegistry(db);
      const layout = computeLayout(registry, db.data.layout);
      if(tableName && !layout[tableName]){
        const tables = registry.list();
        const index = Math.max(tables.findIndex(tbl => tbl.name === tableName), tables.length);
        const fallback = computeGridPosition(index, Math.max(1, tables.length + 1));
        layout[tableName] = fallback;
      }
      return layout;
    }

    function withTableSelection(state, tableName){
      if(!tableName) return state;
      const registry = getRegistry(state);
      const layout = ensureLayout(state, tableName, { registry });
      const tablePos = layout[tableName] || { x: 120, y: 120 };
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field:null }, layout },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            field:{ ...(state.ui?.form?.field || {}), table: tableName },
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName },
            layout:{ x: tablePos.x, y: tablePos.y }
          }
        }
      };
    }

    function withFieldSelection(state, tableName, fieldName){
      if(!tableName || !fieldName) return state;
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field: fieldName } },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName, sourceField: fieldName }
          }
        }
      };
    }

    function mergeLibraryItems(list, record){
      const items = Array.isArray(list) ? list.slice() : [];
      const entry = clone(record);
      const idx = items.findIndex(item => item.id === record.id);
      if(idx >= 0) items[idx] = entry; else items.push(entry);
      items.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
      return items;
    }

    const schedulePersist = (function(){
      if(!SchemaLibrary.available) return ()=>{};
      const debounced = U.Control.debounce(async (record)=>{
        try{
          await SchemaLibrary.save(record, { bumpUpdatedAt:false });
        } catch(error){
          console.warn('[Mishkah][ERD] persist failed', error);
        }
      }, 600);
      return record => debounced(clone(record));
    })();

    function recordFromState(state){
      const meta = state.data.schemaMeta || {};
      return {
        id: state.data.schemaId,
        name: meta.name || '',
        title: meta.title || '',
        description: meta.description || '',
        schema: state.data.schema,
        layout: state.data.layout,
        canvas: state.data.canvas,
        createdAt: state.data.schemaCreatedAt,
        updatedAt: state.data.schemaUpdatedAt
      };
    }

    function SchemaLibraryPanel(db){
      const library = db.data.library || {};
      const items = library.items || [];
      const activeId = db.data.schemaId;
      const listContent = items.length
        ? D.Lists.Ul({ attrs:{ class: tw`flex flex-col gap-2 list-none m-0 p-0` } },
            items.map(item=> D.Lists.Li({ attrs:{ class: tw`rounded-xl border border-[var(--border)]/60 bg-[var(--surface-1)]/70 px-3 py-2 transition ${item.id === activeId ? 'ring-2 ring-[var(--primary)]/60' : 'hover:border-[var(--primary)]/50'}`, gkey:'erd:library:select', 'data-schema-id': item.id } }, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2` }}, [
                D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-0.5` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [item.title || item.name]),
                  D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [item.name])
                ]),
                D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-[10px] text-[var(--muted)]` }}, [U.Time.fmt(item.updatedAt || item.createdAt || Date.now())]),
                  UI.Button({ attrs:{ gkey:'erd:library:delete', 'data-schema-id': item.id, title:'حذف المخطط', class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, ['🗑️'])
                ])
              ])
            ])))
        : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['لم يتم حفظ أي مخططات بعد.']);
      return D.Containers.Aside({ attrs:{ class: tw`hidden lg:flex w-72 flex-col border-l border-[var(--border)] bg-[var(--surface-2)]/70 backdrop-blur` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between px-4 py-3 border-b border-[var(--border)]` }}, [
          D.Text.Span({ attrs:{ class: tw`text-base font-semibold` }}, ['مكتبة المخططات']),
          D.Text.Span({ attrs:{ class: tw`text-[10px] uppercase tracking-wide text-[var(--muted)]` }}, [library.status === 'indexeddb' ? 'IndexedDB' : 'ذاكرة مؤقتة'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`px-4 py-3 flex flex-col gap-2` }}, [
          UI.Button({ attrs:{ gkey:'erd:library:new' }, variant:'solid', size:'sm' }, ['➕ مخطط جديد']),
          UI.Button({ attrs:{ gkey:'erd:import:open' }, variant:'ghost', size:'sm' }, ['⬆️ استيراد JSON'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`flex-1 overflow-y-auto px-3 pb-4` }}, [listContent])
      ]);
    }

    function TemplateOverlay(db, tables){
      const templateState = db.ui?.template || {};
      if(templateState.open === false) return null;
      const registryTables = Array.isArray(tables) ? tables : getRegistry(db).list();
      const previewTables = registryTables.slice(0, 6);
      const cards = previewTables.length
        ? previewTables.map(table => {
            const fieldCount = (table.fields || []).length;
            const relationCount = (table.fields || []).filter(field => field.references).length;
            return D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)]/70 bg-[var(--surface-2)]/60 px-4 py-3 flex flex-col gap-2 shadow-sm` }}, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2` }}, [
                D.Containers.Div({ attrs:{ class: tw`flex flex-col` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [formatIdentifier(table.name)]),
                  table.label ? D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [table.label]) : null
                ].filter(Boolean)),
                UI.Button({ attrs:{ gkey:'erd:field:add:table', 'data-table': table.name, title:'إضافة عمود جديد لهذا الجدول' }, variant:'ghost', size:'sm' }, ['➕ عمود'])
              ]),
              D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [`Fields: ${fieldCount} · Relations: ${relationCount}`])
            ].filter(Boolean));
          })
        : [
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, ['ابدأ بإضافة جدول لإنشاء قالب المخطط.'])
          ];
      return D.Containers.Div({ attrs:{ class: tw`absolute bottom-4 left-4 z-20 w-80 max-w-full pointer-events-auto` }}, [
        D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)] bg-[var(--surface-1)]/95 shadow-xl backdrop-blur flex flex-col` }}, [
          D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between px-4 py-3 border-b border-[var(--border)]/80` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-semibold flex items-center gap-2` }}, ['🧩 ملخص القالب الحالي']),
            UI.Button({ attrs:{ gkey:'erd:template:toggle', title:'إخفاء الملخص', class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, ['إخفاء'])
          ]),
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2 px-4 py-3 max-h-60 overflow-y-auto` }}, cards),
          D.Containers.Div({ attrs:{ class: tw`px-4 py-2 border-t border-[var(--border)]/60` }}, [
            D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)] leading-relaxed` }}, ['هذا الملخص يوضح الجداول النشطة وعدد الحقول والعلاقات، مما يساعدك على فهم شكل المخطط بسرعة.'])
          ])
        ])
      ]);
    }

    function SchemaCanvas(db){
      const registry = getRegistry(db);
      const tables = registry.list();
      scheduleDiagramRender(db);
      const hasTables = tables.length > 0;
      const emptyState = !hasTables
        ? D.Containers.Div({ attrs:{ class: tw`absolute inset-0 flex items-center justify-center pointer-events-none` }}, [
            D.Containers.Div({ attrs:{ class: tw`rounded-3xl border border-dashed border-[var(--border)] bg-[var(--surface-2)]/70 px-6 py-5 text-center text-sm text-[var(--muted)] max-w-md` }}, ['أضف جدولًا جديدًا لبدء بناء المخطط.'])
          ])
        : null;
      const overlay = TemplateOverlay(db, tables);
      return D.Containers.Div({ attrs:{ class: tw`relative flex-1 bg-[var(--surface-1)]` }}, [
        D.Containers.Div({ attrs:{ id:'erd-diagram', class: tw`absolute inset-0` }}, []),
        overlay,
        emptyState
      ].filter(Boolean));
    }

    function Toolbar(db){
      const zoom = db.data.canvas?.zoom || 1;
      const metaTitle = db.data.schemaMeta?.title || 'مخطط بدون اسم';
      const schemaIdentifier = db.data.schemaMeta?.name ? formatIdentifier(db.data.schemaMeta.name) : '';
      const lang = db.env?.lang || db.i18n?.lang || 'ar';
      const theme = db.env?.theme || 'dark';
      const templateOpen = db.ui?.template?.open !== false;
      const metaGroup = UI.ToolbarGroup({ attrs:{ class: tw`items-start gap-3` }, label:'المخطط' }, [
        D.Containers.Div({ attrs:{ class: tw`flex flex-col` }}, [
          D.Text.Span({ attrs:{ class: tw`text-xl font-bold` }}, [metaTitle]),
          schemaIdentifier ? D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--accent-foreground)]/80` }}, [schemaIdentifier]) : null
        ].filter(Boolean)),
        UI.Button({ attrs:{ gkey:'erd:schema:meta:open', class: tw`!px-3` }, variant:'ghost', size:'sm' }, ['✏️ خصائص المخطط'])
      ]);
      const structureGroup = UI.ToolbarGroup({ label:'العناصر' }, [
        UI.Button({ attrs:{ gkey:'erd:table:add' }, variant:'soft', size:'sm' }, ['➕ جدول']),
        UI.Button({ attrs:{ gkey:'erd:field:add' }, variant:'ghost', size:'sm' }, ['➕ حقل']),
        UI.Button({ attrs:{ gkey:'erd:relation:add' }, variant:'ghost', size:'sm' }, ['🔗 علاقة'])
      ]);
      const templateGroup = UI.ToolbarGroup({ label:'القوالب' }, [
        UI.Button({ attrs:{ gkey:'erd:template:toggle' }, variant: templateOpen ? 'soft' : 'ghost', size:'sm' }, [templateOpen ? '🧩 إخفاء القالب' : '🧩 عرض القالب'])
      ]);

      const uiGroup = UI.ToolbarGroup({ label:'الواجهة' }, [
        UI.LanguageSwitch({ lang }),
        UI.ThemeToggleIcon({ theme })
      ]);
      const historyGroup = UI.ToolbarGroup({ label:'التاريخ' }, [
        UI.Button({ attrs:{ gkey:'erd:undo', title:'تراجع' }, variant:'ghost', size:'sm' }, ['↺']),
        UI.Button({ attrs:{ gkey:'erd:redo', title:'إعادة' }, variant:'ghost', size:'sm' }, ['↻']),
        UI.Button({ attrs:{ gkey:'erd:fit', title:'ملاءمة المخطط للشاشة' }, variant:'ghost', size:'sm' }, ['🗺️'])
      ]);
      const exportGroup = UI.ToolbarGroup({ label:'التصدير' }, [
        UI.Button({ attrs:{ gkey:'erd:export:svg', title:'تصدير SVG' }, variant:'ghost', size:'sm' }, ['🖼️ SVG']),
        UI.Button({ attrs:{ gkey:'erd:export:png', title:'تصدير PNG' }, variant:'ghost', size:'sm' }, ['🖼️ PNG']),
        UI.Button({ attrs:{ gkey:'erd:export:json' }, variant:'ghost', size:'sm' }, ['⬇️ تصدير JSON']),
        UI.Button({ attrs:{ gkey:'erd:export:sql' }, variant:'ghost', size:'sm' }, ['🧾 SQL'])
      ]);
      const zoomGroup = UI.ToolbarGroup({ label:'الحجم' }, [
        UI.Button({ attrs:{ gkey:'erd:zoom:out', title:'تصغير' }, variant:'ghost', size:'sm' }, ['➖']),
        D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, [`${Math.round(zoom * 100)}%`]),
        UI.Button({ attrs:{ gkey:'erd:zoom:reset', title:'إعادة الحجم' }, variant:'ghost', size:'sm' }, ['⟳']),
        UI.Button({ attrs:{ gkey:'erd:zoom:in', title:'تكبير' }, variant:'ghost', size:'sm' }, ['➕'])
      ]);

      return UI.Toolbar({
        left:[metaGroup, structureGroup, templateGroup],
        right:[uiGroup, historyGroup, exportGroup, zoomGroup]
      });
    }

    function InspectorPanel(db){
      const selection = db.data.selection || {};
      const registry = getRegistry(db);
      const table = selection.table ? registry.get(selection.table) : null;
      const layout = db.data.layout || {};
      const formLayout = db.ui?.form?.layout || { x:0, y:0 };
      const relationships = table ? (table.fields || []).filter(field=> field.references) : [];
      return D.Containers.Aside({ attrs:{ class: tw`hidden xl:flex w-80 flex-col border-r border-[var(--border)] bg-[var(--surface-2)]/90 backdrop-blur p-4 gap-4` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
          D.Text.H3({ attrs:{ class: tw`text-lg font-semibold` }}, ['خصائص المخطط']),
          UI.Button({ attrs:{ gkey:'erd:schema:meta:open', class: tw`justify-center` }, variant:'secondary', size:'sm' }, ['تحرير الاسم والوصف'])
        ]),
        D.Text.H3({ attrs:{ class: tw`text-lg font-semibold` }}, ['التفاصيل']),
        table ? D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
          D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [`${table.sqlName || Schema.utils.toSnakeCase(table.name)}`]),
          table.label ? D.Text.Span({ attrs:{ class: tw`text-sm` }}, [`المسمى الإضافي: ${table.label}`]) : null,
          D.Text.Span({ attrs:{ class: tw`text-sm` }}, [`عدد الحقول: ${table.fields.length}`]),
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['إحداثيات اللوحة']),
            UI.Input({ attrs:{ gkey:'erd:layout:input', 'data-axis':'x', value:String(formLayout.x), type:'number', class: tw`w-full`, placeholder:'المحور X' } }),
            UI.Input({ attrs:{ gkey:'erd:layout:input', 'data-axis':'y', value:String(formLayout.y), type:'number', class: tw`w-full`, placeholder:'المحور Y' } }),
            UI.Button({ attrs:{ gkey:'erd:layout:apply', variant:'solid', size:'sm' }}, ['تحديث الموقع'])
          ]),
          relationships.length ? D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-1` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['العلاقات الخارجة']),
            ...relationships.map(field=> D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [`${field.name} → ${field.references.table}.${field.references.column}`]))
          ]) : D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, ['لا توجد علاقات محددة.'])
        ].filter(Boolean)) : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['اختر جدولًا من المخطط لاستعراض تفاصيله.'])
      ]);
    }

    function ModalImport(db){
      const open = db.ui?.modals?.import;
      const form = db.ui?.form?.import || { name:'', title:'', targetId:'', text:'' };
      const library = db.data.library || {};
      const items = library.items || [];
      return UI.Modal({
        open,
        size:'lg',
        title:'استيراد مخطط JSON',
        description:'ألصق بيانات المخطط أو استبدل مخططًا موجودًا.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'name', value: form.name || '', placeholder:'المعرف الفريد للمخطط (name)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'title', value: form.title || '', placeholder:'العنوان المعروض' } }),
            UI.Select({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'targetId', value: form.targetId || '' }, options:[
              { value:'', label:'إنشاء مخطط جديد' },
              ...items.map(item=> ({ value:item.id, label:`استبدال: ${item.title || item.name}` }))
            ] }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'text', value: form.text || '', rows:12, class: tw`w-full font-mono text-xs`, placeholder:'{"schema":{...}}' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:import:apply', variant:'solid', size:'sm' }}, ['استيراد وتخزين']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إغلاق'])
        ]
      });
    }

    function ModalExportJson(db){
      const open = db.ui?.modals?.exportJson;
      const text = db.ui?.form?.export?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'مخطط JSON',
        description:'انسخ المحتوى للاستخدام في أماكن أخرى.',
        closeGkey:'erd:modal:close',
        content:[
          UI.Textarea({ attrs:{ readonly:true, value: text, rows:14, class: tw`w-full font-mono text-xs` } })
        ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['تم']) ]
      });
    }

    function ModalExportSql(db){
      const open = db.ui?.modals?.exportSql;
      const text = db.ui?.form?.sql?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'نص SQL',
        description:'هذا النص يمثل أوامر إنشاء الجداول PostgreSQL.',
        closeGkey:'erd:modal:close',
        content:[ UI.Textarea({ attrs:{ readonly:true, value: text, rows:16, class: tw`w-full font-mono text-xs` } }) ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['تم']) ]
      });
    }

    function ModalSchemaMeta(db){
      const open = db.ui?.modals?.schemaMeta;
      const form = db.ui?.form?.schemaMeta || { name:'', title:'', description:'' };
      return UI.Modal({
        open,
        size:'md',
        title:'خصائص المخطط',
        description:'قم بتحديث اسم التعريف والعنوان والوصف.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'name', value: form.name || '', placeholder:'Name (snake_case)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'title', value: form.title || '', placeholder:'Title' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'description', value: form.description || '', rows:4, placeholder:'وصف مختصر للمخطط' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:schema:meta:save', variant:'solid', size:'sm' }}, ['حفظ التعديلات']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalAddTable(db){
      const open = db.ui?.modals?.table;
      const form = db.ui?.form?.table || { name:'', nameInput:'', label:'', comment:'', includeId:true };
      const registry = getRegistry(db);
      const sanitizedName = form.name || '';
      const suggestedName = sanitizedName || (form.label ? sanitizeSqlIdentifier(form.label) : '');
      const helperText = suggestedName
        ? `سيتم حفظ الجدول في قاعدة البيانات بالاسم: ${suggestedName} مع ضمان عدم تكرار المعرف داخل المخطط.`
        : 'اكتب اسمًا إنجليزيًا، وسيتم تحويل المسافات والمحارف الخاصة تلقائيًا إلى صيغة SQL سليمة.';
      return UI.Modal({
        open,
        size:'md',
        title:'إنشاء جدول جديد',
        description:'الاسم الإنجليزي مطلوب وسيُستخدم كاسم الجدول في قاعدة البيانات. يمكنك إضافة مسمى بلغة أخرى اختياريًا.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'name', value: form.nameInput || '', placeholder:'English name (مثال: Sales Orders)' } }),
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [helperText]),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'label', value: form.label || '', placeholder:'اسم الجدول بلغة ثانية (اختياري)' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'comment', value: form.comment || '', rows:3, placeholder:'ملاحظات' } }),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-2` }}, [
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'table', 'data-field':'includeId', type:'checkbox', checked: form.includeId !== false } }),
              UI.Label({ text:'إنشاء حقل id افتراضي؟' })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:table:create', variant:'solid', size:'sm' }}, ['إنشاء']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalAddField(db){
      const open = db.ui?.modals?.field;
      const form = db.ui?.form?.field || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} — ${table.label}`
          : formatIdentifier(table.name)
      }));
      const selectedTable = form.table && registry.get(form.table)
        ? form.table
        : (tableOptions[0]?.value || '');
      const currentTable = selectedTable ? registry.get(selectedTable) : null;
      const previewFieldName = form.name || (form.label ? computeFieldIdentifier(currentTable, form.label) : '');
      const englishInputValue = form.nameInput != null ? form.nameInput : (form.name || '');
      const selectedReferenceTable = form.references?.table && registry.get(form.references.table)
        ? form.references.table
        : '';
      const referenceTableEntity = selectedReferenceTable ? registry.get(selectedReferenceTable) : null;
      const referenceFieldOptions = referenceTableEntity
        ? referenceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const selectedReferenceField = referenceFieldOptions.some(opt => opt.value === form.references?.column)
        ? form.references?.column
        : '';
      return UI.Modal({
        open,
        size:'lg',
        title:'إضافة حقل',
        description:'حدد تفاصيل الحقل الجديد مع اسم إنجليزي متوافق مع SQL ومسمى عربي اختياري.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{
                gkey:'erd:form:update',
                'data-form':'field',
                'data-field':'table',
                value: selectedTable || ''
              },
              options:[{ value:'', label:'اختر الجدول' }, ...tableOptions]
            }),
            UI.Input({
              attrs:{
                gkey:'erd:form:update',
                'data-form':'field',
                'data-field':'name',
                value: englishInputValue,
                placeholder:'English column name (snake_case)'
              }
            }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'label', value: form.label || '', placeholder:'المسمى العربي للحقل' } }),
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--accent-foreground)]/80 md:col-span-2` }}, [previewFieldName ? `المعرف النهائي: ${previewFieldName}` : 'سيتم توليد المعرف تلقائيًا عند الكتابة.']),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'type', value: form.type || 'string' },
              options: FIELD_TYPE_OPTIONS
            }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'defaultValue', value: form.defaultValue || '', placeholder:'قيمة افتراضية' } }),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Nullable؟' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'nullable', type:'checkbox', checked: form.nullable !== false } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Primary Key؟' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'primaryKey', type:'checkbox', checked: !!form.primaryKey } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Unique؟' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'unique', type:'checkbox', checked: !!form.unique } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`col-span-full flex flex-col gap-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['علاقة مرجعية اختيارية']),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'table',
                  value: selectedReferenceTable
                },
                options:[{ value:'', label:'بدون علاقة' }, ...tableOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'column',
                  value: selectedReferenceField
                },
                options:[{ value:'', label:'اختر الحقل' }, ...referenceFieldOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onDelete',
                  value: form.references?.onDelete || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onUpdate',
                  value: form.references?.onUpdate || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:field:create', variant:'solid', size:'sm' }}, ['إضافة']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalRelation(db){
      const open = db.ui?.modals?.relation;
      const form = db.ui?.form?.relation || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} — ${table.label}`
          : formatIdentifier(table.name)
      }));
      const sourceTableValue = form.sourceTable && registry.get(form.sourceTable)
        ? form.sourceTable
        : '';
      const sourceTableEntity = sourceTableValue ? registry.get(sourceTableValue) : null;
      const sourceFieldOptions = sourceTableEntity
        ? sourceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const sourceFieldValue = sourceFieldOptions.some(opt => opt.value === form.sourceField)
        ? form.sourceField
        : '';
      const targetTableValue = form.targetTable && registry.get(form.targetTable)
        ? form.targetTable
        : '';
      const targetTableEntity = targetTableValue ? registry.get(targetTableValue) : null;
      const targetFieldOptions = targetTableEntity
        ? targetTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const targetFieldValue = targetFieldOptions.some(opt => opt.value === form.targetField)
        ? form.targetField
        : '';
      return UI.Modal({
        open,
        size:'md',
        title:'إنشاء علاقة بين الجداول',
        description:'حدد الجدول المصدر والهدف وأسلوب التحديث.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceTable', value: sourceTableValue },
              options:[{ value:'', label:'اختر الجدول المصدر' }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceField', value: sourceFieldValue },
              options:[{ value:'', label:'اختر الحقل المصدر' }, ...sourceFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetTable', value: targetTableValue },
              options:[{ value:'', label:'اختر الجدول الهدف' }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetField', value: targetFieldValue },
              options:[{ value:'', label:'اختر الحقل الهدف' }, ...targetFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onDelete', value: form.onDelete || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onUpdate', value: form.onUpdate || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:relation:create', variant:'solid', size:'sm' }}, ['حفظ العلاقة']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function Modals(db){
      return [
        ModalImport(db),
        ModalExportJson(db),
        ModalExportSql(db),
        ModalSchemaMeta(db),
        ModalAddTable(db),
        ModalAddField(db),
        ModalRelation(db)
      ];
    }

    function AppView(db){
      return D.Containers.Div({ attrs:{ class: tw`flex h-screen w-full bg-[var(--surface-0)] text-[var(--foreground)]` }}, [
        SchemaLibraryPanel(db),
        D.Containers.Div({ attrs:{ class: tw`flex flex-1 flex-col` }}, [
          Toolbar(db),
          SchemaCanvas(db)
        ]),
        InspectorPanel(db),
        ...Modals(db)
      ]);
    }

    const erdOrders = {
      'erd.fit':{
        on:['click'],
        gkeys:['erd:fit'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.fitToScreen === 'function'){
            try { driver.fitToScreen(16); }
            catch(error){ console.warn('[Mishkah][ERD] fit failed', error); }
          } else {
            UI.pushToast(ctx, { title:'لم يتم تفعيل أداة الرسم بعد', icon:'⚠️' });
          }
        }
      },
      'erd.undo':{
        on:['click'],
        gkeys:['erd:undo'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.undo === 'function'){
            try { driver.undo(); }
            catch(error){ console.warn('[Mishkah][ERD] undo failed', error); }
          }
        }
      },
      'erd.redo':{
        on:['click'],
        gkeys:['erd:redo'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.redo === 'function'){
            try { driver.redo(); }
            catch(error){ console.warn('[Mishkah][ERD] redo failed', error); }
          }
        }
      },
      'erd.zoom.in':{
        on:['click'],
        gkeys:['erd:zoom:in'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.min(MAX_CANVAS_ZOOM, (s.data.canvas?.zoom || 1) + 0.1);
            const canvas = { ...(s.data.canvas || {}), zoom, mode:'manual' };
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.out':{
        on:['click'],
        gkeys:['erd:zoom:out'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.max(MIN_CANVAS_ZOOM, (s.data.canvas?.zoom || 1) - 0.1);
            const canvas = { ...(s.data.canvas || {}), zoom, mode:'manual' };
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.reset':{
        on:['click'],
        gkeys:['erd:zoom:reset'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const canvas = { ...(s.data.canvas || {}), zoom:1, mode:'auto' };
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.export.svg':{
        on:['click'],
        gkeys:['erd:export:svg'],
        handler: async (e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(!driver || typeof driver.exportSVG !== 'function'){
            UI.pushToast(ctx, { title:'سائق الرسم لا يدعم تصدير SVG', icon:'⚠️' });
            return;
          }
          try{
            const svg = await driver.exportSVG();
            const blob = svg instanceof Blob ? svg : new Blob([svg], { type:'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const name = ctx.getState().data?.schemaMeta?.name || 'schema';
            link.href = url;
            link.download = `${name}.svg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            UI.pushToast(ctx, { title:'تم تصدير الرسم بصيغة SVG', icon:'✅' });
          } catch(error){
            console.warn('[Mishkah][ERD] export SVG failed', error);
            UI.pushToast(ctx, { title:'تعذر تصدير SVG', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.export.png':{
        on:['click'],
        gkeys:['erd:export:png'],
        handler: async (e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(!driver || typeof driver.exportPNG !== 'function'){
            UI.pushToast(ctx, { title:'سائق الرسم لا يدعم تصدير PNG', icon:'⚠️' });
            return;
          }
          try{
            const blob = await driver.exportPNG({ background: currentPalette().background || '#ffffff' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const name = ctx.getState().data?.schemaMeta?.name || 'schema';
            link.href = url;
            link.download = `${name}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            UI.pushToast(ctx, { title:'تم تصدير الرسم بصيغة PNG', icon:'✅' });
          } catch(error){
            console.warn('[Mishkah][ERD] export PNG failed', error);
            UI.pushToast(ctx, { title:'تعذر تصدير PNG', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.table.select':{
        on:['click'],
        gkeys:['erd:table:select'],
        handler:(e,ctx)=>{
          const card = e.target.closest('[data-table-name]');
          if(!card) return;
          const tableName = card.getAttribute('data-table-name');
          ctx.setState(s => withTableSelection(s, tableName));
          ctx.rebuild();
        }
      },
      'erd.field.select':{
        on:['click'],
        gkeys:['erd:field:select'],
        handler:(e,ctx)=>{
          const row = e.target.closest('[data-field-name]');
          if(!row) return;
          const tableName = row.getAttribute('data-table-name');
          const fieldName = row.getAttribute('data-field-name');
          ctx.setState(s => withFieldSelection(s, tableName, fieldName));
          ctx.rebuild();
        }
      },
      'erd.import.open':{
        on:['click'],
        gkeys:['erd:import:open'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), import:true },
              form:{ ...(s.ui?.form || {}), import:{ name: payload.name, title: payload.title, targetId: s.data.schemaId || '', text: JSON.stringify(payload, null, 2) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.export.json':{
        on:['click'],
        gkeys:['erd:export:json'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas,
            createdAt: state.data.schemaCreatedAt,
            updatedAt: state.data.schemaUpdatedAt
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), exportJson:true },
              form:{ ...(s.ui?.form || {}), export:{ text: JSON.stringify(payload, null, 2) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.export.sql':{
        on:['click'],
        gkeys:['erd:export:sql'],
        handler:(e,ctx)=>{
          const registry = getRegistry(ctx.getState());
          const sql = registry.generateSQL({ schemaName:'public' });
          ctx.setState(s=>({
            ...s,
            data:{ ...s.data, sqlPreview: sql },
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), exportSql:true },
              form:{ ...(s.ui?.form || {}), sql:{ text: sql } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.modal.close':{
        on:['click'],
        gkeys:['erd:modal:close','ui:modal:close'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false } }
          }));
          ctx.rebuild();
        }
      },
      'erd.template.toggle':{
        on:['click'],
        gkeys:['erd:template:toggle'],
        handler:(e,ctx)=>{
          ctx.setState(s=>{
            const currentOpen = s.ui?.template?.open !== false;
            const nextOpen = !currentOpen;
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                template:{ ...(s.ui?.template || {}), open: nextOpen }
              }
            };
          });
          ctx.rebuild();
        }
      },
      'erd.form.update':{
        on:['input','change'],
        gkeys:['erd:form:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          const parent = input.getAttribute('data-parent');
          if(!formKey) return;
          const value = input.value;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            if(formKey === 'fieldRef' || formKey === 'fieldRefColumn' || parent === 'field'){
              const current = currentForms.field || {};
              let nextRef = { ...(current.references || {}) };
              if(fieldKey){
                nextRef[fieldKey] = value;
              }
              if(fieldKey === 'table'){
                nextRef = { ...nextRef, table: value, column: '' };
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...current, references: nextRef } } } };
            }
            if(formKey === 'table' && fieldKey === 'name'){
              const targetForm = currentForms.table || {};
              const normalized = sanitizeSqlIdentifier(value);
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    table:{ ...targetForm, name: normalized, nameInput: value }
                  }
                }
              };
            }
            if(formKey === 'table' && fieldKey === 'label'){
              const targetForm = currentForms.table || {};
              const hasNameInput = !!(targetForm.nameInput && targetForm.nameInput.trim());
              const suggestion = sanitizeSqlIdentifier(value);
              const nextTable = { ...targetForm, label: value };
              if(!hasNameInput){
                nextTable.name = suggestion;
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, table: nextTable } } };
            }
            if(formKey === 'field' && fieldKey === 'label'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = targetForm.table ? registry.get(targetForm.table) : null;
              const nextField = { ...targetForm, label:value };
              if(!targetForm.nameManual){
                const slug = computeFieldIdentifier(table, value);
                nextField.name = slug;
                nextField.nameInput = slug;
                nextField.columnName = slug;
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field: nextField } } };
            }
            if(formKey === 'field' && fieldKey === 'name'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = targetForm.table ? registry.get(targetForm.table) : null;
              const normalized = sanitizeSqlIdentifier(value);
              let nextName = normalized;
              if(!nextName && targetForm.label){
                nextName = computeFieldIdentifier(table, targetForm.label);
              }
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    field:{
                      ...targetForm,
                      name: nextName,
                      nameInput: value,
                      columnName: nextName || '',
                      nameManual: !!normalized
                    }
                  }
                }
              };
            }
            if(formKey === 'field' && fieldKey === 'table'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = value ? registry.get(value) : null;
              let slug = targetForm.name || '';
              let nameInput = targetForm.nameInput || '';
              if(!targetForm.nameManual && targetForm.label){
                slug = computeFieldIdentifier(table, targetForm.label);
                nameInput = slug;
              }
              const currentRefs = targetForm.references || {};
              const references = currentRefs.table === value
                ? currentRefs
                : { table:'', column:'', onDelete: currentRefs.onDelete || 'CASCADE', onUpdate: currentRefs.onUpdate || 'CASCADE' };
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    field:{
                      ...targetForm,
                      table:value,
                      name: slug,
                      nameInput,
                      columnName: slug,
                      references
                    }
                  }
                }
              };
            }
            if(formKey === 'relation' && fieldKey === 'sourceTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, sourceTable: value, sourceField:'' } } }
              };
            }
            if(formKey === 'relation' && fieldKey === 'targetTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, targetTable: value, targetField:'' } } }
              };
            }
            if(fieldKey){
              const targetForm = currentForms[formKey] || {};
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: value } } } };
            }
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: value } } };
          });
          ctx.rebuild();
        }
      },
      'erd.form.toggle':{
        on:['change'],
        gkeys:['erd:form:toggle'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          if(!formKey || !fieldKey) return;
          const checked = input.checked;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            const targetForm = currentForms[formKey] || {};
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: checked } } } };
          });
          ctx.rebuild();
        }
      },
      'erd.table.add':{
        on:['click'],
        gkeys:['erd:table:add'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), table:true } }
          }));
          ctx.rebuild();
        }
      },
      'erd.table.create':{
        on:['click'],
        gkeys:['erd:table:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.table || {};
          const registry = getRegistry(state);
          const englishInput = (form.name || '').trim();
          if(!englishInput){
            UI.pushToast(ctx, { title:'يرجى إدخال الاسم الإنجليزي للجدول', icon:'⚠️' });
            return;
          }
          const name = computeTableIdentifier(registry, englishInput);
          const label = (form.label || '').trim();
          try{
            const currentTables = registry.list();
            const fallbackPosition = computeGridPosition(currentTables.length, currentTables.length + 1);
            const tableConfig = {
              name,
              label: label || '',
              comment: form.comment || '',
              layout: fallbackPosition,
              fields: []
            };
            if(form.includeId){
              tableConfig.fields.push({ name:'id', columnName:'id', type:'uuid', primaryKey:true, nullable:false });
            }
            registry.register(tableConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const layout = ensureLayout({ data:{ layout: s.data.layout, schema: s.data.schema } }, name, { registry });
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                head:{ ...(s.head || {}), title: record.title || (s.head?.title || 'مخطط قاعدة بيانات مشكاة') },
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  layout,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), table:false },
                  form:{
                    ...(s.ui?.form || {}),
                    table:{ name:'', nameInput:'', label:'', comment:'', includeId:true },
                    field:{ ...(s.ui?.form?.field || {}), table: name, label:'', name:'', nameInput:'', nameManual:false, columnName:'' },
                    layout:{ x: layout[name].x, y: layout[name].y }
                  }
                }
              };
              draft = withTableSelection(draft, name);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create table', error);
            UI.pushToast(ctx, { title:'فشل إنشاء الجدول', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.field.add':{
        on:['click'],
        gkeys:['erd:field:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const first = registry.list()[0]?.name || '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), field:true },
              form:{
                ...(s.ui?.form || {}),
                field:{
                  table: s.data.selection?.table || first,
                  label:'',
                  name:'',
                  nameInput:'',
                  nameManual:false,
                  columnName:'',
                  type:'string',
                  nullable:true,
                  primaryKey:false,
                  unique:false,
                  defaultValue:'',
                  references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
                }
              }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.field.add.table':{
        on:['click'],
        gkeys:['erd:field:add:table'],
        handler:(event, ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const target = (event?.target && typeof event.target.closest === 'function')
            ? event.target.closest('[data-m-gkey="erd:field:add:table"]')
            : null;
          const button = target || event.currentTarget;
          const requestedTable = button?.getAttribute ? button.getAttribute('data-table') : '';
          const fallbackTable = state.data.selection?.table || registry.list()[0]?.name || '';
          const tableName = requestedTable && registry.get(requestedTable) ? requestedTable : fallbackTable;
          ctx.setState(s=>{
            const nextState = {
              ...s,
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), field:true },
                form:{
                  ...(s.ui?.form || {}),
                  field:{
                    table: tableName,
                    label:'',
                    name:'',
                    nameInput:'',
                    nameManual:false,
                    columnName:'',
                    type:'string',
                    nullable:true,
                    primaryKey:false,
                    unique:false,
                    defaultValue:'',
                    references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
                  }
                }
              }
            };
            return tableName ? withTableSelection(nextState, tableName) : nextState;
          });
          ctx.rebuild();
        }
      },
      'erd.field.create':{
        on:['click'],
        gkeys:['erd:field:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.field || {};
          const tableName = (form.table || '').trim();
          const label = (form.label || '').trim();
          const englishSource = (form.name || '').trim();
          if(!tableName || (!label && !englishSource)){
            UI.pushToast(ctx, { title:'يرجى تحديد الجدول واسم الحقل باللغتين على الأقل', icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:'الجدول غير موجود', icon:'⚠️' });
            return;
          }
          try{
            let fieldName = sanitizeSqlIdentifier(englishSource);
            if(!fieldName && label){
              fieldName = computeFieldIdentifier(table, label);
            }
            if(!fieldName){
              UI.pushToast(ctx, { title:'الاسم الإنجليزي للحقل غير صالح', icon:'⚠️' });
              return;
            }
            if(typeof table.getField === 'function' && table.getField(fieldName)){
              UI.pushToast(ctx, { title:'اسم الحقل مستخدم مسبقًا داخل الجدول', icon:'⚠️' });
              return;
            }
            const fieldConfig = {
              name: fieldName,
              columnName: fieldName,
              type: form.type || 'string',
              nullable: form.nullable !== false,
              primaryKey: !!form.primaryKey,
              unique: !!form.unique,
              comment: label
            };
            if(form.defaultValue){
              const val = form.defaultValue;
              if(['integer','number','decimal','float'].includes(fieldConfig.type)){
                const num = Number(val);
                if(!Number.isNaN(num)) fieldConfig.defaultValue = num;
              } else if(fieldConfig.type === 'boolean'){
                fieldConfig.defaultValue = ['true','1','yes','on'].includes(String(val).toLowerCase());
              } else {
                fieldConfig.defaultValue = val;
              }
            }
            if(form.references && form.references.table && form.references.column){
              fieldConfig.references = {
                table: form.references.table,
                column: form.references.column,
                onDelete: form.references.onDelete || 'CASCADE',
                onUpdate: form.references.onUpdate || 'CASCADE'
              };
            }
            table.addField(fieldConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), field:false },
                  form:{
                    ...(s.ui?.form || {}),
                    field:{
                      ...form,
                      label:'',
                      name:'',
                      nameInput:'',
                      nameManual:false,
                      columnName:'',
                      defaultValue:'',
                      primaryKey:false,
                      unique:false
                    }
                  }
                }
              };
              draft = withFieldSelection(draft, tableName, fieldName);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to add field', error);
            UI.pushToast(ctx, { title:'فشل إضافة الحقل', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.relation.add':{
        on:['click'],
        gkeys:['erd:relation:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), relation:true },
              form:{ ...(s.ui?.form || {}), relation:{ sourceTable: selection.table || '', sourceField: selection.field || '', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.relation.create':{
        on:['click'],
        gkeys:['erd:relation:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.relation || {};
          if(!form.sourceTable || !form.sourceField || !form.targetTable || !form.targetField){
            UI.pushToast(ctx, { title:'الرجاء اختيار الحقول المصدر والهدف', icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(form.sourceTable);
          if(!table){
            UI.pushToast(ctx, { title:'الجدول المصدر غير موجود', icon:'⚠️' });
            return;
          }
          try{
            table.updateField(form.sourceField, {
              references:{
                table: form.targetTable,
                column: form.targetField,
                onDelete: form.onDelete || 'CASCADE',
                onUpdate: form.onUpdate || 'CASCADE'
              }
            });
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), relation:false } }
              };
              draft = withFieldSelection(draft, form.sourceTable, form.sourceField);
              next = draft;
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create relation', error);
            UI.pushToast(ctx, { title:'فشل إنشاء العلاقة', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.import.apply':{
        on:['click'],
        gkeys:['erd:import:apply'],
        handler:async (e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.import || {};
          const raw = form.text || '';
          try{
            const parsed = JSON.parse(raw);
            const schemaPayload = parsed.schema && parsed.schema.tables ? parsed.schema : parsed;
            const registry = Schema.Registry.fromJSON(schemaPayload);
            const normalizedSchema = registry.toJSON();
            const layout = computeLayout(registry, parsed.layout);
            const targetId = form.targetId || '';
            let existing = null;
            if(targetId){ existing = await SchemaLibrary.get(targetId); }
            const now = Date.now();
            const recordInput = {
              id: targetId || undefined,
              name: form.name || parsed.name || schemaPayload.name || `schema_${now}`,
              title: form.title || parsed.title || form.name || `مخطط ${now}`,
              description: parsed.description || '',
              schema: normalizedSchema,
              layout,
            canvas: normaliseCanvas(parsed.canvas || existing?.canvas || state.data.canvas),
              createdAt: existing?.createdAt,
              updatedAt: now
            };
            const saved = await SchemaLibrary.save(recordInput);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: saved.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: saved.id,
                schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' },
                schemaCreatedAt: saved.createdAt,
                schemaUpdatedAt: saved.updatedAt,
                schema: normalizedSchema,
                layout,
                selection:{ table:first, field:null },
            canvas: normaliseCanvas(saved.canvas || state.data.canvas),
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), import:false },
                form:{
                  ...(s.ui?.form || {}),
                  import:{ name:'', title:'', targetId:'', text:'' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'تم استيراد المخطط وتخزينه', icon:'✅' });
          } catch(error){
            console.warn('[Mishkah][ERD] import failed', error);
            UI.pushToast(ctx, { title:'تعذر استيراد JSON', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.layout.input':{
        on:['input','change'],
        gkeys:['erd:layout:input'],
        handler:(e,ctx)=>{
          const axis = e.target.getAttribute('data-axis');
          if(!axis) return;
          const value = Number(e.target.value);
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), form:{ ...(s.ui?.form || {}), layout:{ ...(s.ui?.form?.layout || {}), [axis]: Number.isFinite(value) ? value : 0 } } }
          }));
          ctx.rebuild();
        }
      },
      'erd.layout.apply':{
        on:['click'],
        gkeys:['erd:layout:apply'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          if(!selection.table){
            UI.pushToast(ctx, { title:'اختر جدولاً لتحديث موقعه', icon:'⚠️' });
            return;
          }
          const formLayout = state.ui?.form?.layout || { x:120, y:120 };
          let next;
          ctx.setState(s=>{
            const layout = Object.assign({}, s.data.layout || {});
            layout[selection.table] = { x: Number(formLayout.x) || 0, y: Number(formLayout.y) || 0 };
            const now = Date.now();
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              data:{
                ...s.data,
                layout,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.library.new':{
        on:['click'],
        gkeys:['erd:library:new'],
        handler:async (e,ctx)=>{
          try{
            const record = await SchemaLibrary.createBlank({ title:'مخطط جديد' });
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: normaliseCanvas(record.canvas),
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  table:{ name:'', nameInput:'', label:'', comment:'', includeId:true },
                  field:{ table:first || '', label:'', name:'', nameInput:'', nameManual:false, columnName:'', type:'string', nullable:true, primaryKey:false, unique:false, defaultValue:'', references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' } },
                  relation:{ sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'تم إنشاء مخطط جديد', icon:'✨' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create new schema', error);
            UI.pushToast(ctx, { title:'تعذر إنشاء المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.library.select':{
        on:['click'],
        gkeys:['erd:library:select'],
        handler:async (e,ctx)=>{
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId || schemaId === state.data.schemaId) return;
          try{
            const record = await SchemaLibrary.get(schemaId);
            if(!record){
              UI.pushToast(ctx, { title:'تعذر تحميل المخطط', icon:'🛑' });
              return;
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: normaliseCanvas(record.canvas),
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
          } catch(error){
            console.warn('[Mishkah][ERD] failed to select schema', error);
            UI.pushToast(ctx, { title:'فشل تحميل المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.library.delete':{
        on:['click'],
        gkeys:['erd:library:delete'],
        handler:async (e,ctx)=>{
          e.preventDefault();
          e.stopPropagation();
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId) return;
          const count = state.data.library?.items?.length || 0;
          if(count <= 1){
            UI.pushToast(ctx, { title:'لا يمكن حذف آخر مخطط', icon:'⚠️' });
            return;
          }
          try{
            await SchemaLibrary.remove(schemaId);
            let list = await SchemaLibrary.list();
            if(!list.length){
              const blank = await SchemaLibrary.createBlank({ title:'مخطط جديد' });
              list = [blank];
            }
            let record = null;
            if(schemaId === state.data.schemaId){
              record = list[0];
            } else {
              record = await SchemaLibrary.get(state.data.schemaId) || list[0];
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: normaliseCanvas(record.canvas),
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'تم حذف المخطط', icon:'🗑️' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to delete schema', error);
            UI.pushToast(ctx, { title:'تعذر حذف المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.schema.meta.open':{
        on:['click'],
        gkeys:['erd:schema:meta:open'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), schemaMeta:true },
              form:{ ...(s.ui?.form || {}), schemaMeta:{ ...(s.data.schemaMeta || {}) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.schema.meta.save':{
        on:['click'],
        gkeys:['erd:schema:meta:save'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const form = s.ui?.form?.schemaMeta || {};
            const now = Date.now();
            const meta = {
              name: (form.name || s.data.schemaMeta?.name || '').trim() || `schema_${s.data.schemaId?.slice(-4) || 'new'}`,
              title: (form.title || form.name || s.data.schemaMeta?.title || '').trim() || 'مخطط جديد',
              description: (form.description || '').trim()
            };
            const record = {
              id: s.data.schemaId,
              name: meta.name,
              title: meta.title,
              description: meta.description,
              schema: s.data.schema,
              layout: s.data.layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              head:{ ...(s.head || {}), title: meta.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaMeta: meta,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), schemaMeta:false },
                form:{ ...(s.ui?.form || {}), schemaMeta: meta }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      }
    };

    const app = M.app.createApp(erdState, {});
    const auto = U.twcss.auto(erdState, app, { pageScaffold:true });

    M.app.setBody(AppView);

    app.setOrders(Object.assign({}, UI.orders, auto.orders, erdOrders));
    app.mount('#app');
  })();
  </script>
</body>
</html>
