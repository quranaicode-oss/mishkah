<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>مخطط قاعدة بيانات مشكاة</title>
  <style>
    :root {
      color-scheme: light dark;
      --background: #f8fafc;
      --surface-0: #f8fafc;
      --surface-1: #ffffff;
      --surface-2: #f1f5f9;
      --card: #ffffff;
      --card-foreground: #0f172a;
      --foreground: #0f172a;
      --muted: #475569;
      --muted-foreground: #475569;
      --border: #cfd8ea;
      --input: #dbe3f8;
      --accent: #eaf2ff;
      --accent-foreground: #102341;
      --primary: #2563eb;
      --primary-foreground: #f8fafc;
      --secondary: #d8e1ff;
      --secondary-foreground: #102341;
      --destructive: #ef4444;
      --destructive-foreground: #ffffff;
      --ring: #2563eb;
      --shadow: 0 28px 60px -28px rgba(15, 23, 42, 0.35);
      --radius: 16px;
      --toolbar-height: 3.5rem;
    }
    :root.dark {
      color-scheme: dark;
      --background: #0b1220;
      --surface-0: #0b1220;
      --surface-1: #101a2c;
      --surface-2: #16243a;
      --card: #111d30;
      --card-foreground: #e2e8f0;
      --foreground: #f8fafc;
      --muted: #94a3b8;
      --muted-foreground: #94a3b8;
      --border: #1f2a3d;
      --input: #223044;
      --accent: #1e2a3f;
      --accent-foreground: #e2e8f0;
      --primary: #60a5fa;
      --primary-foreground: #0b1220;
      --secondary: #27364e;
      --secondary-foreground: #e2e8f0;
      --destructive: #f87171;
      --destructive-foreground: #0b1220;
      --ring: #60a5fa;
      --shadow: 0 30px 70px -36px rgba(8, 15, 30, 0.75);
      --radius: 16px;
    }
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      height: 100%;
      min-height: 100vh;
      margin: 0;
      background: var(--background, #0f1115);
      color: var(--foreground, #f8fafc);
      font-family: "Tajawal", "Cairo", system-ui, sans-serif;
      transition: background-color 160ms ease, color 160ms ease;
    }
    body {
      display: flex;
      min-height: 100vh;
      width: 100vw;
      overflow-x: hidden;
    }
    #app { flex: 1 1 auto; display: flex; }
    textarea[readonly] { user-select: all; }
    .hidden { display: none !important; }

    #erd-diagram {
      cursor: grab;
      overflow: auto;
      touch-action: pan-x pan-y;
      scrollbar-gutter: stable;
    }
    #erd-diagram:active,
    #erd-diagram[data-panning="true"] {
      cursor: grabbing;
    }
    #erd-diagram[data-driver='fake'] svg {
      display: block;
      min-width: 100%;
      min-height: 100%;
    }
    #erd-diagram .x6-graph-scroller {
      overflow: auto !important;
      cursor: inherit;
    }
    #erd-diagram .x6-graph-scroller-content {
      min-width: 100%;
      min-height: 100%;
    }
    .json-editor-shell {
      border-radius: calc(var(--radius) + 6px);
      border: 1px solid color-mix(in srgb, var(--border) 82%, transparent);
      background: color-mix(in oklab, var(--surface-1) 94%, transparent);
      padding: 1.25rem;
      box-shadow: 0 26px 52px -30px rgba(15, 23, 42, 0.45);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .json-editor-toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }
    .json-editor-tabs {
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
      border-radius: 999px;
      border: 1px solid color-mix(in srgb, var(--border) 80%, transparent);
      background: color-mix(in oklab, var(--surface-2) 92%, transparent);
      padding: 0.35rem;
      box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.08);
    }
    .json-editor-viewer {
      position: relative;
      border-radius: calc(var(--radius) + 2px);
      border: 1px solid color-mix(in srgb, var(--border) 80%, transparent);
      background: color-mix(in oklab, var(--surface-0) 96%, transparent);
      padding: 1rem;
      max-height: 24rem;
      overflow: auto;
      font-family: "JetBrains Mono", "Fira Code", "Cascadia Code", "SFMono-Regular", ui-monospace, monospace;
      font-size: 0.85rem;
      line-height: 1.6;
      direction: ltr;
      color: color-mix(in srgb, var(--card-foreground) 92%, transparent);
      box-shadow: inset 0 1px 1px rgba(15, 23, 42, 0.05);
    }
    .json-tree-viewer {
      padding: 0;
      overflow: hidden;
    }
    .json-tree-viewer[data-json-ready='true'] .json-tree-fallback {
      display: none;
    }
    .json-tree-error {
      margin: 0.5rem 1rem;
      padding: 0.75rem 1rem;
      border-radius: calc(var(--radius) - 6px);
      background: color-mix(in srgb, var(--destructive) 8%, transparent);
      color: color-mix(in srgb, var(--destructive-foreground) 86%, transparent);
      font-size: 0.8rem;
    }
    .json-tree-fallback {
      margin: 0;
      padding: 1rem;
      font-size: 0.82rem;
      line-height: 1.6;
      direction: ltr;
      background: transparent;
      color: inherit;
      overflow: auto;
      border: 0;
      box-shadow: none;
    }
    .json-tree {
      padding: 0.75rem 1rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-family: "JetBrains Mono", "Fira Code", "Cascadia Code", "SFMono-Regular", ui-monospace, monospace;
      font-size: 0.82rem;
      line-height: 1.6;
      direction: ltr;
    }
    .json-tree-node {
      display: flex;
      align-items: flex-start;
      gap: 0.45rem;
      color: color-mix(in srgb, var(--card-foreground) 92%, transparent);
    }
    .json-tree-node--branch {
      font-weight: 500;
    }
    .json-tree-node--collapsed > .json-tree-children {
      display: none;
    }
    .json-tree-toggle,
    .json-tree-spacer {
      width: 1.45rem;
      flex: 0 0 1.45rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-top: 0.15rem;
    }
    .json-tree-toggle {
      border: 1px solid color-mix(in srgb, var(--border) 82%, transparent);
      background: color-mix(in srgb, var(--surface-2) 80%, transparent);
      color: color-mix(in srgb, var(--foreground) 94%, transparent);
      border-radius: 999px;
      font-size: 0.75rem;
      height: 1.45rem;
      cursor: pointer;
      box-shadow: inset 0 1px 1px rgba(15, 23, 42, 0.04);
      transition: background-color 160ms ease, color 160ms ease, border-color 160ms ease;
    }
    .json-tree-toggle:hover,
    .json-tree-toggle:focus {
      outline: none;
      border-color: color-mix(in srgb, var(--primary) 70%, transparent);
      background: color-mix(in srgb, var(--primary) 16%, transparent);
      color: color-mix(in srgb, var(--primary-foreground) 94%, transparent);
    }
    .json-tree-key {
      color: color-mix(in srgb, var(--primary) 72%, transparent);
    }
    .json-tree-separator {
      color: color-mix(in srgb, var(--muted-foreground) 74%, transparent);
    }
    .json-tree-summary {
      color: color-mix(in srgb, var(--muted-foreground) 78%, transparent);
      font-weight: 400;
    }
    .json-tree-value {
      font-weight: 400;
    }
    .json-tree-value-string {
      color: color-mix(in srgb, #16a34a 78%, transparent);
    }
    .json-tree-value-number {
      color: color-mix(in srgb, #0284c7 82%, transparent);
    }
    .json-tree-value-boolean {
      color: color-mix(in srgb, #d97706 80%, transparent);
    }
    .json-tree-value-null {
      color: color-mix(in srgb, #9333ea 78%, transparent);
    }
    .json-tree-value-unknown {
      color: color-mix(in srgb, var(--muted-foreground) 86%, transparent);
    }
    .json-tree-children {
      margin-left: 1.45rem;
      padding-left: 0.75rem;
      border-left: 1px solid color-mix(in srgb, var(--border) 72%, transparent);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .json-editor-viewer code {
      white-space: pre;
      display: block;
    }
    .json-editor-empty {
      border: 1px dashed color-mix(in srgb, var(--border) 72%, transparent);
      border-radius: calc(var(--radius) + 2px);
      background: color-mix(in oklab, var(--surface-0) 88%, transparent);
      padding: 2.5rem 1rem;
      text-align: center;
      font-size: 0.85rem;
      color: color-mix(in srgb, var(--muted-foreground) 88%, transparent);
    }
    .json-textarea {
      width: 100%;
      min-height: 20rem;
      resize: vertical;
      border-radius: calc(var(--radius) + 2px);
      border: 1px solid color-mix(in srgb, var(--border) 84%, transparent);
      background: color-mix(in oklab, var(--surface-0) 96%, transparent);
      color: color-mix(in srgb, var(--card-foreground) 94%, transparent);
      font-family: "JetBrains Mono", "Fira Code", "Cascadia Code", "SFMono-Regular", ui-monospace, monospace;
      font-size: 0.85rem;
      line-height: 1.6;
      padding: 1rem;
      direction: ltr;
      box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.06);
    }
    .json-textarea:focus {
      outline: none;
      border-color: color-mix(in srgb, var(--primary) 80%, transparent);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 18%, transparent);
    }
    .CodeMirror {
      border-radius: calc(var(--radius) + 2px);
      border: 1px solid color-mix(in srgb, var(--border) 84%, transparent);
      background: color-mix(in oklab, var(--surface-0) 96%, transparent);
      color: color-mix(in srgb, var(--card-foreground) 94%, transparent);
      font-family: "JetBrains Mono", "Fira Code", "Cascadia Code", "SFMono-Regular", ui-monospace, monospace;
      font-size: 0.85rem;
      line-height: 1.6;
      min-height: 20rem;
      height: auto;
      box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.06);
    }
    .CodeMirror-scroll {
      max-height: 24rem;
    }
    .CodeMirror-gutters {
      background: color-mix(in oklab, var(--surface-2) 92%, transparent);
      border-color: color-mix(in srgb, var(--border) 78%, transparent);
    }
    .CodeMirror-linenumber {
      color: color-mix(in srgb, var(--muted-foreground) 86%, transparent);
    }
    .CodeMirror-selected {
      background: color-mix(in srgb, var(--primary) 30%, transparent) !important;
    }
    .CodeMirror-cursor {
      border-left: 2px solid color-mix(in srgb, var(--primary) 90%, transparent);
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/@antv/x6@1.35.3/dist/x6.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" integrity="sha512-+3bIan+FJxuxMxDPZWS9Vyuk3F7S3w7Dnk3a1JpN96CBvs1+qsSVqSdz+CA0nVddOZXS6jttuPAHyBs+K6Tf1A==" crossorigin="anonymous" referrerpolicy="no-referrer"/>
  <script src="./mishkah-utils.js"></script>
  <script src="./mishkah.core.js"></script>
  <script src="./mishkah-ui.js"></script>
  <script src="./mishkah-schema.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js" integrity="sha512-DpQ0siJmq9hw3rroWAt4EvsC0BpvyEukgqS0bkkCm1cW0XkyKADVY6jwxKF1u9IiMaivGi99ZTSdKCbFf8C9mg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js" integrity="sha512-LFxrDx9yZq9KoU0zY4xXHzkwmo7aX6ixkmKuuNHYsYvwdivgLPgAvFp8ZUBKbjsggq09uXBJgp7wa9u0edPF7w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <div id="app"></div>
  <script>
  (async function(){
    const M = Mishkah;
    const UI = M.UI;
    const U = M.utils;
    const D = M.DSL;
    const Schema = M.schema;
    const { tw, cx } = U.twcss;
    const Text = U.Text || {};
    const LangUtils = U.lang || {};
    const StorageUtils = U.Storage || {};
    const preferencesStore = StorageUtils && typeof StorageUtils.local === 'function'
      ? StorageUtils.local('erd-preferences')
      : null;

    function readUIPreferences(){
      const defaults = {
        panels:{ libraryOpen:false, classificationOpen:false },
        template:{ open:false }
      };
      if(!preferencesStore){
        return defaults;
      }
      const storedPanels = preferencesStore.get('panels', {});
      const storedTemplate = preferencesStore.get('template', {});
      return {
        panels:{
          libraryOpen: storedPanels.libraryOpen != null ? !!storedPanels.libraryOpen : defaults.panels.libraryOpen,
          classificationOpen: storedPanels.classificationOpen != null ? !!storedPanels.classificationOpen : defaults.panels.classificationOpen
        },
        template:{
          open: storedTemplate.open != null ? !!storedTemplate.open : defaults.template.open
        }
      };
    }

    function persistPanelPreference(panelKey, value){
      if(!preferencesStore) return;
      const current = preferencesStore.get('panels', {});
      preferencesStore.set('panels', Object.assign({}, current, { [panelKey]: !!value }));
    }

    function persistTemplatePreference(isOpen){
      if(!preferencesStore) return;
      preferencesStore.set('template', { open: !!isOpen });
    }

    function hasOpenModal(state){
      if(!state || typeof state !== 'object') return false;
      const uiState = state.ui;
      if(!uiState || typeof uiState !== 'object') return false;
      const modalsState = uiState.modals;
      if(!modalsState || typeof modalsState !== 'object') return false;
      return Object.values(modalsState).some(Boolean);
    }

    function createTranslator(db){
      const lookup = typeof LangUtils.makeLangLookup === 'function'
        ? LangUtils.makeLangLookup(db)
        : { TL:(key)=>key };
      const TL = typeof lookup.TL === 'function' ? lookup.TL : (key)=>key;
      return (key, fallback)=>{
        const value = TL(key);
        return value === key ? (fallback != null ? fallback : key) : value;
      };
    }

    const JSON_CODEMIRROR_REGISTRY = new WeakMap();
    let jsonEditorsObserver = null;
    let jsonEditorsRefreshScheduled = false;

    function ensureCodeMirrorInstance(textarea){
      if(!textarea || typeof window === 'undefined') return;
      if(typeof window.CodeMirror === 'undefined') return;
      const desiredHeight = parseInt(textarea.getAttribute('data-height') || '0', 10);
      const readOnlyAttr = textarea.getAttribute('readonly');
      const readOnly = readOnlyAttr != null && readOnlyAttr !== 'false';
      const existing = JSON_CODEMIRROR_REGISTRY.get(textarea);
      if(existing && existing.editor){
        existing.editor.setOption('readOnly', readOnly ? 'nocursor' : false);
        if(desiredHeight > 0){
          existing.editor.setSize('100%', `${desiredHeight}px`);
        } else {
          existing.editor.setSize('100%', 'auto');
        }
        const nextValue = textarea.value || '';
        existing.sync(nextValue);
        existing.editor.refresh();
        return;
      }

      const instance = { editor:null, suppress:false, sync:()=>{} };
      const editor = window.CodeMirror.fromTextArea(textarea, {
        mode:{ name:'javascript', json:true },
        lineNumbers:true,
        lineWrapping:true,
        tabSize:2,
        indentUnit:2,
        viewportMargin: Infinity,
        readOnly: readOnly ? 'nocursor' : false
      });

      if(desiredHeight > 0){
        editor.setSize('100%', `${desiredHeight}px`);
      } else {
        editor.setSize('100%', 'auto');
      }

      instance.editor = editor;
      instance.sync = (value)=>{
        if(!instance.editor) return;
        const next = typeof value === 'string' ? value : (value == null ? '' : String(value));
        if(next === instance.editor.getValue()) return;
        instance.suppress = true;
        instance.editor.setValue(next);
        instance.suppress = false;
      };

      editor.on('change', cm=>{
        if(instance.suppress) return;
        const updated = cm.getValue();
        if(textarea.value !== updated){
          textarea.value = updated;
        }
        const evt = new Event('input', { bubbles:true });
        textarea.dispatchEvent(evt);
      });

      JSON_CODEMIRROR_REGISTRY.set(textarea, instance);
      instance.sync(textarea.value || '');
    }

    function enhanceJsonEditors(root){
      if(typeof window === 'undefined') return;
      const scope = root && root.querySelectorAll ? root : document;
      enhanceJsonTreeViewers(scope);
      if(typeof window.CodeMirror === 'undefined') return;
      const nodes = scope.querySelectorAll ? scope.querySelectorAll('textarea[data-codemirror="json"]') : [];
      nodes.forEach(ensureCodeMirrorInstance);
    }

    function scheduleJsonEditorRefresh(root){
      if(jsonEditorsRefreshScheduled) return;
      jsonEditorsRefreshScheduled = true;
      const run = ()=>{
        jsonEditorsRefreshScheduled = false;
        enhanceJsonEditors(root || document);
      };
      if(typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function'){
        window.requestAnimationFrame(run);
      } else {
        setTimeout(run, 16);
      }
    }

    function setupJsonEditorsObserver(){
      if(typeof window === 'undefined' || typeof document === 'undefined') return;
      scheduleJsonEditorRefresh(document);
      if(jsonEditorsObserver) return;
      jsonEditorsObserver = new MutationObserver(()=> scheduleJsonEditorRefresh(document));
      jsonEditorsObserver.observe(document.body, { childList:true, subtree:true });
    }

    const JSON_TREE_REGISTRY = new WeakMap();

    function decodeJsonAttribute(text){
      if(typeof text !== 'string') return '';
      try {
        return decodeURIComponent(text);
      } catch(_){
        return text;
      }
    }

    function formatJsonPrimitive(value){
      if(value === null) return { text:'null', className:'json-tree-value-null' };
      const type = typeof value;
      switch(type){
        case 'string':
          return { text:`"${value}"`, className:'json-tree-value-string' };
        case 'number':
        case 'bigint':
          return { text:String(value), className:'json-tree-value-number' };
        case 'boolean':
          return { text:value ? 'true' : 'false', className:'json-tree-value-boolean' };
        case 'undefined':
          return { text:'undefined', className:'json-tree-value-unknown' };
        default:
          return { text:String(value), className:'json-tree-value-unknown' };
      }
    }

    function createJsonTreeChildren(value, level, toggleLabel){
      const fragment = document.createDocumentFragment();
      if(Array.isArray(value)){
        if(value.length === 0){
          fragment.appendChild(createJsonTreeNode(null, '[]', level, toggleLabel, { summaryOnly:true }));
        } else {
          value.forEach((item, index)=>{
            fragment.appendChild(createJsonTreeNode(String(index), item, level, toggleLabel));
          });
        }
        return fragment;
      }
      if(value && typeof value === 'object'){
        const keys = Object.keys(value);
        if(keys.length === 0){
          fragment.appendChild(createJsonTreeNode(null, '{}', level, toggleLabel, { summaryOnly:true }));
        } else {
          keys.forEach(key=>{
            fragment.appendChild(createJsonTreeNode(key, value[key], level, toggleLabel));
          });
        }
        return fragment;
      }
      fragment.appendChild(createJsonTreeNode(null, value, level, toggleLabel));
      return fragment;
    }

    function createJsonTreeNode(key, value, level, toggleLabel, options){
      const opts = options || {};
      const node = document.createElement('div');
      node.className = 'json-tree-node';
      node.setAttribute('role', 'treeitem');
      node.setAttribute('aria-level', String(level));

      const isComplex = value && typeof value === 'object';
      const hasChildren = isComplex && (Array.isArray(value) ? value.length > 0 : Object.keys(value).length > 0);
      const isSummaryOnly = opts.summaryOnly === true;
      let toggle;

      if(isComplex && hasChildren){
        node.classList.add('json-tree-node--branch');
        toggle = document.createElement('button');
        toggle.type = 'button';
        toggle.className = 'json-tree-toggle';
        toggle.setAttribute('aria-label', toggleLabel || 'Toggle');
        toggle.setAttribute('aria-expanded', 'true');
        toggle.textContent = '−';
        node.appendChild(toggle);
      } else {
        const spacer = document.createElement('span');
        spacer.className = 'json-tree-spacer';
        node.appendChild(spacer);
      }

      if(key != null){
        const keySpan = document.createElement('span');
        keySpan.className = 'json-tree-key';
        keySpan.textContent = JSON.stringify(key);
        node.appendChild(keySpan);

        const separator = document.createElement('span');
        separator.className = 'json-tree-separator';
        separator.textContent = ':';
        node.appendChild(separator);
      }

      if(isComplex){
        const summary = document.createElement('span');
        summary.className = 'json-tree-summary';
        const size = Array.isArray(value) ? value.length : Object.keys(value).length;
        summary.textContent = Array.isArray(value) ? `Array(${size})` : `Object(${size})`;
        node.appendChild(summary);

        if(hasChildren){
          const children = document.createElement('div');
          children.className = 'json-tree-children';
          children.setAttribute('role', 'group');
          children.appendChild(createJsonTreeChildren(value, level + 1, toggleLabel));
          node.appendChild(children);

          if(toggle){
            toggle.addEventListener('click', ()=>{
              const collapsed = node.classList.toggle('json-tree-node--collapsed');
              toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
              toggle.textContent = collapsed ? '+' : '−';
            });
          }

          return node;
        }
      }

      if(isSummaryOnly){
        const summary = document.createElement('span');
        summary.className = 'json-tree-summary';
        summary.textContent = typeof value === 'string' ? value : JSON.stringify(value);
        node.appendChild(summary);
        return node;
      }

      const { text, className } = formatJsonPrimitive(value);
      const valueSpan = document.createElement('span');
      valueSpan.className = `json-tree-value ${className}`;
      valueSpan.textContent = text;
      node.appendChild(valueSpan);

      return node;
    }

    function ensureJsonTreeInstance(container){
      if(typeof document === 'undefined' || !container) return;
      const encoded = container.getAttribute('data-json-text') || '';
      const prev = JSON_TREE_REGISTRY.get(container);
      if(prev && prev.encoded === encoded) return;

      const raw = decodeJsonAttribute(encoded);
      container.setAttribute('data-json-raw', raw);
      container.setAttribute('data-json-ready', 'false');
      container.removeAttribute('data-json-error');
      const toggleLabel = container.getAttribute('data-json-toggle-label') || 'Toggle node';
      const errorMessage = container.getAttribute('data-json-fallback') || '';

      let data;
      let parsed = false;
      if(raw && raw.trim){
        try {
          data = JSON.parse(raw);
          parsed = true;
        } catch(_){
          parsed = false;
        }
      }

      container.querySelectorAll('.json-tree, .json-tree-error').forEach(node=> node.remove());

      if(!parsed){
        if(errorMessage){
          const alert = document.createElement('div');
          alert.className = 'json-tree-error';
          alert.textContent = errorMessage;
          container.insertBefore(alert, container.firstChild);
        }
        container.setAttribute('data-json-error', 'true');
        JSON_TREE_REGISTRY.set(container, { encoded, raw, error:true });
        return;
      }

      const tree = document.createElement('div');
      tree.className = 'json-tree';
      tree.setAttribute('role', 'tree');
      tree.appendChild(createJsonTreeChildren(data, 1, toggleLabel));
      container.appendChild(tree);
      container.setAttribute('data-json-ready', 'true');
      JSON_TREE_REGISTRY.set(container, { encoded, raw, error:false });
    }

    function enhanceJsonTreeViewers(root){
      if(typeof document === 'undefined') return;
      const scope = root && root.querySelectorAll ? root : document;
      const nodes = scope.querySelectorAll ? scope.querySelectorAll('[data-json-tree]') : [];
      nodes.forEach(ensureJsonTreeInstance);
    }

    function JsonEditorTabs(db, options){
      const opts = options || {};
      const editorId = opts.id || 'json';
      const allowEdit = opts.allowEdit !== false;
      const rawValue = typeof opts.text === 'string' ? opts.text : (opts.text == null ? '' : JSON.stringify(opts.text, null, 2));
      const translators = typeof opts.t === 'function' ? opts.t : (key, fallback)=>fallback;
      const normalizedRows = Number.isFinite(opts.rows) ? Math.max(4, Math.floor(opts.rows)) : Math.max(4, parseInt(opts.rows, 10) || 0);
      const normalizedHeight = Number.isFinite(opts.height) ? Math.max(320, Math.floor(opts.height)) : Math.max(320, parseInt(opts.height, 10) || 0);
      let prettyText = rawValue;
      if(rawValue && rawValue.trim){
        const trimmed = rawValue.trim();
        if(trimmed){
          try {
            prettyText = JSON.stringify(JSON.parse(trimmed), null, 2);
          } catch(_){
            prettyText = rawValue;
          }
        }
      }
      const editorsState = db?.ui?.jsonEditors || {};
      const storedMode = editorsState[editorId]?.mode;
      const defaultMode = allowEdit ? 'editor' : 'viewer';
      const activeMode = storedMode === 'viewer' || storedMode === 'editor' ? storedMode : defaultMode;
      const viewerActive = activeMode === 'viewer';
      const editorActive = activeMode === 'editor' && allowEdit;
      const viewerLabel = translators('json.tabs.viewer', 'عرض');
      const editorLabel = translators('json.tabs.editor', 'تحرير');
      const copyLabel = translators('json.tabs.copy', 'نسخ');
      const hasContent = !!(prettyText && typeof prettyText === 'string' && prettyText.trim());

      const shellClass = tw(cx('json-editor-shell', tw`space-y-4`));
      const toolbarClass = tw(cx('json-editor-toolbar', tw`w-full`));
      const tabsClass = tw(cx('json-editor-tabs', tw`bg-transparent`));
      const viewerPanelClass = tw(cx('json-editor-panel', viewerActive ? 'block' : 'hidden'));
      const editorPanelClass = tw(cx('json-editor-panel', editorActive ? 'block' : 'hidden'));

      const viewerButton = UI.Button({
        attrs:{
          gkey:'erd:json:tab',
          'data-editor-id': editorId,
          'data-editor-mode':'viewer',
          'aria-pressed': viewerActive ? 'true' : 'false',
          class: tw`${viewerActive ? '!bg-[var(--primary)] !text-[var(--primary-foreground)] shadow-sm' : '!text-[var(--muted-foreground)] hover:!text-[var(--foreground)]'} !h-9 !rounded-full !px-4 text-xs font-semibold flex items-center gap-1`
        },
        variant:'ghost',
        size:'sm'
      }, [`👁️ ${viewerLabel}`]);

      const editorButton = allowEdit ? UI.Button({
        attrs:{
          gkey:'erd:json:tab',
          'data-editor-id': editorId,
          'data-editor-mode':'editor',
          'aria-pressed': editorActive ? 'true' : 'false',
          class: tw`${editorActive ? '!bg-[var(--primary)] !text-[var(--primary-foreground)] shadow-sm' : '!text-[var(--muted-foreground)] hover:!text-[var(--foreground)]'} !h-9 !rounded-full !px-4 text-xs font-semibold flex items-center gap-1`
        },
        variant:'ghost',
        size:'sm'
      }, [`⌨️ ${editorLabel}`]) : null;

      const copyButtonClass = tw(cx('json-copy-btn', tw`!h-9 !rounded-full !px-4 text-xs font-semibold flex items-center gap-1`));
      const copyButton = UI.Button({
        attrs:{
          gkey:'erd:json:copy',
          'data-editor-id': editorId,
          class: copyButtonClass
        },
        variant:'soft',
        size:'sm'
      }, [`📋 ${copyLabel}`]);

      const textareaAttrs = {
        class:'json-textarea',
        rows: normalizedRows,
        value: rawValue,
        placeholder: opts.placeholder || '',
        dir:'ltr',
        spellcheck:'false',
        autocomplete:'off',
        'data-codemirror':'json',
        'data-editor-id': editorId,
        'data-height': String(normalizedHeight),
        'data-json-source':'editor',
        style:`min-height:${normalizedHeight}px;`
      };
      if(opts.gkey) textareaAttrs.gkey = opts.gkey;
      if(opts.formKey) textareaAttrs['data-form'] = opts.formKey;
      if(opts.fieldKey) textareaAttrs['data-field'] = opts.fieldKey;

      const header = D.Containers.Div({ attrs:{ class: toolbarClass }}, [
        D.Containers.Div({ attrs:{ class: tabsClass }}, [viewerButton, editorButton].filter(Boolean)),
        copyButton
      ]);

      const viewerContainerClass = tw(cx('json-editor-viewer json-tree-viewer', tw`relative`));
      const viewerPanel = D.Containers.Div({ attrs:{ class: viewerPanelClass }}, [
        hasContent
          ? D.Containers.Div({
              attrs:{
                class: viewerContainerClass,
                'data-json-source':'viewer',
                'data-json-tree':'true',
                'data-json-text': encodeURIComponent(prettyText),
                'data-json-toggle-label': translators('json.tree.toggle', 'تبديل العنصر'),
                'data-json-fallback': translators('json.tree.invalid', 'تعذر تحليل JSON للعرض الشجري. سيتم عرض النص كما هو.'),
                dir:'ltr'
              }
            }, [
              D.Text.Pre({ attrs:{ class:'json-tree-fallback' }}, [
                D.Text.Code({ attrs:{ class: tw`block` }}, [prettyText])
              ])
            ])
          : D.Containers.Div({ attrs:{ class:'json-editor-empty', 'data-json-source':'viewer' }}, [
              translators('json.tabs.empty', 'لا يوجد محتوى JSON للعرض حاليًا.')
            ])
      ]);

      const editorPanel = allowEdit
        ? D.Containers.Div({ attrs:{ class: editorPanelClass }}, [
            D.Inputs.Textarea({ attrs: textareaAttrs })
          ])
        : null;

      return D.Containers.Div({ attrs:{ class: shellClass, 'data-json-editor': editorId }}, [
        header,
        viewerPanel,
        editorPanel
      ].filter(Boolean));
    }

    setupJsonEditorsObserver();

    const I18N_DICT = {
      'app.title':{ ar:'مخطط قاعدة بيانات مشكاة', en:'Mishkah Database Diagram' },
      'schema.untitled':{ ar:'مخطط بدون اسم', en:'Untitled diagram' },
      'library.title':{ ar:'مكتبة المخططات', en:'Diagram library' },
      'library.empty':{ ar:'لم يتم حفظ أي مخططات بعد.', en:'No diagrams saved yet.' },
      'library.storage.indexeddb':{ ar:'IndexedDB', en:'IndexedDB' },
      'library.storage.memory':{ ar:'ذاكرة مؤقتة', en:'Memory cache' },
      'library.new.button':{ ar:'مخطط جديد', en:'New diagram' },
      'library.import.button':{ ar:'استيراد JSON', en:'Import JSON' },
      'library.delete.title':{ ar:'حذف المخطط', en:'Delete diagram' },
      'template.overlay.heading':{ ar:'ملخص القالب الحالي', en:'Template overview' },
      'template.overlay.hide':{ ar:'إخفاء', en:'Hide' },
      'template.overlay.hide-title':{ ar:'إخفاء الملخص', en:'Hide summary' },
      'template.overlay.show':{ ar:'عرض', en:'Show' },
      'template.overlay.description':{ ar:'هذا الملخص يوضح الجداول النشطة وعدد الحقول والعلاقات، مما يساعدك على فهم شكل المخطط بسرعة.', en:'This summary highlights the active tables, field counts, and relationships to give you a quick understanding of the diagram.' },
      'template.overlay.empty':{ ar:'ابدأ بإضافة جدول لإنشاء قالب المخطط.', en:'Start by adding a table to generate a template.' },
      'template.overlay.add-column.title':{ ar:'إضافة عمود جديد لهذا الجدول', en:'Add a new column to this table' },
      'canvas.empty':{ ar:'أضف جدولًا جديدًا لبدء بناء المخطط.', en:'Add a new table to start building the diagram.' },
      'toolbar.export':{ ar:'تصدير', en:'Export' },
      'toolbar.stats.tables':{ ar:'جداول', en:'Tables' },
      'toolbar.stats.fields':{ ar:'حقول', en:'Fields' },
      'toolbar.stats.relations':{ ar:'علاقات', en:'Relations' },
      'toolbar.schema.group':{ ar:'المخطط', en:'Diagram' },
      'toolbar.schema.driver':{ ar:'المحرك', en:'Driver' },
      'toolbar.schema.edit':{ ar:'خصائص المخطط', en:'Schema properties' },
      'toolbar.structure.group':{ ar:'العناصر', en:'Elements' },
      'toolbar.structure.addTable':{ ar:'جدول', en:'Table' },
      'toolbar.structure.addField':{ ar:'حقل', en:'Field' },
      'toolbar.structure.addRelation':{ ar:'علاقة', en:'Relation' },
      'toolbar.structure.columns':{ ar:'الأعمدة', en:'Columns' },
      'toolbar.templates.group':{ ar:'القوالب', en:'Templates' },
      'toolbar.templates.hide':{ ar:'إخفاء القالب', en:'Hide template' },
      'toolbar.templates.show':{ ar:'عرض القالب', en:'Show template' },
      'toolbar.quickActions':{ ar:'أوامر سريعة', en:'Quick actions' },
      'panel.library.hide':{ ar:'إخفاء المكتبة', en:'Hide library' },
      'panel.library.show':{ ar:'إظهار المكتبة', en:'Show library' },
      'panel.classification.hide':{ ar:'إخفاء التصنيف', en:'Hide classification' },
      'panel.classification.show':{ ar:'إظهار التصنيف', en:'Show classification' },
      'toolbar.ui.group':{ ar:'الواجهة', en:'Interface' },
      'toolbar.ui.theme.light':{ ar:'تفعيل الوضع النهاري', en:'Switch to light mode' },
      'toolbar.ui.theme.dark':{ ar:'تفعيل الوضع الليلي', en:'Switch to dark mode' },
      'toolbar.history.group':{ ar:'التاريخ', en:'History' },
      'toolbar.history.undo.title':{ ar:'تراجع', en:'Undo' },
      'toolbar.history.redo.title':{ ar:'إعادة', en:'Redo' },
      'toolbar.history.fit.title':{ ar:'ملاءمة المخطط للشاشة', en:'Fit diagram to screen' },
      'toolbar.export.group':{ ar:'التصدير', en:'Export' },
      'toolbar.zoom.group':{ ar:'الحجم', en:'Zoom' },
      'toolbar.zoom.out.title':{ ar:'تصغير', en:'Zoom out' },
      'toolbar.zoom.reset.title':{ ar:'إعادة الحجم', en:'Reset zoom' },
      'toolbar.zoom.in.title':{ ar:'تكبير', en:'Zoom in' },
      'classification.title':{ ar:'sche_Tree', en:'sche_Tree' },
      'classification.addRow':{ ar:'إضافة صف', en:'Add row' },
      'classification.save':{ ar:'حفظ التصنيف', en:'Save classification' },
      'classification.bulk':{ ar:'ترميز الشجرة', en:'Encode tree' },
      'classification.code':{ ar:'الكود', en:'Code' },
      'classification.name':{ ar:'الاسم', en:'Name' },
      'classification.parent':{ ar:'الأب', en:'Parent' },
      'classification.empty':{ ar:'لم يتم تعريف أي فئات بعد.', en:'No classes defined yet.' },
      'classification.leaf.only':{ ar:'يرجى اختيار كود نهائي من الشجرة.', en:'Please choose a leaf code from the tree.' },
      'modal.classification.title':{ ar:'إدارة ترميز الشجرة', en:'Manage tree encoding' },
      'modal.classification.description':{ ar:'حرر قائمة الفئات بصيغة JSON (code، name، parent).', en:'Edit the class list as JSON (code, name, parent).' },
      'modal.classification.placeholder':{ ar:'[{"code":"01","name":"Root","parent":null}]', en:'[{"code":"01","name":"Root","parent":null}]' },
      'modal.classification.apply':{ ar:'تطبيق', en:'Apply' },
      'modal.table.class.placeholder':{ ar:'اختر الفئة', en:'Select class' },
      'modal.table.class.label':{ ar:'الفئة (Class)', en:'Class' },
      'modal.import.title':{ ar:'استيراد مخطط JSON', en:'Import JSON diagram' },
      'modal.import.description':{ ar:'ألصق بيانات المخطط أو استبدل مخططًا موجودًا.', en:'Paste the diagram data or replace an existing diagram.' },
      'modal.import.name.placeholder':{ ar:'المعرف الفريد للمخطط (name)', en:'Unique diagram identifier (name)' },
      'modal.import.title.placeholder':{ ar:'العنوان المعروض', en:'Displayed title' },
      'modal.import.target.new':{ ar:'إنشاء مخطط جديد', en:'Create a new diagram' },
      'modal.import.target.replace':{ ar:'استبدال:', en:'Replace:' },
      'modal.import.submit':{ ar:'استيراد وتخزين', en:'Import and store' },
      'modal.close':{ ar:'إغلاق', en:'Close' },
      'modal.exportJson.title':{ ar:'مخطط JSON', en:'JSON diagram' },
      'modal.exportJson.description':{ ar:'انسخ المحتوى للاستخدام في أماكن أخرى.', en:'Copy the content for use elsewhere.' },
      'json.tabs.viewer':{ ar:'عرض', en:'Viewer' },
      'json.tabs.editor':{ ar:'تحرير', en:'Editor' },
      'json.tabs.copy':{ ar:'نسخ', en:'Copy' },
      'json.tabs.empty':{ ar:'لا يوجد محتوى JSON للعرض حاليًا.', en:'There is no JSON content to display yet.' },
      'json.tree.toggle':{ ar:'تبديل العنصر', en:'Toggle node' },
      'json.tree.invalid':{ ar:'تعذر تحليل JSON للعرض الشجري، يتم عرض النص كما هو.', en:'Unable to parse JSON for the tree view; showing raw text instead.' },
      'json.copy.success':{ ar:'تم نسخ JSON إلى الحافظة', en:'JSON copied to the clipboard' },
      'json.copy.error':{ ar:'تعذر نسخ JSON', en:'Unable to copy JSON' },
      'json.copy.unavailable':{ ar:'لا يوجد نص لنسخه', en:'There is no text to copy' },
      'modal.done':{ ar:'تم', en:'Done' },
      'modal.exportSql.title':{ ar:'نص SQL', en:'SQL script' },
      'modal.exportSql.description':{ ar:'هذا النص يمثل أوامر إنشاء الجداول PostgreSQL.', en:'This script represents the PostgreSQL table definitions.' },
      'modal.schemaMeta.title':{ ar:'خصائص المخطط', en:'Diagram properties' },
      'modal.schemaMeta.description':{ ar:'قم بتحديث اسم التعريف والعنوان والوصف.', en:'Update the identifier, title, and description.' },
      'modal.schemaMeta.description.placeholder':{ ar:'وصف مختصر للمخطط', en:'Short diagram description' },
      'modal.schemaMeta.save':{ ar:'حفظ التعديلات', en:'Save changes' },
      'modal.table.title':{ ar:'إنشاء جدول جديد', en:'Create new table' },
      'modal.table.description':{ ar:'الاسم الإنجليزي مطلوب وسيُستخدم كاسم الجدول في قاعدة البيانات. يمكنك إضافة مسمى بلغة أخرى اختياريًا.', en:'An English name is required and will be used as the table name in the database. You can optionally provide another language label.' },
      'modal.table.name.placeholder':{ ar:'English name (مثال: Sales Orders)', en:'English name (e.g. Sales Orders)' },
      'modal.table.label.placeholder':{ ar:'اسم الجدول بلغة ثانية (اختياري)', en:'Table label in another language (optional)' },
      'common.notes.placeholder':{ ar:'ملاحظات', en:'Notes' },
      'modal.table.includeId':{ ar:'إنشاء حقل id افتراضي؟', en:'Create default id field?' },
      'common.create':{ ar:'إنشاء', en:'Create' },
      'common.cancel':{ ar:'إلغاء', en:'Cancel' },
      'table.create.helper.suggested':{ ar:'سيتم حفظ الجدول في قاعدة البيانات بالاسم: {name} مع ضمان عدم تكرار المعرف داخل المخطط.', en:'The table will be saved in the database with the name: {name}, ensuring the identifier stays unique within the diagram.' },
      'table.create.helper.prompt':{ ar:'اكتب اسمًا إنجليزيًا، وسيتم تحويل المسافات والمحارف الخاصة تلقائيًا إلى صيغة SQL سليمة.', en:'Type an English name; spaces and special characters will be converted automatically to a valid SQL identifier.' },
      'modal.field.title':{ ar:'إضافة حقل', en:'Add field' },
      'modal.field.description':{ ar:'حدد تفاصيل الحقل الجديد مع اسم إنجليزي متوافق مع SQL ومسمى عربي اختياري.', en:'Provide the new field details with an SQL-friendly English name and an optional localized label.' },
      'modal.field.table.placeholder':{ ar:'اختر الجدول', en:'Select table' },
      'modal.field.label.placeholder':{ ar:'المسمى العربي للحقل', en:'Field display label' },
      'modal.field.identifier.preview':{ ar:'المعرف النهائي: {name}', en:'Final identifier: {name}' },
      'modal.field.identifier.pending':{ ar:'سيتم توليد المعرف تلقائيًا عند الكتابة.', en:'The identifier is generated automatically as you type.' },
      'modal.field.default.placeholder':{ ar:'قيمة افتراضية', en:'Default value' },
      'modal.field.nullable':{ ar:'Nullable؟', en:'Nullable?' },
      'modal.field.primaryKey':{ ar:'Primary Key؟', en:'Primary key?' },
      'modal.field.unique':{ ar:'Unique؟', en:'Unique?' },
      'modal.field.reference.title':{ ar:'علاقة مرجعية اختيارية', en:'Optional reference' },
      'modal.field.reference.none':{ ar:'بدون علاقة', en:'No relation' },
      'modal.field.reference.selectField':{ ar:'اختر الحقل', en:'Select field' },
      'common.add':{ ar:'إضافة', en:'Add' },
      'modal.relation.title':{ ar:'إنشاء علاقة بين الجداول', en:'Create relationship between tables' },
      'modal.relation.description':{ ar:'حدد الجدول المصدر والهدف وأسلوب التحديث.', en:'Choose the source and target tables and the update strategy.' },
      'modal.relation.sourceTable':{ ar:'اختر الجدول المصدر', en:'Select source table' },
      'modal.relation.sourceField':{ ar:'اختر الحقل المصدر', en:'Select source field' },
      'modal.relation.targetTable':{ ar:'اختر الجدول الهدف', en:'Select target table' },
      'modal.relation.targetField':{ ar:'اختر الحقل الهدف', en:'Select target field' },
      'modal.relation.save':{ ar:'حفظ العلاقة', en:'Save relationship' },
      'modal.columns.empty.title':{ ar:'محرر الأعمدة', en:'Columns editor' },
      'modal.columns.empty.description':{ ar:'لا توجد جداول في المخطط بعد. قم بإضافة جدول لبدء إدارة الأعمدة.', en:'There are no tables in the diagram yet. Add a table to start managing columns.' },
      'modal.columns.empty.action':{ ar:'أضف جدولًا جديدًا من شريط الأدوات ثم عد إلى هنا.', en:'Add a new table from the toolbar and come back here.' },
      'modal.columns.length.placeholder':{ ar:'الطول', en:'Length' },
      'modal.columns.precision.placeholder':{ ar:'الدقة', en:'Precision' },
      'modal.columns.scale.placeholder':{ ar:'المقياس', en:'Scale' },
      'modal.columns.focus':{ ar:'عرض في المخطط', en:'Locate' },
      'modal.columns.delete':{ ar:'حذف العمود', en:'Delete column' },
      'modal.columns.name.placeholder':{ ar:'اسم العمود (snake_case)', en:'Column name (snake_case)' },
      'modal.columns.default.placeholder':{ ar:'القيمة الافتراضية', en:'Default value' },
      'modal.columns.refTable.placeholder':{ ar:'جدول المرجع (FK)', en:'Reference table (FK)' },
      'modal.columns.refColumn.placeholder':{ ar:'حقل المرجع (FK)', en:'Reference field (FK)' },
      'modal.columns.noColumns':{ ar:'لا توجد أعمدة بعد لهذا الجدول.', en:'No columns for this table yet.' },
      'modal.columns.header':{ ar:'أعمدة الجدول', en:'Table columns' },
      'modal.columns.header.withName':{ ar:'أعمدة الجدول: {name}', en:'Table columns: {name}' },
      'modal.columns.addColumn':{ ar:'عمود جديد', en:'New column' },
      'modal.columns.title':{ ar:'محرر الأعمدة', en:'Columns editor' },
      'modal.columns.description':{ ar:'تحكم في أعمدة الجدول المحدد بسرعة عبر واجهة واحدة.', en:'Manage the selected table columns from one place.' },
      'modal.columns.tables':{ ar:'الجداول', en:'Tables' },
      'modal.columns.save':{ ar:'حفظ الأعمدة', en:'Save columns' },
      'modal.columns.table.header.name':{ ar:'الاسم', en:'Name' },
      'modal.columns.table.header.type':{ ar:'النوع', en:'Type' },
      'modal.columns.table.header.length':{ ar:'الطول / الدقة', en:'Length / precision' },
      'modal.columns.table.header.nullable':{ ar:'NULL؟', en:'NULL?' },
      'modal.columns.table.header.pk':{ ar:'PK', en:'PK' },
      'modal.columns.table.header.default':{ ar:'القيمة الافتراضية', en:'Default value' },
      'modal.columns.table.header.references':{ ar:'المفتاح الأجنبي', en:'Foreign key' },
      'modal.columns.table.header.actions':{ ar:'إجراءات', en:'Actions' },
      'modal.columns.reference.table':{ ar:'جدول المرجع', en:'Reference table' },
      'modal.columns.reference.column':{ ar:'حقل المرجع', en:'Reference column' },
      'modal.columns.reference.noMatch':{ ar:'لا توجد أعمدة متوافقة في الجدول المحدد.', en:'No compatible columns in the selected table.' },
      'modal.columns.reference.typeMismatch':{ ar:'يجب أن يتطابق نوع بيانات المفتاح الأجنبي مع العمود المرجعي.', en:'Foreign key type must match the referenced column.' },
      'modal.columns.section.unique':{ ar:'القيود الفريدة', en:'Unique constraints' },
      'modal.columns.section.indexes':{ ar:'الفهارس', en:'Indexes' },
      'modal.columns.unique.add':{ ar:'إضافة قيد فريد', en:'Add unique constraint' },
      'modal.columns.unique.empty':{ ar:'لا توجد قيود فريدة لهذا الجدول.', en:'No unique constraints for this table.' },
      'modal.columns.indexes.add':{ ar:'إضافة فهرس', en:'Add index' },
      'modal.columns.indexes.empty':{ ar:'لا توجد فهارس إضافية لهذا الجدول.', en:'No additional indexes for this table.' },
      'modal.columns.unique.edit':{ ar:'تعديل', en:'Edit' },
      'modal.columns.unique.delete':{ ar:'حذف', en:'Delete' },
      'modal.columns.indexes.edit':{ ar:'تعديل', en:'Edit' },
      'modal.columns.indexes.delete':{ ar:'حذف', en:'Delete' },
      'modal.columns.unique.modal.title':{ ar:'قيد فريد', en:'Unique constraint' },
      'modal.columns.unique.modal.description':{ ar:'حدد الأعمدة التي يجب أن تكون قيمها فريدة.', en:'Choose the columns that must stay unique.' },
      'modal.columns.unique.modal.name':{ ar:'اسم القيد', en:'Constraint name' },
      'modal.columns.unique.modal.columns':{ ar:'الأعمدة المرتبطة', en:'Columns' },
      'modal.columns.unique.save':{ ar:'حفظ القيد', en:'Save constraint' },
      'modal.columns.index.modal.title':{ ar:'فهرس جديد', en:'Index' },
      'modal.columns.index.modal.description':{ ar:'اختر الأعمدة وطريقة الفهرسة المفضلة.', en:'Pick the columns and indexing method.' },
      'modal.columns.index.modal.name':{ ar:'اسم الفهرس', en:'Index name' },
      'modal.columns.index.modal.method':{ ar:'طريقة الفهرسة', en:'Index method' },
      'modal.columns.index.modal.where':{ ar:'شرط التصفية (اختياري)', en:'Filter condition (optional)' },
      'modal.columns.index.modal.columns':{ ar:'الأعمدة المرتبطة', en:'Columns' },
      'modal.columns.index.save':{ ar:'حفظ الفهرس', en:'Save index' },
      'toast.columns.unique.saved':{ ar:'تم حفظ القيد الفريد', en:'Unique constraint saved' },
      'toast.columns.unique.deleted':{ ar:'تم حذف القيد الفريد', en:'Unique constraint removed' },
      'toast.columns.unique.invalid':{ ar:'اختر عمودًا واحدًا على الأقل للقيد الفريد.', en:'Select at least one column for the unique constraint.' },
      'toast.columns.index.saved':{ ar:'تم حفظ الفهرس بنجاح', en:'Index saved successfully' },
      'toast.columns.index.deleted':{ ar:'تم حذف الفهرس', en:'Index removed' },
      'toast.columns.index.invalid':{ ar:'اختر عمودًا واحدًا على الأقل للفهرس.', en:'Select at least one column for the index.' },
      'toast.columns.tableMissing':{ ar:'الجدول غير موجود', en:'Table not found' },
      'toast.columns.indexMissing':{ ar:'الفهرس غير موجود', en:'Index not found' },
      'context.section.schema':{ ar:'المخطط', en:'Diagram' },
      'context.section.structure':{ ar:'البنية', en:'Structure' },
      'context.section.outputs':{ ar:'المخرجات', en:'Outputs' },
      'context.section.relationships':{ ar:'العلاقات', en:'Relationships' },
      'context.table.rename':{ ar:'إعادة تسمية الجدول', en:'Rename table' },
      'context.table.duplicate':{ ar:'تكرار الجدول', en:'Duplicate table' },
      'context.table.delete':{ ar:'حذف الجدول', en:'Delete table' },
      'context.table.columns':{ ar:'إدارة الأعمدة', en:'Manage columns' },
      'context.table.addUnique':{ ar:'إضافة قيد فريد', en:'Add unique constraint' },
      'context.table.addIndex':{ ar:'إضافة فهرس', en:'Add index' },
      'context.table.generateFk':{ ar:'توليد علاقة خارجية', en:'Generate foreign key' },
      'context.table.exportSql':{ ar:'تصدير هذا الجدول (SQL)', en:'Export this table (SQL)' },
      'context.table.exportJson':{ ar:'تصدير هذا الجدول (JSON)', en:'Export this table (JSON)' },
      'context.table.show':{ ar:'إظهار في المشهد', en:'Show on canvas' },
      'context.table.hide':{ ar:'إخفاء في المشهد', en:'Hide from canvas' },
      'context.field.rename':{ ar:'إعادة تسمية الحقل', en:'Rename field' },
      'context.field.type':{ ar:'تغيير نوع الحقل', en:'Change field type' },
      'context.field.length':{ ar:'ضبط الطول/الدقة', en:'Adjust length/precision' },
      'context.field.properties':{ ar:'الخصائص', en:'Properties' },
      'context.field.pk.add':{ ar:'تعيين كمفتاح أساسي', en:'Set as primary key' },
      'context.field.pk.remove':{ ar:'إلغاء المفتاح الأساسي', en:'Remove primary key' },
      'context.field.null.allow':{ ar:'السماح بالقيم الفارغة', en:'Allow null values' },
      'context.field.null.disallow':{ ar:'فرض Not Null', en:'Enforce not null' },
      'context.field.unique.add':{ ar:'إضافة إلى القيد الفريد', en:'Add to unique constraint' },
      'context.field.unique.remove':{ ar:'إزالة من القيد الفريد', en:'Remove from unique constraint' },
      'context.field.index.add':{ ar:'إضافة إلى الفهرس', en:'Add to index' },
      'context.field.index.remove':{ ar:'إزالة من الفهرس', en:'Remove from index' },
      'context.field.relationships':{ ar:'العلاقات', en:'Relationships' },
      'context.field.createFk':{ ar:'إنشاء علاقة خارجية من هذا الحقل', en:'Create FK from this field' }
    };

    const X6_CDN_SOURCES = [
      'https://unpkg.com/@antv/x6@1.35.3/dist/x6.js',
      'https://cdn.jsdelivr.net/npm/@antv/x6@1.35.3/dist/x6.js'
    ];

    function loadScriptOnce(url){
      return new Promise((resolve, reject)=>{
        if(typeof document === 'undefined'){
          reject(new Error('document unavailable'));
          return;
        }
        const existing = document.querySelector(`script[data-mishkah-loader="${url}"]`);
        if(existing){
          if(existing.getAttribute('data-loaded') === 'true'){
            resolve();
            return;
          }
          existing.addEventListener('load', ()=> resolve(), { once:true });
          existing.addEventListener('error', ()=> reject(new Error(`Failed to load script: ${url}`)), { once:true });
          return;
        }
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.setAttribute('data-mishkah-loader', url);
        script.addEventListener('load', ()=>{
          script.setAttribute('data-loaded', 'true');
          resolve();
        }, { once:true });
        script.addEventListener('error', ()=>{
          script.remove();
          reject(new Error(`Failed to load script: ${url}`));
        }, { once:true });
        document.head.appendChild(script);
      });
    }

    async function ensureX6Library(){
      if(typeof window === 'undefined') return false;
      if(window.X6?.Graph) return true;
      if(window.__mishkahX6Loading){
        try { await window.__mishkahX6Loading; }
        catch(error){ console.warn('[Mishkah][ERD] X6 preload failed', error); }
        return !!(window.X6?.Graph);
      }
      window.__mishkahX6Loading = (async ()=>{
        for(const url of X6_CDN_SOURCES){
          try {
            await loadScriptOnce(url);
            if(window.X6?.Graph) return true;
          } catch(error){
            console.warn('[Mishkah][ERD] failed to load X6 source', url, error);
          }
        }
        return !!(window.X6?.Graph);
      })();
      try {
        const ready = await window.__mishkahX6Loading;
        return ready;
      } catch(error){
        console.warn('[Mishkah][ERD] X6 loader encountered an error', error);
        return !!(window.X6?.Graph);
      }
    }

    const x6Available = await ensureX6Library();
    const initialGraphDriver = x6Available ? 'x6' : 'fake';
    if(!x6Available){
      console.warn('[Mishkah][ERD] AntV X6 library is not available, diagram will use fallback driver.');
    }

    let erdAppInstance = null;
    let erdDriver = null;
    let activeDriverName = null;
    let activeDriverHost = null;
    let pendingDiagramFrame = false;
    let lastDiagramState = null;
    let applyingAutoZoom = false;

    function applyAutoZoom(targetZoom){
      if(!erdAppInstance) return;
      const zoom = Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, Number(targetZoom) || 1));
      if(applyingAutoZoom) return;
      const state = erdAppInstance.getState();
      const currentZoom = state?.data?.canvas?.zoom || 1;
      if(Math.abs(currentZoom - zoom) < 0.01) return;
      applyingAutoZoom = true;
      try {
        erdAppInstance.setState(s => ({
          ...s,
          data:{
            ...s.data,
            canvas:{ ...(s.data.canvas || {}), zoom, mode:'auto' },
          },
        }));
        erdAppInstance.flush();
      } finally {
        applyingAutoZoom = false;
      }
    }

    const TABLE_WIDTH = 280;
    const HEADER_HEIGHT = 48;
    const ROW_HEIGHT = 28;
    const AUTO_LAYOUT_ORIGIN_X = 240;
    const AUTO_LAYOUT_ORIGIN_Y = 200;
    const AUTO_LAYOUT_COLUMN_GAP = TABLE_WIDTH + 520;
    const AUTO_LAYOUT_ROW_GAP = HEADER_HEIGHT + ROW_HEIGHT * 14;
    const FALLBACK_NODE_SPACING_X = AUTO_LAYOUT_COLUMN_GAP;
    const FALLBACK_NODE_SPACING_Y = AUTO_LAYOUT_ROW_GAP + ROW_HEIGHT * 6;
    const RTL_TEXT_PADDING = 28;
    const MIN_CANVAS_ZOOM = 0.2;
    const MAX_CANVAS_ZOOM = 3;

    function computeTableHeight(fieldCount){
      const rows = Math.max(1, Number(fieldCount) || 0);
      return Math.max(HEADER_HEIGHT + rows * ROW_HEIGHT, HEADER_HEIGHT + ROW_HEIGHT);
    }

    function createAutoLayoutFallbackMap(tables){
      const fallback = {};
      const list = Array.isArray(tables) ? tables.filter(tbl => tbl && tbl.name) : [];
      if(!list.length) return fallback;

      const metaByName = new Map();
      list.forEach(table => {
        const nameKey = String(table.name);
        const idKey = table?.id != null ? String(table.id) : '';
        const fields = Array.isArray(table?.fields) ? table.fields : [];
        metaByName.set(nameKey, {
          table,
          name: nameKey,
          idKey,
          fields,
          height: computeTableHeight(fields.length),
        });
      });

      const adjacency = new Map();
      const directed = new Map();

      function ensureNode(name){
        if(!adjacency.has(name)) adjacency.set(name, new Set());
        if(!directed.has(name)) directed.set(name, new Set());
      }

      const names = Array.from(metaByName.keys());
      names.forEach(ensureNode);

      names.forEach(name => {
        const meta = metaByName.get(name);
        const fields = meta?.fields || [];
        fields.forEach(field => {
          const ref = field && field.references;
          if(!ref || !ref.table) return;
          const target = String(ref.table);
          if(!metaByName.has(target)) return;
          ensureNode(target);
          directed.get(name).add(target);
          adjacency.get(name).add(target);
          adjacency.get(target).add(name);
        });
      });

      const components = [];
      const visited = new Set();
      names.forEach(name => {
        if(visited.has(name)) return;
        const stack = [name];
        const component = [];
        visited.add(name);
        while(stack.length){
          const current = stack.pop();
          component.push(current);
          const neighbors = adjacency.get(current);
          if(neighbors && neighbors.size){
            neighbors.forEach(next => {
              if(!visited.has(next)){
                visited.add(next);
                stack.push(next);
              }
            });
          }
        }
        components.push(component);
      });

      function layoutAsGrid(componentNames, origin){
        const placements = new Map();
        const originX = origin.originX;
        const originY = origin.originY;
        const columnCount = Math.max(1, Math.ceil(Math.sqrt(Math.max(1, componentNames.length))));
        const columnHeights = new Array(columnCount).fill(originY);
        const sortedNames = componentNames.slice().sort((a, b) => {
          const metaA = metaByName.get(a);
          const metaB = metaByName.get(b);
          const heightDiff = (metaB?.height || 0) - (metaA?.height || 0);
          if(heightDiff !== 0) return heightDiff;
          return String(a).localeCompare(String(b));
        });
        sortedNames.forEach(name => {
          const meta = metaByName.get(name);
          if(!meta) return;
          let targetColumn = 0;
          let minHeight = columnHeights[0];
          for(let col = 1; col < columnCount; col += 1){
            if(columnHeights[col] < minHeight){
              minHeight = columnHeights[col];
              targetColumn = col;
            }
          }
          const x = originX + targetColumn * AUTO_LAYOUT_COLUMN_GAP;
          const y = columnHeights[targetColumn];
          placements.set(name, { x, y });
          columnHeights[targetColumn] = y + meta.height + AUTO_LAYOUT_ROW_GAP;
        });
        const width = Math.max(TABLE_WIDTH, (columnCount - 1) * AUTO_LAYOUT_COLUMN_GAP + TABLE_WIDTH);
        const height = Math.max(...columnHeights.map(total => total - originY), computeTableHeight(0));
        return { placements, width, height };
      }

      function layoutWithRelations(componentNames, origin){
        const placements = new Map();
        const originX = origin.originX;
        const originY = origin.originY;
        const outgoing = new Map();
        const indegree = new Map();
        componentNames.forEach(name => {
          outgoing.set(name, new Set());
          indegree.set(name, 0);
        });
        componentNames.forEach(name => {
          const edges = directed.get(name) || new Set();
          edges.forEach(target => {
            if(!outgoing.has(target)) return;
            outgoing.get(name).add(target);
          });
        });
        componentNames.forEach(name => {
          outgoing.get(name).forEach(target => {
            indegree.set(target, (indegree.get(target) || 0) + 1);
          });
        });
        const queue = [];
        const layers = new Map();
        componentNames.forEach(name => {
          if((indegree.get(name) || 0) === 0){
            queue.push(name);
            layers.set(name, 0);
          }
        });
        const seen = new Set(queue);
        while(queue.length){
          const name = queue.shift();
          const layer = layers.get(name) || 0;
          (outgoing.get(name) || new Set()).forEach(target => {
            const nextLayer = layer + 1;
            if(!layers.has(target) || nextLayer > layers.get(target)){
              layers.set(target, nextLayer);
            }
            const nextDegree = (indegree.get(target) || 0) - 1;
            indegree.set(target, nextDegree);
            if(nextDegree <= 0 && !seen.has(target)){
              queue.push(target);
              seen.add(target);
            }
          });
        }
        let maxLayer = 0;
        layers.forEach(value => { if(value > maxLayer) maxLayer = value; });
        const unassigned = componentNames.filter(name => !layers.has(name));
        unassigned.forEach(name => {
          const neighbors = adjacency.get(name);
          let baseLayer = maxLayer + 1;
          if(neighbors && neighbors.size){
            let sum = 0;
            let count = 0;
            neighbors.forEach(neighbor => {
              if(layers.has(neighbor)){
                sum += layers.get(neighbor);
                count += 1;
              }
            });
            if(count > 0){
              baseLayer = Math.round(sum / count);
            }
          }
          layers.set(name, baseLayer);
          if(baseLayer > maxLayer) maxLayer = baseLayer;
        });
        if(!layers.size){
          return layoutAsGrid(componentNames, origin);
        }
        const distinctLayers = Array.from(new Set(Array.from(layers.values()).sort((a, b) => a - b)));
        const layerToColumn = new Map();
        distinctLayers.forEach((layer, index) => layerToColumn.set(layer, index));
        const columns = new Map();
        layers.forEach((layer, name) => {
          const columnIndex = layerToColumn.get(layer);
          if(!columns.has(columnIndex)) columns.set(columnIndex, []);
          columns.get(columnIndex).push(name);
        });
        let componentHeight = 0;
        const sortedColumns = Array.from(columns.keys()).sort((a, b) => a - b);
        sortedColumns.forEach(columnIndex => {
          const namesInColumn = columns.get(columnIndex) || [];
          namesInColumn.sort((a, b) => {
            const degreeA = adjacency.get(a)?.size || 0;
            const degreeB = adjacency.get(b)?.size || 0;
            if(degreeA !== degreeB) return degreeB - degreeA;
            const heightDiff = (metaByName.get(b)?.height || 0) - (metaByName.get(a)?.height || 0);
            if(heightDiff !== 0) return heightDiff;
            return String(a).localeCompare(String(b));
          });
          const x = originX + columnIndex * AUTO_LAYOUT_COLUMN_GAP;
          let y = originY;
          namesInColumn.forEach(name => {
            const meta = metaByName.get(name);
            if(!meta) return;
            placements.set(name, { x, y });
            y += meta.height + AUTO_LAYOUT_ROW_GAP;
          });
          componentHeight = Math.max(componentHeight, y - originY);
        });
        const width = Math.max(TABLE_WIDTH, (sortedColumns.length - 1) * AUTO_LAYOUT_COLUMN_GAP + TABLE_WIDTH);
        const height = componentHeight || computeTableHeight(0);
        return { placements, width, height };
      }

      const maxPerRow = Math.max(1, Math.ceil(Math.sqrt(Math.max(1, components.length))));
      let originX = AUTO_LAYOUT_ORIGIN_X;
      let originY = AUTO_LAYOUT_ORIGIN_Y;
      let rowHeight = 0;

      components
        .sort((a, b) => b.length - a.length)
        .forEach((component, index) => {
          const hasRelations = component.some(name => (directed.get(name) || new Set()).size > 0);
          const result = hasRelations
            ? layoutWithRelations(component, { originX, originY })
            : layoutAsGrid(component, { originX, originY });
          result.placements.forEach((point, name) => {
            const meta = metaByName.get(name);
            if(!meta) return;
            if(meta.idKey) fallback[meta.idKey] = point;
            fallback[meta.name] = point;
          });
          originX += result.width + AUTO_LAYOUT_COLUMN_GAP;
          rowHeight = Math.max(rowHeight, result.height || 0);
          if((index + 1) % maxPerRow === 0){
            originX = AUTO_LAYOUT_ORIGIN_X;
            originY += rowHeight + AUTO_LAYOUT_ROW_GAP;
            rowHeight = 0;
          }
        });

      return fallback;
    }

    function createRectIndex({ cellWidth = AUTO_LAYOUT_COLUMN_GAP, cellHeight = AUTO_LAYOUT_ROW_GAP, padding = 32 } = {}){
      const buckets = new Map();
      const padX = Math.max(0, Number(padding) || 0);
      const padY = padX;
      function expandedRect(rect){
        return {
          x: rect.x - padX / 2,
          y: rect.y - padY / 2,
          width: rect.width + padX,
          height: rect.height + padY,
        };
      }
      function cellKey(col, row){
        return `${col}:${row}`;
      }
      function eachCell(rect, callback){
        const area = expandedRect(rect);
        const minCol = Math.floor(area.x / cellWidth);
        const maxCol = Math.floor((area.x + area.width) / cellWidth);
        const minRow = Math.floor(area.y / cellHeight);
        const maxRow = Math.floor((area.y + area.height) / cellHeight);
        for(let row = minRow; row <= maxRow; row += 1){
          for(let col = minCol; col <= maxCol; col += 1){
            callback(col, row, cellKey(col, row));
          }
        }
      }
      return {
        insert(rect){
          eachCell(rect, (_col, _row, key)=>{
            if(!buckets.has(key)) buckets.set(key, []);
            buckets.get(key).push(rect);
          });
        },
        collides(rect){
          let hit = false;
          eachCell(rect, (_col, _row, key)=>{
            if(hit) return;
            const list = buckets.get(key);
            if(!list) return;
            for(let idx = 0; idx < list.length; idx += 1){
              if(rectsOverlap(rect, list[idx])){
                hit = true;
                break;
              }
            }
          });
          return hit;
        }
      };
    }

    function rectsOverlap(a, b){
      if(!a || !b) return false;
      const aRight = a.x + a.width;
      const bRight = b.x + b.width;
      const aBottom = a.y + a.height;
      const bBottom = b.y + b.height;
      if(aRight <= b.x) return false;
      if(bRight <= a.x) return false;
      if(aBottom <= b.y) return false;
      if(bBottom <= a.y) return false;
      return true;
    }

    function claimRect(preferred, fallback, index, options = {}){
      const rectIndex = index || createRectIndex({ padding: options.padding });
      const width = Math.max(1, Number(options.width) || TABLE_WIDTH);
      const height = Math.max(1, Number(options.height) || AUTO_LAYOUT_ROW_GAP);
      const stepX = Math.max(16, Number(options.stepX) || AUTO_LAYOUT_COLUMN_GAP);
      const stepY = Math.max(16, Number(options.stepY) || AUTO_LAYOUT_ROW_GAP);
      const safeFallback = fallback || { x: AUTO_LAYOUT_ORIGIN_X, y: AUTO_LAYOUT_ORIGIN_Y };
      const origin = normalisePoint(safeFallback, safeFallback);

      function rounded(point){
        return { x: Math.round(point.x), y: Math.round(point.y) };
      }

      function makeRect(point){
        const roundedPoint = rounded(point);
        return { x: roundedPoint.x, y: roundedPoint.y, width, height };
      }

      function tryPlace(point){
        const rect = makeRect(point);
        if(rectIndex.collides(rect)) return false;
        rectIndex.insert(rect);
        return true;
      }

      const initial = normalisePoint(preferred, origin);
      if(tryPlace(initial)){
        return rounded(initial);
      }

      const seen = new Set();
      const candidates = [];
      const addCandidate = (point)=>{
        const roundedPoint = rounded(point);
        const key = `${roundedPoint.x}:${roundedPoint.y}`;
        if(seen.has(key)) return;
        seen.add(key);
        candidates.push(roundedPoint);
      };

      addCandidate(initial);
      addCandidate(origin);

      const maxRadius = 48;
      for(let radius = 1; radius <= maxRadius; radius += 1){
        const offsetX = stepX * radius;
        const offsetY = stepY * radius;
        addCandidate({ x: origin.x + offsetX, y: origin.y });
        addCandidate({ x: origin.x, y: origin.y + offsetY });
        addCandidate({ x: origin.x - offsetX, y: origin.y });
        addCandidate({ x: origin.x, y: origin.y - offsetY });
        addCandidate({ x: origin.x + offsetX, y: origin.y + offsetY });
        addCandidate({ x: origin.x - offsetX, y: origin.y + offsetY });
        addCandidate({ x: origin.x + offsetX, y: origin.y - offsetY });
        addCandidate({ x: origin.x - offsetX, y: origin.y - offsetY });
      }

      for(let idx = 0; idx < candidates.length; idx += 1){
        const candidate = candidates[idx];
        if(tryPlace(candidate)){
          return candidate;
        }
      }

      return rounded(initial);
    }

    function normalisePoint(point, fallback){
      if(point && Number.isFinite(Number(point.x)) && Number.isFinite(Number(point.y))){
        return { x: Number(point.x), y: Number(point.y) };
      }
      return { x: fallback.x, y: fallback.y };
    }

    function normaliseClasses(input){
      if(!Array.isArray(input)) return [];
      const seen = new Set();
      const out = [];
      input.forEach(item => {
        if(!item) return;
        const rawCode = item.code != null ? String(item.code).trim() : '';
        const code = rawCode.replace(/\s+/g, '');
        if(!code || code.length % 2 !== 0) return;
        const name = item.name != null ? String(item.name).trim() : '';
        const parentRaw = item.parent != null && item.parent !== '' ? String(item.parent).trim() : null;
        const parent = parentRaw ? parentRaw.replace(/\s+/g, '') : null;
        if(parent && parent.length % 2 !== 0) return;
        if(code === parent) return;
        if(seen.has(code)) return;
        seen.add(code);
        out.push({ code, name, parent });
      });
      out.sort((a, b) => a.code.localeCompare(b.code, undefined, { numeric:true }));
      return out;
    }

    function classesByParent(classes){
      const map = new Map();
      classes.forEach(item => {
        if(!item || !item.code) return;
        const parent = item.parent || null;
        if(!map.has(parent)) map.set(parent, []);
        map.get(parent).push(item);
      });
      return map;
    }

    function computeClassLeaves(classes){
      const byParent = classesByParent(classes);
      return classes.filter(item => {
        const children = byParent.get(item.code);
        return !children || children.length === 0;
      });
    }

    function classDepth(code){
      if(!code) return 0;
      return Math.max(0, Math.floor(code.length / 2));
    }

    function commitClasses(ctx, nextClasses, options = {}){
      const normalized = normaliseClasses(nextClasses);
      let nextState = null;
      ctx.setState(s => {
        const now = Date.now();
        const classificationForm = s.ui?.form?.classification || {};
        const tableForm = s.ui?.form?.table || {};
        const leafCodes = new Set(computeClassLeaves(normalized).map(item => item.code));
        const tableClassCode = tableForm.classCode && leafCodes.has(tableForm.classCode)
          ? tableForm.classCode
          : '';
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: s.data.schema,
          layout: s.data.layout,
          canvas: s.data.canvas,
          classes: normalized,
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now
        };
        const rows = normalized.map(item => ({ ...item }));
        const draft = {
          ...s,
          data:{
            ...s.data,
            classes: normalized,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
          },
          ui:{
            ...(s.ui || {}),
            modals:{ ...(s.ui?.modals || {}), classification: options.closeModal ? false : (s.ui?.modals?.classification || false) },
            form:{
              ...(s.ui?.form || {}),
              classification:{ rows, bulkText: normalized.length ? JSON.stringify(normalized, null, 2) : '' },
              table:{ ...(tableForm || {}), classCode: tableClassCode }
            }
          }
        };
        nextState = draft;
        return draft;
      });
      
      if(nextState){
        schedulePersist(recordFromState(nextState));
      }
      return nextState;
    }

    function computeLayoutBounds(nodes){
      if(!Array.isArray(nodes) || !nodes.length){
        return { width: 0, height: 0, minX: 0, minY: 0, maxX: 0, maxY: 0 };
      }
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      nodes.forEach(node => {
        const x = Number(node.x) || 0;
        const y = Number(node.y) || 0;
        const width = Number(node.width) || 0;
        const height = Number(node.height) || 0;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + width);
        maxY = Math.max(maxY, y + height);
      });
      return { minX, minY, maxX, maxY, width: Math.max(0, maxX - minX), height: Math.max(0, maxY - minY) };
    }

    function recommendZoomForBounds(bounds, viewportWidth, viewportHeight){
      if(!bounds || bounds.width <= 0 || bounds.height <= 0){
        return 1;
      }
      const width = Math.max(1, viewportWidth || 0);
      const height = Math.max(1, viewportHeight || 0);
      const paddedWidth = bounds.width + AUTO_LAYOUT_COLUMN_GAP;
      const paddedHeight = bounds.height + AUTO_LAYOUT_ROW_GAP;
      const scaleX = width ? width / paddedWidth : 1;
      const scaleY = height ? height / paddedHeight : 1;
      const zoom = Math.min(1, scaleX, scaleY);
      return Math.max(MIN_CANVAS_ZOOM, Number.isFinite(zoom) ? zoom : 1);
    }

    function normaliseCanvas(canvas){
      const source = canvas || {};
      const rawZoom = Number(source.zoom);
      const zoom = Number.isFinite(rawZoom) ? Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, rawZoom)) : 1;
      const mode = source.mode === 'manual' ? 'manual' : 'auto';
      return { ...source, zoom, mode };
    }

    function layoutsDiffer(current, computed){
      const currentMap = current || {};
      const computedMap = computed || {};
      const currentKeys = Object.keys(currentMap);
      const computedKeys = Object.keys(computedMap);
      if(currentKeys.length !== computedKeys.length) return true;
      return computedKeys.some(key => {
        const a = currentMap[key];
        const b = computedMap[key];
        if(!a || !b) return true;
        return Number(a.x) !== Number(b.x) || Number(a.y) !== Number(b.y);
      });
    }

    const FIELD_TYPE_OPTIONS = [
      { value:'string', label:'String (varchar)' },
      { value:'text', label:'Text' },
      { value:'integer', label:'Integer' },
      { value:'number', label:'Numeric (precision/scale)' },
      { value:'decimal', label:'Decimal' },
      { value:'float', label:'Float / double precision' },
      { value:'boolean', label:'Boolean' },
      { value:'date', label:'Date' },
      { value:'datetime', label:'Datetime' },
      { value:'timestamp', label:'Timestamp with timezone' },
      { value:'json', label:'JSONB' },
      { value:'uuid', label:'UUID' }
    ];

    const RELATION_ACTION_OPTIONS = ['CASCADE','RESTRICT','SET NULL','NO ACTION'];
    const INDEX_METHOD_OPTIONS = ['btree','hash','gist','gin'];

    const clone = (U.JSON && U.JSON.clone) ? U.JSON.clone : (obj => JSON.parse(JSON.stringify(obj)));

    const FIELD_BADGE_MAP = {
      pk: '⦿',
      fk: '↗',
      uk: '☆',
      nullable: '∅',
      index: '#'
    };

    function truncateText(value, maxLength){
      const text = String(value ?? '').trim();
      if(!text) return '';
      const limit = Math.max(4, Number(maxLength) || 32);
      if(text.length <= limit) return text;
      return `${text.slice(0, limit - 1)}…`;
    }

    function fieldBadges(field){
      const badges = [];
      if(field.pk) badges.push(FIELD_BADGE_MAP.pk);
      if(field.unique && !field.pk) badges.push(FIELD_BADGE_MAP.uk);
      if(field.references) badges.push(FIELD_BADGE_MAP.fk);
      if(field.index && !field.unique && !field.pk) badges.push(FIELD_BADGE_MAP.index);
      if(field.nullable) badges.push(FIELD_BADGE_MAP.nullable);
      return badges.join(' ');
    }

    function buildFieldDisplay(field){
      const badges = fieldBadges(field);
      const label = truncateText(field.name || '', 22);
      const type = truncateText(field.type || '', 18);
      return {
        badges,
        label,
        type
      };
    }

    function buildColumnsFormRows(table){
      if(!table || !Array.isArray(table.fields)) return [];
      return table.fields.map(field => ({
        key: field.name,
        originalName: field.name,
        name: field.name,
        type: field.type || 'string',
        length: field.maxLength != null ? String(field.maxLength) : '',
        precision: field.precision != null ? String(field.precision) : '',
        scale: field.scale != null ? String(field.scale) : '',
        nullable: field.nullable !== false,
        defaultValue: field.defaultValue != null ? String(field.defaultValue) : '',
        primaryKey: !!field.primaryKey,
        unique: !!field.unique,
        index: !!field.index,
        references: field.references ? {
          table: field.references.table || '',
          column: field.references.column || '',
          onDelete: field.references.onDelete || 'CASCADE',
          onUpdate: field.references.onUpdate || 'CASCADE'
        } : { table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
      }));
    }

    function createBlankColumnRow(table){
      const baseIndex = (table?.fields?.length || 0) + 1;
      const baseName = `column_${baseIndex}`;
      const uniqueName = table ? ensureUniqueFieldName(table, baseName) : baseName;
      const key = `${uniqueName}_${Date.now()}`;
      return {
        key,
        originalName:'',
        name: uniqueName,
        type:'string',
        length: typeSupportsLength('string') ? defaultLengthForType('string') : '',
        precision:'',
        scale:'',
        nullable:true,
        defaultValue:'',
        primaryKey:false,
        unique:false,
        index:false,
        references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
      };
    }

    function typesAreCompatible(localType, foreignType){
      if(!localType || !foreignType) return false;
      const normalize = value => String(value || '').toLowerCase();
      const compatMap = {
        integer:['integer','number','decimal','bigint','smallint'],
        number:['number','integer','decimal','float','double'],
        decimal:['decimal','number','integer','float','double'],
        float:['float','number','decimal','double'],
        double:['double','float','number','decimal'],
        bigint:['bigint','integer','number'],
        uuid:['uuid','string','text'],
        string:['string','text','uuid','varchar','char'],
        text:['text','string'],
        boolean:['boolean'],
        date:['date','timestamp','timestamptz'],
        timestamp:['timestamp','timestamptz','date'],
        timestamptz:['timestamptz','timestamp','date']
      };
      const local = normalize(localType);
      const foreign = normalize(foreignType);
      const allowed = compatMap[local] || [local];
      return allowed.includes(foreign);
    }

    function findDefaultReferenceColumn(table, localType){
      if(!table || !Array.isArray(table.fields)) return null;
      const compatible = table.fields.filter(field => typesAreCompatible(localType, field.type));
      if(!compatible.length) return null;
      const primary = compatible.find(field => field.primaryKey);
      return primary || compatible[0];
    }

    function getTableIndexes(table){
      if(!table) return [];
      return Array.isArray(table.indexes)
        ? table.indexes.filter(idx => idx && Array.isArray(idx.columns)).map(idx => Object.assign({}, idx))
        : [];
    }

    function ensureUniqueIndexName(table, baseName, currentName){
      const base = sanitizeSqlIdentifier(baseName || 'idx') || 'idx';
      const existing = new Set(getTableIndexes(table).map(idx => String(idx.name || '')).filter(Boolean));
      if(currentName) existing.delete(currentName);
      let candidate = base;
      let suffix = 2;
      while(existing.has(candidate)){
        candidate = `${base}_${suffix++}`;
      }
      return candidate;
    }

    function persistColumnsEditorState(ctx, registry, tableName, { toastTitle='', formOverrides={} }={}){
      const schemaJSON = registry.toJSON();
      let persistRecord = null;
      let nextState = null;
      ctx.setState(s=>{
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: schemaJSON,
          layout: s.data.layout,
          canvas: s.data.canvas,
          classes: s.data.classes || [],
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now
        };
        persistRecord = record;
        const refreshedTable = registry.get(tableName);
        const refreshedRows = buildColumnsFormRows(refreshedTable);
        const nextForm = Object.assign({}, s.ui?.form || {});
        nextForm.columns = { table: tableName, rows: refreshedRows, deleted: [] };
        Object.assign(nextForm, formOverrides || {});
        const draft = {
          ...s,
          data:{
            ...s.data,
            schema: schemaJSON,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
          },
          ui:{
            ...(s.ui || {}),
            modals:{ ...(s.ui?.modals || {}), columns:true, columnsUnique:false, columnsIndex:false },
            form: nextForm
          }
        };
        nextState = draft;
        return draft;
      });
      
      if(persistRecord) schedulePersist(recordFromState(nextState));
      if(toastTitle) UI.pushToast(ctx, { title: toastTitle, icon:'✅' });
    }

    function defaultLengthForType(type){
      if(type === 'string' || type === 'text') return '4000';
      return '';
    }

    function defaultPrecisionForType(type){
      if(type === 'decimal' || type === 'number') return { precision:'18', scale:'2' };
      return { precision:'', scale:'' };
    }

    function typeSupportsLength(type){
      return ['string', 'text'].includes(type);
    }

    function typeSupportsPrecision(type){
      return ['decimal', 'number'].includes(type);
    }

    class SvgDriver {
      constructor(){
        this.container = null;
        this.hooks = {};
        this.svg = null;
        this.viewport = null;
        this.wrapper = null;
        this.defs = null;
        this.lastState = null;
        this.baseBBox = null;
        this.overrideFitPadding = null;
        this.dragContext = null;
        this.nodeCache = new Map();
        this.edgeCache = new Map();
      }

      init(container, hooks){
        this.container = container;
        this.hooks = hooks || {};
        if(container) container.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'm-erd-svg-wrapper';
        Object.assign(wrapper.style, {
          position: 'relative',
          width: '100%',
          height: '100%',
          overflow: 'hidden'
        });
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.setAttribute('class', 'm-erd-svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        const defs = document.createElementNS(svgNS, 'defs');
        const marker = document.createElementNS(svgNS, 'marker');
        marker.setAttribute('id', 'm-erd-arrow');
        marker.setAttribute('viewBox', '0 0 12 12');
        marker.setAttribute('refX', '10');
        marker.setAttribute('refY', '6');
        marker.setAttribute('markerUnits', 'strokeWidth');
        marker.setAttribute('markerWidth', '8');
        marker.setAttribute('markerHeight', '8');
        marker.setAttribute('orient', 'auto');
        const markerPath = document.createElementNS(svgNS, 'path');
        markerPath.setAttribute('d', 'M 0 0 L 12 6 L 0 12 z');
        markerPath.setAttribute('fill', 'currentColor');
        marker.appendChild(markerPath);
        defs.appendChild(marker);
        svg.appendChild(defs);
        const viewport = document.createElementNS(svgNS, 'g');
        viewport.setAttribute('class', 'm-erd-viewport');
        svg.appendChild(viewport);
        wrapper.appendChild(svg);
        if(container) container.appendChild(wrapper);
        this.wrapper = wrapper;
        this.svg = svg;
        this.viewport = viewport;
        this.defs = defs;
        this.baseBBox = null;
        this.lastState = null;
        this.overrideFitPadding = null;
      }

      clear(){
        if(!this.viewport) return;
        while(this.viewport.firstChild){
          this.viewport.removeChild(this.viewport.firstChild);
        }
        this.nodeCache.clear();
        this.edgeCache.clear();
        this.edgeCache.clear();
      }

      clientPointToSvg(clientX, clientY){
        if(!this.svg) return null;
        const point = this.svg.createSVGPoint();
        point.x = clientX;
        point.y = clientY;
        const ctm = this.svg.getScreenCTM();
        if(!ctm) return null;
        const transformed = point.matrixTransform(ctm.inverse());
        return { x: transformed.x, y: transformed.y };
      }

      attachNodeInteractions(group, node){
        if(!group) return;
        group.style.cursor = 'move';
        group.style.touchAction = 'none';
        const handlePointerDown = event => {
          const appState = (erdAppInstance && typeof erdAppInstance.getState === 'function')
            ? erdAppInstance.getState()
            : null;
          if(appState && hasOpenModal(appState)) return;
          if(event.button && event.button !== 0) return;
          event.preventDefault();
          event.stopPropagation();
          const origin = this.clientPointToSvg(event.clientX, event.clientY);
          if(!origin) return;
          const pointerId = event.pointerId;
          if(group.setPointerCapture && pointerId != null){
            try { group.setPointerCapture(pointerId); }
            catch(_){}
          }
          this.dragContext = {
            node,
            group,
            pointerId,
            offsetX: origin.x - node.x,
            offsetY: origin.y - node.y,
          };
          const target = this.svg?.ownerDocument || document;
          target.addEventListener('pointermove', handlePointerMove);
          target.addEventListener('pointerup', handlePointerUp);
          target.addEventListener('pointercancel', handlePointerUp);
        };

        const handlePointerMove = event => {
          if(!this.dragContext || (event.pointerId != null && this.dragContext.pointerId != null && event.pointerId !== this.dragContext.pointerId)){
            return;
          }
          event.preventDefault();
          const point = this.clientPointToSvg(event.clientX, event.clientY);
          if(!point) return;
          const nextX = point.x - this.dragContext.offsetX;
          const nextY = point.y - this.dragContext.offsetY;
          this.dragContext.node.x = nextX;
          this.dragContext.node.y = nextY;
          this.dragContext.group.setAttribute('transform', `translate(${nextX} ${nextY})`);
          this.updateEdgePaths(this.dragContext.node.id);
        };

        const handlePointerUp = event => {
          if(!this.dragContext || (event.pointerId != null && this.dragContext.pointerId != null && event.pointerId !== this.dragContext.pointerId)){
            return;
          }
          const context = this.dragContext;
          this.dragContext = null;
          const target = this.svg?.ownerDocument || document;
          target.removeEventListener('pointermove', handlePointerMove);
          target.removeEventListener('pointerup', handlePointerUp);
          target.removeEventListener('pointercancel', handlePointerUp);
          if(context.group.releasePointerCapture && context.pointerId != null){
            try { context.group.releasePointerCapture(context.pointerId); }
            catch(_){}
          }
          const roundedX = Math.round(context.node.x);
          const roundedY = Math.round(context.node.y);
          context.group.setAttribute('transform', `translate(${roundedX} ${roundedY})`);
          context.node.x = roundedX;
          context.node.y = roundedY;
          this.hooks?.onNodeMove?.({ id: String(context.node.id), x: roundedX, y: roundedY });
          this.updateEdgePaths(context.node.id);
        };

        group.addEventListener('pointerdown', handlePointerDown);
      }

      computeBoundingBox(nodes){
        if(!nodes.length){
          return {
            minX: 0,
            minY: 0,
            maxX: 640,
            maxY: 480
          };
        }
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        nodes.forEach(node => {
          minX = Math.min(minX, node.x);
          minY = Math.min(minY, node.y);
          maxX = Math.max(maxX, node.x + node.width);
          maxY = Math.max(maxY, node.y + node.height);
        });
        return { minX, minY, maxX, maxY };
      }

      setViewBox(bbox, zoom, padding, mode = 'auto'){
        if(!this.svg) return;
        const baseWidth = Math.max(1, (bbox.maxX - bbox.minX));
        const baseHeight = Math.max(1, (bbox.maxY - bbox.minY));
        let pad = Math.max(24, padding != null ? padding : 120);
        let effectiveMode = mode || 'auto';
        const forcingFit = this.overrideFitPadding != null;
        if(forcingFit){
          pad = Math.max(24, this.overrideFitPadding);
          effectiveMode = 'auto';
          this.overrideFitPadding = null;
        }
        const safeZoom = (zoom && Number.isFinite(zoom))
          ? Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, zoom))
          : 1;
        const zoomValue = forcingFit ? 1 : safeZoom;
        const contentWidth = baseWidth + pad * 2;
        const contentHeight = baseHeight + pad * 2;
        if(effectiveMode === 'manual'){
          const translateX = pad - bbox.minX;
          const translateY = pad - bbox.minY;
          if(this.wrapper){
            this.wrapper.style.overflow = 'auto';
            this.wrapper.style.minWidth = `${contentWidth}px`;
            this.wrapper.style.minHeight = `${contentHeight}px`;
          }
          this.svg.setAttribute('viewBox', `0 0 ${contentWidth} ${contentHeight}`);
          this.svg.style.width = `${contentWidth * zoomValue}px`;
          this.svg.style.height = `${contentHeight * zoomValue}px`;
          this.svg.style.maxWidth = 'none';
          this.svg.style.maxHeight = 'none';
          if(this.viewport){
            this.viewport.setAttribute('transform', `translate(${translateX} ${translateY}) scale(${zoomValue})`);
          }
        } else {
          const centerX = bbox.minX + baseWidth / 2;
          const centerY = bbox.minY + baseHeight / 2;
          let viewWidth = contentWidth;
          let viewHeight = contentHeight;
          if(zoomValue !== 1){
            viewWidth = viewWidth / zoomValue;
            viewHeight = viewHeight / zoomValue;
          }
          const viewX = centerX - viewWidth / 2;
          const viewY = centerY - viewHeight / 2;
          if(this.wrapper){
            this.wrapper.style.overflow = 'hidden';
            this.wrapper.style.minWidth = '';
            this.wrapper.style.minHeight = '';
          }
          this.svg.setAttribute('viewBox', `${viewX} ${viewY} ${viewWidth} ${viewHeight}`);
          this.svg.style.width = '100%';
          this.svg.style.height = '100%';
          this.svg.style.maxWidth = '';
          this.svg.style.maxHeight = '';
          if(this.viewport){
            this.viewport.removeAttribute('transform');
          }
        }
        this.baseBBox = Object.assign({}, bbox, { pad });
      }

      focusNode(nodeId, options = {}){
        if(!nodeId) return;
        const container = this.container;
        if(!container) return;
        const state = this.lastState;
        if(!state) return;
        const tables = Array.isArray(state.tables) ? state.tables : [];
        if(!tables.length) return;
        const target = tables.find(tbl => String(tbl.id) === String(nodeId) || String(tbl.name) === String(nodeId));
        if(!target) return;
        const layout = state.layout || {};
        const fallbackPositions = createAutoLayoutFallbackMap(tables);
        const source = layout[target.id] || layout[target.name];
        const fallback = fallbackPositions[target.id] || fallbackPositions[target.name] || { x: AUTO_LAYOUT_ORIGIN_X, y: AUTO_LAYOUT_ORIGIN_Y };
        const position = normalisePoint(source, fallback);
        const fields = Array.isArray(target.fields) ? target.fields : [];
        let centerY = position.y + computeTableHeight(fields.length) / 2;
        if(options.field){
          const index = fields.findIndex(field => String(field?.name || '').toLowerCase() === String(options.field).toLowerCase());
          if(index >= 0){
            centerY = position.y + HEADER_HEIGHT + ROW_HEIGHT * index + ROW_HEIGHT / 2;
          }
        }
        const centerX = position.x + TABLE_WIDTH / 2;
        const targetLeft = Math.max(0, centerX - (container.clientWidth || 0) / 2);
        const targetTop = Math.max(0, centerY - (container.clientHeight || 0) / 2);
        if(typeof container.scrollTo === 'function'){
          try {
            container.scrollTo({ left: targetLeft, top: targetTop, behavior:'smooth' });
          } catch(_){
            container.scrollTo(targetLeft, targetTop);
          }
        } else {
          container.scrollLeft = targetLeft;
          container.scrollTop = targetTop;
        }
      }

      updateEdgePaths(nodeId){
        if(!nodeId || !this.edgeCache.size) return;
        this.edgeCache.forEach(meta => {
          if(meta.sourceNode !== nodeId && meta.targetNode !== nodeId) return;
          const geometry = this.computeEdgeGeometry(meta);
          if(!geometry) return;
          meta.path.setAttribute('d', geometry.path);
          if(meta.label){
            meta.label.setAttribute('x', String(geometry.labelX));
            meta.label.setAttribute('y', String(geometry.labelY));
          }
        });
      }

      computeEdgeGeometry(meta){
        if(!meta) return null;
        const sourceNode = this.nodeCache.get(meta.sourceNode);
        const targetNode = this.nodeCache.get(meta.targetNode);
        if(!sourceNode || !targetNode) return null;
        const sourceFieldY = sourceNode.fieldMap.get(meta.sourceField) || sourceNode.height / 2;
        const targetFieldY = targetNode.fieldMap.get(meta.targetField) || targetNode.height / 2;
        const sourceSide = meta.sourceSide === 'left' ? 'left' : 'right';
        const targetSide = meta.targetSide === 'right' ? 'right' : 'left';
        const startX = sourceSide === 'left' ? sourceNode.x : sourceNode.x + sourceNode.width;
        const endX = targetSide === 'right' ? targetNode.x + targetNode.width : targetNode.x;
        const startY = sourceNode.y + sourceFieldY;
        const endY = targetNode.y + targetFieldY;
        const margin = 36;
        const segments = [`M ${startX} ${startY}`];
        const forward = startX <= endX;
        if(forward){
          const exitX = sourceSide === 'left' ? sourceNode.x - margin : sourceNode.x + sourceNode.width + margin;
          const entryX = targetSide === 'right' ? targetNode.x + targetNode.width + margin : targetNode.x - margin;
          const midY = startY + (endY - startY) / 2;
          segments.push(`L ${exitX} ${startY}`);
          segments.push(`L ${exitX} ${midY}`);
          segments.push(`L ${entryX} ${midY}`);
          segments.push(`L ${entryX} ${endY}`);
        } else {
          const verticalDirection = endY >= startY ? 1 : -1;
          const exitY = verticalDirection > 0
            ? Math.max(startY + margin, sourceNode.y + sourceNode.height + margin)
            : Math.min(startY - margin, sourceNode.y - margin);
          const entryY = verticalDirection > 0
            ? Math.min(endY - margin, targetNode.y - margin)
            : Math.max(endY + margin, targetNode.y + targetNode.height + margin);
          const midX = startX + (endX - startX) / 2;
          segments.push(`L ${startX} ${exitY}`);
          segments.push(`L ${midX} ${exitY}`);
          segments.push(`L ${midX} ${entryY}`);
          segments.push(`L ${endX} ${entryY}`);
        }
        segments.push(`L ${endX} ${endY}`);
        const path = segments.join(' ');
        const labelX = (startX + endX) / 2;
        const labelY = (startY + endY) / 2 - 6;
        return { path, labelX, labelY };
      }

      render(state){
        if(!this.svg || !this.viewport) return;
        this.lastState = state;
        const tables = Array.isArray(state?.tables) ? state.tables : [];
        const relations = Array.isArray(state?.relations) ? state.relations : [];
        const layout = state?.layout || {};
        const selection = state?.selection || {};
        const palette = state?.palette || {};
        const zoom = state?.zoom;
        const canvasMode = state?.canvasMode || 'auto';
        const direction = (state?.direction || '').toLowerCase();
        const isRTL = direction === 'rtl';

        this.clear();
        console.debug('[Mishkah][ERD] SVG driver render', tables.length, 'tables');

        const svgNS = 'http://www.w3.org/2000/svg';
        if(this.defs && typeof this.defs.querySelectorAll === 'function'){
          const dynamicDefs = Array.from(this.defs.querySelectorAll('clipPath[data-m-erd-dynamic="true"]'));
          dynamicDefs.forEach(def => def.remove());
        }
        const fallbackPositions = createAutoLayoutFallbackMap(tables);
        const nodes = tables.map((table, index)=>{
          const source = layout[table.id] || layout[table.name];
          const fallback = fallbackPositions[table.id] || fallbackPositions[table.name] || {
            x: AUTO_LAYOUT_ORIGIN_X + index * FALLBACK_NODE_SPACING_X,
            y: AUTO_LAYOUT_ORIGIN_Y + index * FALLBACK_NODE_SPACING_Y,
          };
          const { x, y } = normalisePoint(source, fallback);
          const fields = Array.isArray(table.fields) ? table.fields : [];
          const width = TABLE_WIDTH;
          const height = computeTableHeight(fields.length);
          const fieldMap = new Map();
          fields.forEach((field, idx)=>{
            const centerY = HEADER_HEIGHT + ROW_HEIGHT * idx + ROW_HEIGHT / 2;
            fieldMap.set(field.name, centerY);
          });
          return {
            id: table.id,
            table,
            x,
            y,
            width,
            height,
            fields,
            fieldMap
          };
        });

        const bbox = this.computeBoundingBox(nodes);
        this.setViewBox(bbox, zoom, 120, canvasMode);

        const edgesGroup = document.createElementNS(svgNS, 'g');
        edgesGroup.setAttribute('class', 'm-erd-edges');
        const nodesGroup = document.createElementNS(svgNS, 'g');
        nodesGroup.setAttribute('class', 'm-erd-nodes');

        const colors = {
          tableStroke: palette.border || '#1f2a3d',
          tableFill: palette.card || '#111d30',
          headerFill: palette.primary || '#2563eb',
          headerText: palette.primaryForeground || '#f8fafc',
          headerSubtle: palette.primaryForeground ? `${palette.primaryForeground}cc` : '#e2e8f0cc',
          fieldText: palette.foreground || '#f8fafc',
          fieldType: palette.muted || '#94a3b8',
          rowEven: palette.surface || '#0f172a',
          rowOdd: palette.card || '#111d30',
          badge: palette.accentForeground || '#102341',
          edge: palette.accentForeground || '#60a5fa',
          background: palette.surface || '#101a2c'
        };

        const nodeLookup = new Map();

        this.nodeCache.clear();

        nodes.forEach(node => {
          nodeLookup.set(node.id, node);
          this.nodeCache.set(node.id, node);
          const group = document.createElementNS(svgNS, 'g');
          group.setAttribute('data-node-id', node.id);
          group.setAttribute('data-table-name', node.table?.name || node.id);
          group.setAttribute('transform', `translate(${node.x} ${node.y})`);

          const body = document.createElementNS(svgNS, 'rect');
          body.setAttribute('x', '0');
          body.setAttribute('y', '0');
          body.setAttribute('width', String(node.width));
          body.setAttribute('height', String(node.height));
          body.setAttribute('rx', '18');
          body.setAttribute('ry', '18');
          body.setAttribute('fill', colors.tableFill);
          body.setAttribute('stroke', selection.table === node.id ? (palette.primary || '#60a5fa') : colors.tableStroke);
          body.setAttribute('stroke-width', selection.table === node.id ? '2.6' : '1.8');

          const headerHeight = Math.max(HEADER_HEIGHT, 48);
          const header = document.createElementNS(svgNS, 'rect');
          header.setAttribute('x', '0');
          header.setAttribute('y', '0');
          header.setAttribute('width', String(node.width));
          header.setAttribute('height', String(headerHeight));
          header.setAttribute('rx', '18');
          header.setAttribute('ry', '18');
          header.setAttribute('fill', colors.headerFill);

          const headerClip = document.createElementNS(svgNS, 'clipPath');
          const clipId = `m-erd-clip-${String(node.id).replace(/[^a-zA-Z0-9_-]/g, '_')}`;
          if(this.defs){
            headerClip.setAttribute('id', clipId);
            headerClip.setAttribute('data-m-erd-dynamic', 'true');
            const clipRect = document.createElementNS(svgNS, 'rect');
            clipRect.setAttribute('x', '0');
            clipRect.setAttribute('y', '0');
            clipRect.setAttribute('width', String(node.width));
            clipRect.setAttribute('height', String(node.height));
            clipRect.setAttribute('rx', '18');
            clipRect.setAttribute('ry', '18');
            headerClip.appendChild(clipRect);
            this.defs.appendChild(headerClip);
          }

          const tableMeta = node.table || {};
          const title = document.createElementNS(svgNS, 'text');
          const headerX = isRTL ? node.width - RTL_TEXT_PADDING : RTL_TEXT_PADDING;
          title.setAttribute('x', String(headerX));
          title.setAttribute('y', '28');
          title.setAttribute('fill', colors.headerText);
          title.setAttribute('font-size', '14');
          title.setAttribute('font-weight', '700');
          title.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
          if(isRTL){
            title.setAttribute('text-anchor', 'start');
            title.setAttribute('style', 'direction: rtl; unicode-bidi: isolate;');
          } else {
            title.setAttribute('style', 'direction: ltr; unicode-bidi: isolate;');
          }
          title.textContent = truncateText(tableMeta.displayName || tableMeta.label || tableMeta.name || node.id, 26);
          title.setAttribute('clip-path', `url(#${clipId})`);

          let subtitleNode = null;
          if(tableMeta.label && tableMeta.label !== tableMeta.name){
            subtitleNode = document.createElementNS(svgNS, 'text');
            subtitleNode.setAttribute('x', String(headerX));
            subtitleNode.setAttribute('y', '44');
            subtitleNode.setAttribute('fill', colors.headerSubtle);
            subtitleNode.setAttribute('font-size', '11');
            subtitleNode.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            subtitleNode.setAttribute('clip-path', `url(#${clipId})`);
            if(isRTL){
              subtitleNode.setAttribute('text-anchor', 'start');
              subtitleNode.setAttribute('style', 'direction: rtl; unicode-bidi: isolate;');
            } else {
              subtitleNode.setAttribute('style', 'direction: ltr; unicode-bidi: isolate;');
            }
            subtitleNode.textContent = truncateText(tableMeta.label, 32);
          }

          const contentTop = headerHeight;
          const rowsGroup = document.createElementNS(svgNS, 'g');

          node.fields.forEach((field, idx)=>{
            const rowTop = contentTop + ROW_HEIGHT * idx;
            const rowRect = document.createElementNS(svgNS, 'rect');
            rowRect.setAttribute('x', '0');
            rowRect.setAttribute('y', String(rowTop));
            rowRect.setAttribute('width', String(node.width));
            rowRect.setAttribute('height', String(ROW_HEIGHT));
            rowRect.setAttribute('fill', idx % 2 === 0 ? colors.rowEven : colors.rowOdd);
            rowRect.setAttribute('data-field-name', field.name);
            rowRect.setAttribute('data-table-name', node.table?.name || node.id);

            const display = field.display || buildFieldDisplay(field);
            const baseY = rowTop + ROW_HEIGHT / 2 + 1;

            const nameText = document.createElementNS(svgNS, 'text');
            const rtlNamePadding = display.badges ? RTL_TEXT_PADDING + 16 : RTL_TEXT_PADDING;
            const ltrNamePadding = display.badges ? 40 : 20;
            const nameX = isRTL
              ? node.width - rtlNamePadding
              : ltrNamePadding;
            nameText.setAttribute('x', String(nameX));
            nameText.setAttribute('y', String(baseY));
            nameText.setAttribute('fill', colors.fieldText);
            nameText.setAttribute('font-size', '12');
            nameText.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            nameText.setAttribute('dominant-baseline', 'middle');
            nameText.setAttribute('font-weight', field.pk ? '700' : '500');
            nameText.setAttribute('data-field-name', field.name);
            nameText.setAttribute('data-table-name', node.table?.name || node.id);
            if(isRTL){
              nameText.setAttribute('text-anchor', 'start');
              nameText.setAttribute('style', 'direction: rtl; unicode-bidi: isolate;');
            } else {
              nameText.setAttribute('style', 'direction: ltr; unicode-bidi: isolate;');
            }
            nameText.textContent = display.label || field.name;

            if(display.badges){
              const badgeText = document.createElementNS(svgNS, 'text');
              const badgeX = isRTL ? node.width - RTL_TEXT_PADDING : RTL_TEXT_PADDING;
              badgeText.setAttribute('x', String(badgeX));
              badgeText.setAttribute('y', String(baseY));
              badgeText.setAttribute('fill', colors.badge);
              badgeText.setAttribute('font-size', '11');
              badgeText.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
              badgeText.setAttribute('dominant-baseline', 'middle');
              badgeText.setAttribute('data-field-name', field.name);
              badgeText.setAttribute('data-table-name', node.table?.name || node.id);
              if(isRTL){
                badgeText.setAttribute('text-anchor', 'start');
              }
              badgeText.setAttribute('style', 'direction: ltr; unicode-bidi: isolate;');
              badgeText.textContent = display.badges;
              rowsGroup.appendChild(badgeText);
            }

            const typeText = document.createElementNS(svgNS, 'text');
            const typeX = isRTL ? RTL_TEXT_PADDING : (node.width - RTL_TEXT_PADDING);
            typeText.setAttribute('x', String(typeX));
            typeText.setAttribute('y', String(baseY));
            typeText.setAttribute('fill', colors.fieldType);
            typeText.setAttribute('font-size', '11');
            typeText.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            typeText.setAttribute('dominant-baseline', 'middle');
            typeText.setAttribute('data-field-name', field.name);
            typeText.setAttribute('data-table-name', node.table?.name || node.id);
            typeText.setAttribute('text-anchor', isRTL ? 'start' : 'end');
            typeText.setAttribute('style', isRTL ? 'direction: ltr; unicode-bidi: isolate;' : 'direction: ltr; unicode-bidi: isolate;');
            typeText.textContent = display.type || field.type || '';

            rowsGroup.appendChild(rowRect);
            rowsGroup.appendChild(nameText);
            rowsGroup.appendChild(typeText);
          });

          group.appendChild(body);
          group.appendChild(header);
          group.appendChild(title);
          if(subtitleNode) group.appendChild(subtitleNode);
          group.appendChild(rowsGroup);
          this.attachNodeInteractions(group, node);
          nodesGroup.appendChild(group);
        });

        relations.forEach(rel => {
          const sourceNode = nodeLookup.get(rel.from?.table || rel.source?.table || '');
          const targetNode = nodeLookup.get(rel.to?.table || rel.target?.table || '');
          if(!sourceNode || !targetNode) return;
          const sourceFieldName = rel.from?.field || rel.source?.field;
          const targetFieldName = rel.to?.field || rel.target?.field;
          const edgeId = rel.id || `${sourceNode.id}:${sourceFieldName}→${targetNode.id}:${targetFieldName}`;
          const meta = {
            id: edgeId,
            path: null,
            label: null,
            sourceNode: sourceNode.id,
            targetNode: targetNode.id,
            sourceField: sourceFieldName,
            targetField: targetFieldName,
            sourceSide: rel.from?.side || (rel.from?.port?.endsWith(':left') ? 'left' : 'right'),
            targetSide: rel.to?.side || (rel.to?.port?.endsWith(':right') ? 'right' : 'left')
          };
          const geometry = this.computeEdgeGeometry(meta);
          const path = document.createElementNS(svgNS, 'path');
          path.setAttribute('d', geometry ? geometry.path : `M ${sourceNode.x} ${sourceNode.y} L ${targetNode.x} ${targetNode.y}`);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', colors.edge);
          path.setAttribute('stroke-width', '1.8');
          path.setAttribute('marker-end', 'url(#m-erd-arrow)');
          path.setAttribute('style', `color:${colors.edge}`);
          path.setAttribute('data-edge-id', edgeId);
          edgesGroup.appendChild(path);

          if(rel.cardinality){
            const label = document.createElementNS(svgNS, 'text');
            const labelX = geometry ? geometry.labelX : (sourceNode.x + targetNode.x) / 2;
            const labelY = geometry ? geometry.labelY : (sourceNode.y + targetNode.y) / 2 - 6;
            label.setAttribute('x', String(labelX));
            label.setAttribute('y', String(labelY));
            label.setAttribute('fill', colors.fieldText);
            label.setAttribute('font-size', '11');
            label.setAttribute('font-weight', '600');
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-family', '"Cairo", "Tajawal", system-ui, sans-serif');
            label.textContent = rel.cardinality;
            edgesGroup.appendChild(label);
            meta.label = label;
          } else {
            meta.label = null;
          }
          meta.path = path;
          this.edgeCache.set(edgeId, meta);
        });

        this.viewport.appendChild(edgesGroup);
        this.viewport.appendChild(nodesGroup);
      }

      fitToScreen(padding = 16){
        this.overrideFitPadding = padding;
        if(this.lastState){
          this.render(this.lastState);
        }
      }

      undo(){}
      redo(){}

      async exportSVG(){
        if(!this.svg) return '<svg />';
        const serializer = new XMLSerializer();
        return serializer.serializeToString(this.svg);
      }

      async exportPNG(opts = {}){
        if(!this.svg) return new Blob();
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(this.svg);
        const svgBlob = new Blob([svgString], { type:'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);
        try {
          const image = new Image();
          const width = opts.width || this.wrapper?.clientWidth || 1600;
          const height = opts.height || this.wrapper?.clientHeight || 900;
          await new Promise((resolve, reject)=>{
            image.onload = resolve;
            image.onerror = reject;
            image.src = url;
          });
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          if(opts.background){
            ctx.fillStyle = opts.background;
            ctx.fillRect(0, 0, width, height);
          }
          ctx.drawImage(image, 0, 0, width, height);
          const blob = await new Promise((resolve, reject)=>{
            canvas.toBlob(result => {
              if(result) resolve(result);
              else reject(new Error('Failed to export PNG'));
            });
          });
          return blob;
        } finally {
          URL.revokeObjectURL(url);
        }
      }

      destroy(){
        if(this.container) this.container.innerHTML = '';
        this.container = null;
        this.svg = null;
        this.viewport = null;
        this.wrapper = null;
        this.defs = null;
        this.lastState = null;
        this.baseBBox = null;
        this.overrideFitPadding = null;
        this.nodeCache.clear();
        this.edgeCache.clear();
      }
    }

    class X6Driver {
      constructor(){
        this.graph = null;
        this.hooks = null;
        this.initialized = false;
        this.container = null;
      }

      init(container, hooks){
        this.hooks = hooks || {};
        this.container = container;
        const Graph = window?.X6?.Graph;
        if(!Graph){
          console.warn('[Mishkah][ERD] AntV X6 Graph not available, falling back to FakeDriver');
          throw new Error('X6 not available');
        }
        this.graph = new Graph({
          container,
          grid: true,
          scroller: { enabled: true, pannable: true, minScale: MIN_CANVAS_ZOOM, maxScale: MAX_CANVAS_ZOOM },
          mousewheel: { enabled: true, modifiers: ['ctrl','meta'], minScale: MIN_CANVAS_ZOOM, maxScale: MAX_CANVAS_ZOOM },
          history: { enabled: true },
          selecting: { enabled: true, multiple: true, rubberband: true },
          keyboard: { enabled: true },
          clipboard: { enabled: true },
          snapline: { enabled: true },
          connecting: {
            allowBlank: false,
            allowLoop: false,
            snap: true,
            router: { name: 'manhattan' },
            connector: { name: 'rounded' },
            validateConnection: ({ sourceMagnet, targetMagnet }) => !!(sourceMagnet && targetMagnet),
          },
        });

        this.graph.on('node:change:position', ({ node }) => {
          const { x, y } = node.getPosition();
          this.hooks?.onNodeMove?.({ id: String(node.id), x, y });
        });

        this.graph.on('selection:changed', ({ selected }) => {
          if(!selected) return;
          const ids = selected
            .filter(cell => cell && typeof cell.isNode === 'function' && cell.isNode())
            .map(cell => String(cell.id));
          this.hooks?.onSelect?.(ids);
        });

        this.graph.on('edge:connected', ({ edge, isNew }) => {
          if(!edge) return;
          const meta = edge.getData ? edge.getData() : null;
          if(meta?.hydrated){
            edge.setData({ ...meta, hydrated: false });
            return;
          }
          if(isNew === false) return;
          const source = edge.getSource();
          const target = edge.getTarget();
          if(!source || !target) return;
          this.hooks?.onEdgeConnect?.({
            source: { id: String(source.cell), port: String(source.port) },
            target: { id: String(target.cell), port: String(target.port) },
          });
        });
      }

      render(state){
        if(!this.graph) return;
        const layout = state?.layout || {};
        const tables = Array.isArray(state?.tables) ? state.tables : [];
        const relations = Array.isArray(state?.relations) ? state.relations : [];
        const fallbackPositions = createAutoLayoutFallbackMap(tables);
        const nodes = tables.map((tbl, index) => {
          const fallback = fallbackPositions[tbl.id] || fallbackPositions[tbl.name] || {
            x: AUTO_LAYOUT_ORIGIN_X + index * FALLBACK_NODE_SPACING_X,
            y: AUTO_LAYOUT_ORIGIN_Y + index * FALLBACK_NODE_SPACING_Y,
          };
          const { x, y } = normalisePoint(layout[tbl.id] || layout[tbl.name], fallback);
          const position = { x, y };
          const fields = Array.isArray(tbl.fields) ? tbl.fields : [];
          const headerLabel = tbl.displayName || tbl.label || tbl.name || tbl.id;
          const subtitle = tbl.label && tbl.label !== tbl.name ? ` (${tbl.label})` : '';
          const headerLine = truncateText(`${headerLabel}${subtitle}`, 42);
          const fieldLines = fields.map(field => {
            const display = field.display || buildFieldDisplay(field);
            const badges = display.badges ? `${display.badges} ` : '';
            const type = display.type ? ` · ${display.type}` : '';
            return `${badges}${display.label || field.name}${type}`;
          });
          const bodyText = [headerLine, ...fieldLines].join('\n');
          const height = computeTableHeight(fields.length);
          const portItems = fields.flatMap((field, idx) => {
            const yOffset = HEADER_HEIGHT + ROW_HEIGHT * idx + ROW_HEIGHT / 2;
            const portBase = `${tbl.id}:${field.name}`;
            return [
              {
                id: `${portBase}:left`,
                group: 'in',
                attrs: {
                  circle: {
                    title: `${field.name}${field.type ? ` (${field.type})` : ''}`,
                  },
                },
                args: { x: 0, y: yOffset },
              },
              {
                id: `${portBase}:right`,
                group: 'out',
                attrs: {
                  circle: {
                    title: `${field.name}${field.type ? ` (${field.type})` : ''}`,
                  },
                },
                args: { x: TABLE_WIDTH, y: yOffset },
              },
            ];
          });
          return {
            id: tbl.id,
            shape: 'rect',
            x: position.x,
            y: position.y,
            width: TABLE_WIDTH,
            height,
            data: { hydrated: true },
            attrs: {
              body: {
                fill: '#111d30',
                stroke: '#1f2a3d',
                rx: 18,
                ry: 18,
              },
              label: {
                text: bodyText,
                fill: '#f8fafc',
                fontSize: 12,
                fontWeight: 500,
                lineHeight: 1.35,
                textAnchor: 'start',
                refX: 16,
                refY: 22,
                textWrap: {
                  width: TABLE_WIDTH - 32,
                  height: height - 32,
                  ellipsis: true,
                  breakWord: true,
                },
              },
            },
            ports: {
              groups: {
                in: {
                  position: { name: 'absolute' },
                  attrs: { circle: { r: 4, magnet: true, stroke: 'transparent', fill: 'transparent' } },
                },
                out: {
                  position: { name: 'absolute' },
                  attrs: { circle: { r: 4, magnet: true, stroke: 'transparent', fill: 'transparent' } },
                },
              },
              items: portItems,
            },
          };
        });

        const edges = relations.map(rel => ({
          id: rel.id || `${rel.from.table}:${rel.from.field}→${rel.to.table}:${rel.to.field}`,
          shape: 'edge',
          source: { cell: rel.from.table, port: rel.from.port || `${rel.from.table}:${rel.from.field}:right` },
          target: { cell: rel.to.table, port: rel.to.port || `${rel.to.table}:${rel.to.field}:left` },
          router: { name: 'manhattan' },
          connector: { name: 'rounded' },
          attrs: { line: { stroke: '#0284c7', strokeWidth: 1.6 } },
          labels: rel.cardinality || rel.onDelete || rel.onUpdate ? [
            {
              attrs: {
                label: {
                  text: rel.cardinality || '1..*',
                  fill: '#0f172a',
                  background: {
                    fill: '#f8fafc',
                    stroke: '#94a3b8',
                    padding: 2,
                  },
                },
              },
            },
          ] : [],
          data: { hydrated: true },
        }));

        this.graph.fromJSON({ cells: [...nodes, ...edges] });

        const selection = state?.selection;
        if(selection?.table){
          const node = this.graph.getCellById(selection.table);
          if(node){
            this.graph.resetSelection(node);
          }
        }

        if(typeof state?.zoom === 'number' && Number.isFinite(state.zoom)){
          const safeZoom = Math.max(MIN_CANVAS_ZOOM, Math.min(MAX_CANVAS_ZOOM, state.zoom));
          try { this.graph.zoomTo(safeZoom); }
          catch(error){ console.warn('[Mishkah][ERD] zoomTo failed', error); }
        }

        if(state?.canvasMode !== 'manual'){
          try { this.graph.centerContent(); }
          catch(error){ console.warn('[Mishkah][ERD] centerContent failed', error); }
        }

        if(!this.initialized){
          this.initialized = true;
        }
      }

      focusNode(nodeId, options = {}){
        if(!this.graph || nodeId == null) return;
        const id = String(nodeId);
        const cell = this.graph.getCellById(id);
        if(!cell) return;
        try {
          if(this.graph.scroller && typeof this.graph.scroller.center === 'function'){
            this.graph.scroller.center(cell, { animation:{ duration:200 } });
          } else if(typeof this.graph.centerCell === 'function'){
            this.graph.centerCell(cell);
          } else if(typeof this.graph.scrollIntoView === 'function'){
            this.graph.scrollIntoView(cell, { animation:{ duration:200 } });
          } else if(typeof this.graph.centerContent === 'function'){
            this.graph.centerContent();
          }
          if(options.field && typeof this.graph.select === 'function'){
            this.graph.select(cell);
          }
        } catch(error){
          console.warn('[Mishkah][ERD] focusNode (X6) failed', error);
        }
      }

      fitToScreen(padding = 16){
        if(!this.graph) return;
        this.graph.scaleContentToFit({ padding });
      }

      undo(){
        if(!this.graph) return;
        this.graph.history?.undo();
      }

      redo(){
        if(!this.graph) return;
        this.graph.history?.redo();
      }

      async exportSVG(){
        if(!this.graph) return '<svg />';
        return this.graph.toSVG({ preserveDimensions: true });
      }

      async exportPNG(opts = {}){
        if(!this.graph) return new Blob();
        const dataUrl = await this.graph.toPNG({
          backgroundColor: opts.background || '#ffffff',
          padding: 16,
          quality: 1,
        });
        const response = await fetch(dataUrl);
        return await response.blob();
      }

      destroy(){
        if(this.graph){
          this.graph.dispose();
          this.graph = null;
        }
        this.container = null;
      }
    }

    const DiagramDrivers = {
      fake: SvgDriver,
      x6: X6Driver,
    };

    function sanitizeSqlIdentifier(value){
      if(!value) return '';
      const snake = Schema.utils.toSnakeCase(value || '') || '';
      return snake
        .replace(/[^a-z0-9_]/g, '')
        .replace(/_{2,}/g, '_')
        .replace(/^_+|_+$/g, '')
        .slice(0, 64);
    }

    function identifierFromLabel(label, fallback){
      const sanitized = sanitizeSqlIdentifier(label || '');
      if(sanitized) return sanitized;
      if(Text && typeof Text.identifierFromArabic === 'function'){
        const derived = sanitizeSqlIdentifier(Text.identifierFromArabic(label, { fallback }));
        if(derived) return derived;
      }
      const fallbackBase = sanitizeSqlIdentifier(fallback || 'item');
      return fallbackBase || (fallback || 'item');
    }

    function formatIdentifier(value){
      if(!value) return '';
      return value
        .replace(/_/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/(^|\s)([a-z])/g, (_, space, ch)=> space + ch.toUpperCase());
    }

    function ensureUniqueTableName(registry, base){
      const clean = base || 'table';
      let candidate = clean;
      let index = 1;
      while(registry.get(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function ensureUniqueFieldName(table, base){
      const clean = base || 'field';
      if(!table) return clean;
      let candidate = clean;
      let index = 1;
      while(table.getField(candidate)){
        candidate = `${clean}_${index++}`;
      }
      return candidate;
    }

    function computeTableIdentifier(registry, source){
      const fallback = `table_${registry.list().length + 1}`;
      const base = sanitizeSqlIdentifier(source || '') || identifierFromLabel(source, fallback);
      return ensureUniqueTableName(registry, base);
    }

    function computeFieldIdentifier(table, label){
      const fallback = `field_${(table?.fields?.length || 0) + 1}`;
      const base = identifierFromLabel(label, fallback);
      return ensureUniqueFieldName(table, base);
    }

    function currentPalette(){
      if(typeof window === 'undefined') return {};
      const computed = getComputedStyle(document.documentElement);
      const read = key => (computed.getPropertyValue(key) || '').trim();
      return {
        background: read('--background') || '#f8fafc',
        surface: read('--surface-2') || '#eef2ff',
        border: read('--border') || '#d7deed',
        foreground: read('--foreground') || '#0f172a',
        muted: read('--muted-foreground') || '#475569',
        accent: read('--accent') || '#eaf2ff',
        accentForeground: read('--accent-foreground') || '#102341',
        primary: read('--primary') || '#2563eb',
        primaryForeground: read('--primary-foreground') || '#f8fafc'
      };
    }

    function buildDriverStateSnapshot(state, host){
      const registry = getRegistry(state);
      const layout = computeLayout(registry, state.data.layout);
      const hiddenTables = new Set((state.ui?.hiddenTables || []).map(name => String(name)));
      const direction = (state.env?.dir || (typeof document !== 'undefined' ? document.documentElement.getAttribute('dir') : '') || 'ltr').toLowerCase();
      const tables = registry.list()
        .filter(table => !hiddenTables.has(table.name))
        .map(table => ({
          id: table.name,
          name: table.name,
          label: table.label || '',
          displayName: formatIdentifier(table.name),
          fields: (table.fields || []).map(field => ({
          name: field.name,
          type: field.type,
          pk: !!field.primaryKey,
          unique: !!field.unique,
          nullable: field.nullable !== false,
          default: field.defaultValue,
          references: field.references || null,
          index: !!field.index,
          display: buildFieldDisplay({
            name: field.name,
            type: field.type,
            pk: !!field.primaryKey,
            unique: !!field.unique,
            nullable: field.nullable !== false,
            references: field.references,
            index: !!field.index
          }),
        })),
      }));
      const relations = [];
      registry.list().forEach(table => {
        (table.fields || []).forEach(field => {
          if(field.references && field.references.table){
            relations.push({
              id: `${table.name}:${field.name}→${field.references.table}:${field.references.column || field.references.field || 'id'}`,
              from: {
                table: table.name,
                field: field.name,
                port: `${table.name}:${field.name}:right`,
                side: 'right'
              },
              to: {
                table: field.references.table,
                field: field.references.column || field.references.field || 'id',
                port: `${field.references.table}:${field.references.column || field.references.field || 'id'}:left`,
                side: 'left'
              },
              cardinality: field.references.cardinality || '',
              onDelete: field.references.onDelete,
              onUpdate: field.references.onUpdate,
            });
          }
        });
      });
      const fallbackPositions = createAutoLayoutFallbackMap(tables);
      const nodesMeta = tables.map((table, index) => {
        const fallback = fallbackPositions[table.id] || fallbackPositions[table.name] || {
          x: AUTO_LAYOUT_ORIGIN_X + index * FALLBACK_NODE_SPACING_X,
          y: AUTO_LAYOUT_ORIGIN_Y + index * FALLBACK_NODE_SPACING_Y,
        };
        const point = layout[table.id] || layout[table.name];
        const { x, y } = normalisePoint(point, fallback);
        return {
          id: table.id,
          x,
          y,
          width: TABLE_WIDTH,
          height: computeTableHeight(table.fields.length),
        };
      });
      const bounds = computeLayoutBounds(nodesMeta);
      const canvasState = normaliseCanvas(state.data.canvas);
      const canvasMode = canvasState.mode || 'auto';
      const storedZoom = canvasState.zoom || 1;
      let zoom = storedZoom;
      if(canvasMode !== 'manual'){
        const viewportWidth = host?.clientWidth || (typeof window !== 'undefined' ? window.innerWidth : 0);
        const viewportHeight = host?.clientHeight || (typeof window !== 'undefined' ? window.innerHeight : 0);
        zoom = recommendZoomForBounds(bounds, viewportWidth, viewportHeight);
      }
      return {
        tables,
        relations,
        layout,
        selection: state.data.selection || {},
        zoom,
        canvasMode,
        storedZoom,
        bounds,
        direction,
        hidden: Array.from(hiddenTables),
      };
    }

    function scheduleDiagramRender(state){
      lastDiagramState = state;
      if(pendingDiagramFrame) return;
      pendingDiagramFrame = true;
      requestAnimationFrame(()=>{
        pendingDiagramFrame = false;
        const snapshot = erdAppInstance ? erdAppInstance.getState() : lastDiagramState;
        if(snapshot) renderDiagram(snapshot);
      });
    }

    function closeContextMenu(){
      if(!erdAppInstance) return;
      erdAppInstance.setState(s => ({
        ...s,
        ui:{
          ...(s.ui || {}),
          contextMenu:{ open:false, x:0, y:0, type:'canvas', table:'', field:'' }
        }
      }));
      erdAppInstance.flush();
    }

    function openContextMenu(payload){
      if(!erdAppInstance || !payload) return;
      const { clientX = 0, clientY = 0, type = 'canvas', table = '', field = '' } = payload;
      const clampedX = Math.max(0, clientX);
      const clampedY = Math.max(0, clientY);
      erdAppInstance.setState(s => ({
        ...s,
        ui:{
          ...(s.ui || {}),
          contextMenu:{
            open:true,
            x: clampedX,
            y: clampedY,
            type,
            table,
            field
          }
        }
      }));
      erdAppInstance.flush();
    }

    function ensureContextMenuHandlers(host){
      if(!host) return;
      const root = host.parentElement || host;
      if(root.__mishkahContextMenuAttached) return;
      const openFromEvent = event => {
        if(!erdAppInstance) return;
        if(event){
          if(typeof event.preventDefault === 'function') event.preventDefault();
          if(typeof event.stopPropagation === 'function') event.stopPropagation();
        }
        const target = event?.target;
        if(target && typeof root.contains === 'function' && !root.contains(target)) return;
        const hostRect = typeof host.getBoundingClientRect === 'function' ? host.getBoundingClientRect() : null;
        const fallbackX = hostRect ? hostRect.left + hostRect.width / 2 : (typeof window !== 'undefined' ? window.innerWidth / 2 : 0);
        const fallbackY = hostRect ? hostRect.top + hostRect.height / 2 : (typeof window !== 'undefined' ? window.innerHeight / 2 : 0);
        const pointX = typeof event?.clientX === 'number' ? event.clientX : fallbackX;
        const pointY = typeof event?.clientY === 'number' ? event.clientY : fallbackY;
        root.__mishkahLastContextOpen = Date.now();
        if(!target || typeof target.closest !== 'function'){
          openContextMenu({
            clientX: pointX,
            clientY: pointY,
            type:'canvas'
          });
          return;
        }
        const fieldElement = target.closest('[data-field-name]');
        if(fieldElement){
          openContextMenu({
            clientX: pointX,
            clientY: pointY,
            type:'field',
            field: fieldElement.getAttribute('data-field-name') || '',
            table: fieldElement.getAttribute('data-table-name') || (fieldElement.closest('[data-table-name]')?.getAttribute('data-table-name') || '')
          });
          return;
        }
        const tableElement = target.closest('[data-table-name]');
        if(tableElement){
          openContextMenu({
            clientX: pointX,
            clientY: pointY,
            type:'table',
            table: tableElement.getAttribute('data-table-name') || tableElement.getAttribute('data-node-id') || ''
          });
          return;
        }
        openContextMenu({
          clientX: pointX,
          clientY: pointY,
          type:'canvas'
        });
      };
      const handlePointerDown = event => {
        if(!event) return;
        const isRightClick = event.button === 2 || (event.button === 0 && event.ctrlKey);
        if(!isRightClick) return;
        openFromEvent(event);
      };
      const handleContextMenu = event => {
        if(event){
          if(typeof event.preventDefault === 'function') event.preventDefault();
          if(typeof event.stopPropagation === 'function') event.stopPropagation();
          if(typeof event.stopImmediatePropagation === 'function') event.stopImmediatePropagation();
          try { event.returnValue = false; }
          catch(error) { /* ignore */ }
        }
        const now = Date.now();
        const lastOpen = root.__mishkahLastContextOpen || 0;
        if(now - lastOpen < 150){
          return;
        }
        openFromEvent(event);
      };
      const options = { capture:true, passive:false };
      root.addEventListener('pointerdown', handlePointerDown, options);
      root.addEventListener('contextmenu', handleContextMenu, options);
      const ownerDocument = root.ownerDocument || host.ownerDocument || document;
      if(ownerDocument){
        if(!root.__mishkahContextMenuDocGuard){
          const guard = event => {
            if(!event) return;
            const target = event.target;
            if(target && typeof root.contains === 'function' && !root.contains(target) && target !== root){
              return;
            }
            if(typeof root.isConnected === 'boolean' && !root.isConnected){
              if(root.__mishkahContextMenuDocGuard?.document){
                try {
                  root.__mishkahContextMenuDocGuard.document.removeEventListener('contextmenu', guard, true);
                } catch(error){ /* ignore */ }
              }
              root.__mishkahContextMenuDocGuard = null;
              return;
            }
            if(typeof event.preventDefault === 'function') event.preventDefault();
            if(typeof event.stopPropagation === 'function') event.stopPropagation();
            if(typeof event.stopImmediatePropagation === 'function') event.stopImmediatePropagation();
            try { event.returnValue = false; }
            catch(error) { /* ignore */ }
            const now = Date.now();
            const lastOpen = root.__mishkahLastContextOpen || 0;
            if(now - lastOpen < 120){
              return;
            }
            openFromEvent(event);
          };
          ownerDocument.addEventListener('contextmenu', guard, true);
          root.__mishkahContextMenuDocGuard = { handler: guard, document: ownerDocument };
        }
        if(!ownerDocument.__mishkahContextMenuKeybound){
          const handleKeyDown = event => {
            if(event.key === 'Escape' || event.key === 'Esc'){
              closeContextMenu();
            }
          };
          ownerDocument.addEventListener('keydown', handleKeyDown);
          ownerDocument.__mishkahContextMenuKeybound = true;
        }
      }
      root.__mishkahContextMenuAttached = true;
    }

    function ensureCanvasPointerHandlers(host){
      if(!host || host.__mishkahPointerHandlersAttached) return;
      const supportsPointerEvents = typeof window !== 'undefined' && 'PointerEvent' in window;
      const supportsTouchEvents = !supportsPointerEvents && typeof window !== 'undefined' && ('ontouchstart' in window);
      const ownerDocument = host.ownerDocument || (typeof document !== 'undefined' ? document : null);
      const passiveFalse = { passive:false };

      const getEventPoint = (event, pointerId)=>{
        if(!event) return null;
        if(event.pointerId != null && (pointerId == null || pointerId === event.pointerId)){
          return { x:event.clientX, y:event.clientY, pointerId:event.pointerId };
        }
        const touchLists = [event.touches, event.changedTouches];
        for(let i=0;i<touchLists.length;i++){
          const list = touchLists[i];
          if(!list || typeof list.length !== 'number') continue;
          for(let j=0;j<list.length;j++){
            const touch = list[j];
            const id = touch && touch.identifier != null ? touch.identifier : null;
            if(pointerId == null || pointerId === id){
              if(typeof touch.clientX === 'number' && typeof touch.clientY === 'number'){
                return { x:touch.clientX, y:touch.clientY, pointerId:id };
              }
            }
          }
        }
        if(typeof event.clientX === 'number' && typeof event.clientY === 'number'){
          return { x:event.clientX, y:event.clientY, pointerId:pointerId != null ? pointerId : null };
        }
        return null;
      };

      const detectPointerType = event => {
        if(!event) return '';
        if(typeof event.pointerType === 'string') return event.pointerType;
        if(event.type && event.type.indexOf('mouse') === 0) return 'mouse';
        if(event.type && event.type.indexOf('touch') === 0) return 'touch';
        return '';
      };

      const attachFallbackListeners = pointerType => {
        if(supportsPointerEvents || !ownerDocument) return;
        const type = pointerType === 'touch' ? 'touch' : 'mouse';
        host.__mishkahActivePanDoc = ownerDocument;
        host.__mishkahActivePanType = type;
        if(type === 'touch'){
          ownerDocument.addEventListener('touchmove', movePan, passiveFalse);
          ownerDocument.addEventListener('touchend', endPan, passiveFalse);
          ownerDocument.addEventListener('touchcancel', endPan, passiveFalse);
        } else {
          ownerDocument.addEventListener('mousemove', movePan, passiveFalse);
          ownerDocument.addEventListener('mouseup', endPan, passiveFalse);
        }
      };

      const detachFallbackListeners = () => {
        if(supportsPointerEvents) return;
        const doc = host.__mishkahActivePanDoc;
        if(!doc) return;
        const type = host.__mishkahActivePanType === 'touch' ? 'touch' : 'mouse';
        if(type === 'touch'){
          doc.removeEventListener('touchmove', movePan, passiveFalse);
          doc.removeEventListener('touchend', endPan, passiveFalse);
          doc.removeEventListener('touchcancel', endPan, passiveFalse);
        } else {
          doc.removeEventListener('mousemove', movePan, passiveFalse);
          doc.removeEventListener('mouseup', endPan, passiveFalse);
        }
        host.__mishkahActivePanDoc = null;
        host.__mishkahActivePanType = null;
      };

      const assignPanState = (pointer) => {
        if(!pointer) return;
        const state = {
          pointerId: pointer.pointerId,
          pointerType: pointer.pointerType || '',
          x: pointer.x,
          y: pointer.y,
          scrollLeft: host.scrollLeft,
          scrollTop: host.scrollTop,
          moved:false
        };
        host.__mishkahPanState = state;
        host.__mishkahPanPendingToken = null;
        if(supportsPointerEvents && typeof host.setPointerCapture === 'function' && pointer.pointerId != null){
          try { host.setPointerCapture(pointer.pointerId); }
          catch(error){ /* noop */ }
        }
        if(!supportsPointerEvents) attachFallbackListeners(pointer.pointerType);
      };

      const startPan = event => {
        if(!event) return;
        if(host.__mishkahPanState) return;
        const appState = (erdAppInstance && typeof erdAppInstance.getState === 'function')
          ? erdAppInstance.getState()
          : null;
        if(appState && hasOpenModal(appState)) return;
        const pointerType = detectPointerType(event);
        if(pointerType === 'mouse'){
          if(event.button !== 0) return;
          if(typeof event.buttons === 'number' && event.buttons !== 1) return;
        }
        const point = getEventPoint(event);
        if(!point) return;
        const pointer = {
          pointerId: point.pointerId != null ? point.pointerId : (event.pointerId != null ? event.pointerId : null),
          pointerType,
          x: point.x,
          y: point.y
        };
        if(pointer.pointerType === 'touch' && typeof event.preventDefault === 'function'){
          event.preventDefault();
        }
        let switchedToManual = false;
        if(appState){
          const canvasState = appState?.data?.canvas || {};
          if(canvasState.mode !== 'manual'){
            const currentZoom = typeof canvasState.zoom === 'number' ? canvasState.zoom : 1;
            switchedToManual = true;
            erdAppInstance.setState(s => ({
              ...s,
              data:{
                ...s.data,
                canvas:{ ...(s.data.canvas || {}), mode:'manual', zoom: currentZoom },
              },
            }));
            erdAppInstance.flush();
          }
        }
        if(switchedToManual){
          const token = Symbol('pan');
          host.__mishkahPanPendingToken = token;
          requestAnimationFrame(() => {
            if(host.__mishkahPanPendingToken !== token) return;
            assignPanState(pointer);
          });
        } else {
          assignPanState(pointer);
        }
      };

      const movePan = event => {
        const state = host.__mishkahPanState;
        if(!state) return;
        if(state.pointerId != null && event.pointerId != null && state.pointerId !== event.pointerId) return;
        const point = getEventPoint(event, state.pointerId);
        if(!point) return;
        const dx = point.x - state.x;
        const dy = point.y - state.y;
        const threshold = 3;
        if(!state.moved){
          if(Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
          state.moved = true;
          host.setAttribute('data-panning', 'true');
        }
        host.scrollLeft = state.scrollLeft - dx;
        host.scrollTop = state.scrollTop - dy;
        if(typeof event.preventDefault === 'function') event.preventDefault();
      };

      const endPan = event => {
        const state = host.__mishkahPanState;
        if(!state) return;
        if(state.pointerId != null){
          if(event && event.pointerId != null && state.pointerId !== event.pointerId) return;
          if(event && event.changedTouches && event.changedTouches.length){
            let matched = false;
            for(let i=0;i<event.changedTouches.length;i++){
              const touch = event.changedTouches[i];
              if(touch && touch.identifier === state.pointerId){
                matched = true;
                break;
              }
            }
            if(!matched){
              const touches = event.touches;
              if(touches && touches.length){
                for(let j=0;j<touches.length;j++){
                  if(touches[j] && touches[j].identifier === state.pointerId){
                    return;
                  }
                }
              }
            }
          }
        }
        if(event){
          const type = event.type || '';
          if(supportsPointerEvents && (type === 'pointerout' || type === 'pointerleave')){
            if(typeof event.buttons === 'number' && event.buttons !== 0) return;
          }
          if(!supportsPointerEvents && state.pointerType === 'mouse' && (type === 'mouseout' || type === 'mouseleave')){
            if(typeof event.buttons === 'number' && event.buttons !== 0) return;
          }
        }
        host.__mishkahPanPendingToken = null;
        if(supportsPointerEvents && state && typeof host.releasePointerCapture === 'function' && state.pointerId != null){
          try { host.releasePointerCapture(state.pointerId); }
          catch(error){ /* noop */ }
        }
        host.__mishkahPanState = null;
        host.removeAttribute('data-panning');
        if(!supportsPointerEvents) detachFallbackListeners();
        if(state.moved && event && typeof event.preventDefault === 'function'){
          event.preventDefault();
        }
      };

      if(supportsPointerEvents){
        host.addEventListener('pointerdown', startPan);
        host.addEventListener('pointermove', movePan);
        host.addEventListener('pointerup', endPan);
        host.addEventListener('pointerleave', endPan);
        host.addEventListener('pointercancel', endPan);
        host.addEventListener('pointerout', endPan);
      } else {
        host.addEventListener('mousedown', startPan);
        host.addEventListener('mousemove', movePan);
        host.addEventListener('mouseup', endPan);
        host.addEventListener('mouseleave', endPan);
        host.addEventListener('mouseout', endPan);
        if(supportsTouchEvents){
          host.addEventListener('touchstart', startPan, passiveFalse);
          host.addEventListener('touchmove', movePan, passiveFalse);
          host.addEventListener('touchend', endPan, passiveFalse);
          host.addEventListener('touchcancel', endPan, passiveFalse);
        }
      }
      host.__mishkahPointerHandlersAttached = true;
    }

    function ensureDriverInstance(state){
      if(typeof window === 'undefined') return null;
      const host = document.getElementById('erd-diagram');
      if(!host) return null;
      ensureContextMenuHandlers(host);
      ensureCanvasPointerHandlers(host);
      const requestedDriver = (state?.env?.graph?.driver || 'fake').toLowerCase();
      const driverKey = requestedDriver === 'x6' && !(window?.X6?.Graph) ? 'fake' : requestedDriver;
      if(erdDriver && activeDriverName === driverKey){
        if(activeDriverHost && activeDriverHost !== host){
          try { erdDriver.destroy(); }
          catch(error){ console.warn('[Mishkah][ERD] driver destroy failed', error); }
          erdDriver = null;
          activeDriverHost = null;
        } else {
          return erdDriver;
        }
      }
      if(erdDriver){
        try { erdDriver.destroy(); }
        catch(error){ console.warn('[Mishkah][ERD] driver destroy failed', error); }
        erdDriver = null;
        activeDriverHost = null;
      }
      const DriverCtor = DiagramDrivers[driverKey] || DiagramDrivers.fake;
      try {
        const instance = new DriverCtor();
        instance.init(host, {
          onNodeMove: handleDriverNodeMove,
          onSelect: handleDriverSelect,
          onEdgeConnect: handleDriverEdgeConnect,
        });
        erdDriver = instance;
        activeDriverName = driverKey;
        activeDriverHost = host;
        host.setAttribute('data-driver', driverKey);
        return erdDriver;
      } catch(error){
        console.warn('[Mishkah][ERD] failed to initialise driver', driverKey, error);
        if(driverKey !== 'fake'){
          try {
            const fallback = new SvgDriver();
            fallback.init(host, {
              onNodeMove: handleDriverNodeMove,
              onSelect: handleDriverSelect,
              onEdgeConnect: handleDriverEdgeConnect,
            });
            erdDriver = fallback;
            activeDriverName = 'fake';
            activeDriverHost = host;
            host.setAttribute('data-driver', 'fake');
            return erdDriver;
          } catch(fallbackError){
            console.error('[Mishkah][ERD] failed to initialise FakeDriver', fallbackError);
          }
        }
        return null;
      }
    }

    function renderDiagram(state){
      if(!state || typeof window === 'undefined') return;
      const host = document.getElementById('erd-diagram');
      if(!host) return;
      const driver = ensureDriverInstance(state);
      if(!driver) return;
      const payload = buildDriverStateSnapshot(state, host);
      if(layoutsDiffer(state.data.layout, payload.layout)){
        erdAppInstance.setState(s => ({
          ...s,
          data:{
            ...s.data,
            layout: payload.layout,
          },
        }));
        erdAppInstance.flush();
      }
      const palette = currentPalette();
      payload.palette = palette;
      host.style.background = palette.background || '#f8fafc';
      if(payload.canvasMode !== 'manual' && Math.abs(payload.zoom - (payload.storedZoom || 0)) > 0.01){
        applyAutoZoom(payload.zoom);
      }
      try {
        driver.render(payload);
      } catch(error){
        console.warn('[Mishkah][ERD] driver render failed', error);
      }
    }

    function extractFieldFromPort(portId){
      if(!portId) return '';
      const parts = String(portId).split(':');
      if(parts.length <= 1) return parts[0] || '';
      const fieldParts = parts.slice(1);
      if(fieldParts.length > 1){
        const last = fieldParts[fieldParts.length - 1];
        if(last === 'left' || last === 'right') fieldParts.pop();
      }
      return fieldParts.join(':');
    }

    function handleDriverNodeMove(position){
      if(!erdAppInstance || !position) return;
      const id = String(position.id || '');
      if(!id) return;
      const x = Math.round(Number(position.x) || 0);
      const y = Math.round(Number(position.y) || 0);
      let persistRecord = null;
      erdAppInstance.setState(s => {
        const layout = Object.assign({}, s.data.layout || {});
        const current = layout[id] || {};
        if(current.x === x && current.y === y){
          return s;
        }
        layout[id] = { x, y };
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: s.data.schema,
          layout,
          canvas: s.data.canvas,
          classes: s.data.classes || [],
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now,
        };
        persistRecord = record;
        return {
          ...s,
          data:{
            ...s.data,
            layout,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) },
          },
          ui:{
            ...(s.ui || {}),
            form:{
              ...(s.ui?.form || {}),
              layout:{ x, y },
            },
          },
        };
      });
      erdAppInstance.flush();
      if(persistRecord){
        schedulePersist(persistRecord);
      }
    }

    function handleDriverSelect(ids){
      if(!erdAppInstance) return;
      const list = Array.isArray(ids) ? ids : [];
      if(!list.length) return;
      const tableName = list[0];
      if(!tableName) return;
      erdAppInstance.setState(s => withTableSelection(s, tableName));
      erdAppInstance.flush();
    }

    function handleDriverEdgeConnect(connection){
      if(!erdAppInstance || !connection) return;
      const sourceTable = connection.source?.id ? String(connection.source.id) : '';
      const targetTable = connection.target?.id ? String(connection.target.id) : '';
      const sourceField = extractFieldFromPort(connection.source?.port);
      const targetField = extractFieldFromPort(connection.target?.port);
      if(!sourceTable || !sourceField || !targetTable || !targetField) return;
      let persistRecord = null;
      erdAppInstance.setState(s => {
        const registry = Schema.Registry.fromJSON(s.data.schema);
        const table = registry.get(sourceTable);
        if(!table) return s;
        const field = table.getField(sourceField);
        if(!field) return s;
        const currentRefs = field.references || {};
        try {
          table.updateField(sourceField, {
            references:{
              table: targetTable,
              column: targetField,
              onDelete: currentRefs.onDelete || 'CASCADE',
              onUpdate: currentRefs.onUpdate || 'CASCADE',
              cardinality: currentRefs.cardinality,
            },
          });
        } catch(error){
          console.warn('[Mishkah][ERD] failed to apply edge connection', error);
          return s;
        }
        const schemaJSON = registry.toJSON();
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: schemaJSON,
          layout: s.data.layout,
          canvas: s.data.canvas,
          classes: s.data.classes || [],
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now,
        };
        persistRecord = record;
        let draft = {
          ...s,
          data:{
            ...s.data,
            schema: schemaJSON,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) },
          },
        };
        draft = withFieldSelection(draft, sourceTable, sourceField);
        return draft;
      });
      erdAppInstance.flush();
      if(persistRecord){
        schedulePersist(persistRecord);
      }
    }


    const SchemaLibrary = (function(){
      const storeName = 'schemas';
      const AdapterClass = (U && (U.IndexedDBX || U.IndexedDB)) || null;
      const hasIndexedDB = typeof indexedDB !== 'undefined' && !!AdapterClass;
      const adapter = hasIndexedDB ? new AdapterClass({
        name:'mishkah-erd',
        version:1,
        schema:{
          stores:{
            [storeName]:{
              keyPath:'id',
              autoIncrement:false,
              indexes:{
                by_name:{ keyPath:'name', unique:true },
                by_updatedAt:{ keyPath:'updatedAt' },
                by_createdAt:{ keyPath:'createdAt' }
              }
            }
          }
        }
      }) : null;
      const memory = new Map();
      const status = hasIndexedDB ? 'indexeddb' : 'memory';

      const SEED_SCHEMA = {
        id:'schema_seed',
        name:'commerce_schema',
        title:'مخطط متجر إلكتروني',
        description:'مخطط افتراضي يوضح علاقة العملاء بالطلبات والمخزون والمدفوعات.',
        tables:[
          {
            name:'customers',
            label:'العملاء',
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'full_name', type:'string', nullable:false, maxLength:180, comment:'اسم العميل الكامل' },
              { name:'email', type:'string', nullable:false, unique:true, comment:'بريد إلكتروني فريد لكل عميل' },
              { name:'phone_number', type:'string', nullable:true, comment:'رقم للتواصل' },
              { name:'created_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'orders',
            label:'الطلبات',
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_number', type:'string', nullable:false, unique:true, comment:'رقم الطلب الظاهر للعميل' },
              { name:'customer_id', type:'uuid', nullable:false, references:{ table:'customers', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'status', type:'string', nullable:false, defaultValue:'pending', enum:['pending','processing','shipped','completed','cancelled'] },
              { name:'total_amount', type:'decimal', nullable:false, precision:12, scale:2 },
              { name:'placed_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'order_items',
            label:'بنود الطلبات',
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_id', type:'uuid', nullable:false, references:{ table:'orders', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'product_id', type:'uuid', nullable:false, references:{ table:'products', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'quantity', type:'integer', nullable:false, defaultValue:1 },
              { name:'unit_price', type:'decimal', nullable:false, precision:10, scale:2 },
              { name:'line_total', type:'decimal', nullable:false, precision:12, scale:2 }
            ]
          },
          {
            name:'products',
            label:'المنتجات',
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'name', type:'string', nullable:false, maxLength:160 },
              { name:'sku', type:'string', nullable:false, unique:true, comment:'معرّف فريد للمخزون' },
              { name:'price', type:'decimal', nullable:false, precision:10, scale:2 },
              { name:'stock_quantity', type:'integer', nullable:false, defaultValue:0 },
              { name:'category_id', type:'uuid', nullable:true, references:{ table:'categories', column:'id', onDelete:'SET NULL', onUpdate:'CASCADE' } },
              { name:'created_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          },
          {
            name:'categories',
            label:'التصنيفات',
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'name', type:'string', nullable:false, unique:true },
              { name:'description', type:'text', nullable:true }
            ]
          },
          {
            name:'payments',
            label:'المدفوعات',
            fields:[
              { name:'id', type:'uuid', nullable:false, primaryKey:true },
              { name:'order_id', type:'uuid', nullable:false, references:{ table:'orders', column:'id', onDelete:'CASCADE', onUpdate:'CASCADE' } },
              { name:'payment_method', type:'string', nullable:false },
              { name:'paid_amount', type:'decimal', nullable:false, precision:12, scale:2 },
              { name:'paid_at', type:'timestamp', nullable:false, defaultValue:'NOW()' }
            ]
          }
        ]
      };

      function buildSeedRecord(){
        const registry = new Schema.Registry({ tables: SEED_SCHEMA.tables });
        const tables = registry.list();
        const layout = {};
        const fallbackPositions = createAutoLayoutFallbackMap(tables);
        tables.forEach((table, index) => {
          const fallback = fallbackPositions[table.id] || fallbackPositions[table.name] || {
            x: AUTO_LAYOUT_ORIGIN_X + index * FALLBACK_NODE_SPACING_X,
            y: AUTO_LAYOUT_ORIGIN_Y + index * FALLBACK_NODE_SPACING_Y,
          };
          const source = table.layout || {};
          layout[table.name] = normalisePoint(source, fallback);
        });
        const now = Date.now();
        return {
          id: SEED_SCHEMA.id,
          name: SEED_SCHEMA.name,
          title: SEED_SCHEMA.title,
          description: SEED_SCHEMA.description,
          schema: registry.toJSON(),
          layout,
          canvas:{ zoom:1, mode:'auto' },
          classes:[],
          createdAt: now,
          updatedAt: now
        };
      }

      function normalize(input, { bumpUpdatedAt=true }={}){
        const now = Date.now();
        const id = input.id || U.Id.uid('schema');
        const name = (input.name || '').trim() || `schema_${id.slice(-4)}`;
        const title = (input.title || '').trim() || name;
        const description = (input.description || '').trim();
        const schema = clone(input.schema || { tables: [] });
        const layout = clone(input.layout || {});
        const canvas = normaliseCanvas(clone(input.canvas || {}));
        const classes = normaliseClasses(clone(input.classes || []));
        const createdAt = input.createdAt || now;
        const updatedAt = bumpUpdatedAt ? now : (input.updatedAt || now);
        return { id, name, title, description, schema, layout, canvas, classes, createdAt, updatedAt };
      }

      async function ready(){
        if(adapter && adapter.ensureSchema){
          try { await adapter.ensureSchema(); }
          catch(error){ console.warn('[Mishkah][ERD] failed to ensure schema store', error); }
        }
        return true;
      }

      async function save(input, opts={}){
        const record = normalize(input, opts);
        if(adapter){
          try { await adapter.put(storeName, record); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB save failed', error); }
        }
        memory.set(record.id, clone(record));
        return clone(record);
      }

      async function get(id){
        if(!id) return null;
        if(adapter){
          try {
            const row = await adapter.get(storeName, id);
            if(row){
              memory.set(row.id, clone(row));
              return clone(row);
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB get failed', error);
          }
        }
        const existing = memory.get(id);
        return existing ? clone(existing) : null;
      }

      async function list(){
        if(adapter){
          try {
            const rows = await adapter.getAll(storeName);
            if(Array.isArray(rows)){
              rows.forEach(row => memory.set(row.id, clone(row)));
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB list failed', error);
          }
        }
        const out = Array.from(memory.values()).map(item => clone(item));
        out.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
        return out;
      }

      async function remove(id){
        if(!id) return false;
        if(adapter){
          try { await adapter.delete(storeName, id); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB delete failed', error); }
        }
        memory.delete(id);
        return true;
      }

      async function createBlank(meta={}){
        return save({
          id: meta.id,
          name: meta.name || '',
          title: meta.title || meta.name || 'مخطط جديد',
          description: meta.description || '',
          schema: new Schema.Registry().toJSON(),
          layout:{},
          canvas:{ zoom:1, mode:'auto' },
          classes:[],
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
      }

      async function createSeed(){
        const seed = buildSeedRecord();
        return save(seed, { bumpUpdatedAt:false });
      }

      return { status, available:true, ready, save, get, list, remove, createBlank, createSeed };
    })();

    await SchemaLibrary.ready();

    let libraryItems = await SchemaLibrary.list();
    if(!libraryItems.length){
      const seedRecord = await SchemaLibrary.createSeed();
      libraryItems = [seedRecord];
    }

    const activeRecord = libraryItems[0];
    const activeRegistry = Schema.Registry.fromJSON(activeRecord.schema || { tables: [] });
    const activeClasses = normaliseClasses(activeRecord.classes || []);

    function computeLayout(registry, layout){
      const map = Object.assign({}, layout || {});
      const tables = registry.list();
      const fallbackPositions = createAutoLayoutFallbackMap(tables);
      const rectIndex = createRectIndex();
      tables.forEach((table, index)=>{
        const baseFallback = fallbackPositions[table.id] || fallbackPositions[table.name] || {
          x: AUTO_LAYOUT_ORIGIN_X + index * FALLBACK_NODE_SPACING_X,
          y: AUTO_LAYOUT_ORIGIN_Y + index * FALLBACK_NODE_SPACING_Y,
        };
        const storedPoint = map[table.id] || map[table.name] || table.layout;
        const fields = Array.isArray(table?.fields) ? table.fields : [];
        const height = computeTableHeight(fields.length);
        const point = claimRect(storedPoint, baseFallback, rectIndex, {
          width: TABLE_WIDTH,
          height,
          padding: 48,
          stepX: AUTO_LAYOUT_COLUMN_GAP,
          stepY: AUTO_LAYOUT_ROW_GAP
        });
        const idKey = table?.id != null ? String(table.id) : '';
        const nameKey = table?.name != null ? String(table.name) : (idKey || `table_${index}`);
        if(idKey) map[idKey] = point;
        map[nameKey] = point;
      });
      return map;
    }

    const initialLayout = computeLayout(activeRegistry, activeRecord.layout);
    const firstTable = activeRegistry.list()[0]?.name || null;
    const initialLayoutPoint = firstTable ? (initialLayout[firstTable] || { x:120, y:120 }) : { x:120, y:120 };
    const uiPreferences = readUIPreferences();

    const erdState = {
      head:{ title: activeRecord.title || 'مخطط قاعدة بيانات مشكاة' },
      i18n:{ lang:'ar', fallback:'en', dict: I18N_DICT },
      env:{ theme:'dark', lang:'ar', dir:'rtl', graph:{ driver: initialGraphDriver } },
      data:{
        schemaId: activeRecord.id,
        schemaMeta:{
          name: activeRecord.name,
          title: activeRecord.title,
          description: activeRecord.description || ''
        },
        schemaCreatedAt: activeRecord.createdAt,
        schemaUpdatedAt: activeRecord.updatedAt,
        schema: activeRegistry.toJSON(),
        layout: initialLayout,
        selection:{ table:firstTable, field:null },
        canvas: normaliseCanvas(activeRecord.canvas),
        sqlPreview:'',
        error:null,
        library:{ items: libraryItems, status: SchemaLibrary.status },
        classes: activeClasses
      },
      ui:{
        modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false, columns:false, columnsUnique:false, columnsIndex:false, classification:false },
        template:{ open: uiPreferences.template.open },
        panels:{ libraryOpen: uiPreferences.panels.libraryOpen, classificationOpen: uiPreferences.panels.classificationOpen },
        jsonEditors:{
          import:{ mode:'editor' },
          exportJson:{ mode:'viewer' },
          classification:{ mode:'editor' }
        },
        form:{
          table:{ name:'', nameInput:'', label:'', comment:'', includeId:true, classCode:'' },
          field:{
            table:firstTable || '',
            name:'',
            nameInput:'',
            nameManual:false,
            columnName:'',
            type:'string',
            nullable:true,
            primaryKey:false,
            unique:false,
            defaultValue:'',
            references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
          },
          relation:{
            sourceTable:firstTable || '',
            sourceField:'',
            targetTable:'',
            targetField:'',
            onDelete:'CASCADE',
            onUpdate:'CASCADE'
          },
          import:{ name: activeRecord.name || '', title: activeRecord.title || '', targetId: activeRecord.id || '', text:'' },
          export:{ text:'' },
          sql:{ text:'' },
          layout:{ x: initialLayoutPoint.x, y: initialLayoutPoint.y },
          schemaMeta:{
            name: activeRecord.name || '',
            title: activeRecord.title || '',
            description: activeRecord.description || ''
          },
          columns:{ table:firstTable || '', rows: buildColumnsFormRows(activeRegistry.get(firstTable || '')) },
          classification:{
            rows: activeClasses.map(item => ({ ...item })),
            bulkText: activeClasses.length ? JSON.stringify(activeClasses, null, 2) : ''
          }
        },
        toolbar:{ exportOpen:false, exportAnchor:null },
        contextMenu:{ open:false, x:0, y:0, type:'canvas', table:'', field:'' },
        hiddenTables:[]
      }
    };

    function getRegistry(db){
      try {
        return Schema.Registry.fromJSON(db.data.schema);
      } catch(error){
        console.warn('[Mishkah][ERD] schema parse failed', error);
        return new Schema.Registry();
      }
    }

    function buildInteractionContext(db){
      const registry = getRegistry(db);
      const selection = db.data?.selection || {};
      const table = selection.table ? registry.get(selection.table) : null;
      const field = table && selection.field ? table.getField(selection.field) : null;
      return { registry, selection, table, field };
    }

    function ensureLayout(db, tableName, options = {}){
      const registry = options.registry || getRegistry(db);
      const layout = computeLayout(registry, db.data.layout);
      if(tableName && !layout[tableName]){
        const tables = registry.list();
        const index = Math.max(tables.findIndex(tbl => tbl.name === tableName), tables.length);
        const fallbackPositions = createAutoLayoutFallbackMap(tables);
        layout[tableName] = fallbackPositions[tableName] || {
          x: AUTO_LAYOUT_ORIGIN_X + index * FALLBACK_NODE_SPACING_X,
          y: AUTO_LAYOUT_ORIGIN_Y + index * FALLBACK_NODE_SPACING_Y,
        };
      }
      return layout;
    }

    function withTableSelection(state, tableName){
      if(!tableName) return state;
      const registry = getRegistry(state);
      const layout = ensureLayout(state, tableName, { registry });
      const tablePos = layout[tableName] || { x: 120, y: 120 };
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field:null }, layout },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            field:{ ...(state.ui?.form?.field || {}), table: tableName },
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName },
            layout:{ x: tablePos.x, y: tablePos.y }
          }
        }
      };
    }

    function withFieldSelection(state, tableName, fieldName){
      if(!tableName || !fieldName) return state;
      return {
        ...state,
        data:{ ...(state.data || {}), selection:{ table: tableName, field: fieldName } },
        ui:{
          ...(state.ui || {}),
          form:{
            ...(state.ui?.form || {}),
            relation:{ ...(state.ui?.form?.relation || {}), sourceTable: tableName, sourceField: fieldName }
          }
        }
      };
    }

    function focusTableOnCanvas(tableName, fieldName){
      if(!tableName || typeof document === 'undefined') return;
      const state = erdAppInstance ? erdAppInstance.getState() : lastDiagramState;
      if(!state) return;
      const registry = getRegistry(state);
      if(!registry || typeof registry.get !== 'function') return;
      const table = registry.get(tableName);
      if(!table) return;
      const layout = ensureLayout(state, tableName, { registry });
      const position = layout[tableName] || layout[String(table?.id || '')] || { x: AUTO_LAYOUT_ORIGIN_X, y: AUTO_LAYOUT_ORIGIN_Y };
      const fields = Array.isArray(table.fields) ? table.fields : [];
      const host = document.getElementById('erd-diagram');
      const driver = ensureDriverInstance(state);
      if(driver && typeof driver.focusNode === 'function'){
        try {
          driver.focusNode(tableName, { field: fieldName });
        } catch(error){
          console.warn('[Mishkah][ERD] focusNode failed', error);
        }
      }
      if(!host) return;
      const fieldCount = fields.length;
      const tableHeight = computeTableHeight(fieldCount);
      const centerX = position.x + TABLE_WIDTH / 2;
      let centerY = position.y + tableHeight / 2;
      if(fieldName){
        const index = fields.findIndex(field => String(field?.name || '').toLowerCase() === String(fieldName).toLowerCase());
        if(index >= 0){
          centerY = position.y + HEADER_HEIGHT + ROW_HEIGHT * index + ROW_HEIGHT / 2;
        }
      }
      const targetLeft = Math.max(0, centerX - (host.clientWidth || 0) / 2);
      const targetTop = Math.max(0, centerY - (host.clientHeight || 0) / 2);
      if(typeof host.scrollTo === 'function'){
        try {
          host.scrollTo({ left: targetLeft, top: targetTop, behavior: 'smooth' });
        } catch(_){
          host.scrollTo(targetLeft, targetTop);
        }
      } else {
        host.scrollLeft = targetLeft;
        host.scrollTop = targetTop;
      }
    }

    function mergeLibraryItems(list, record){
      const items = Array.isArray(list) ? list.slice() : [];
      const entry = clone(record);
      const idx = items.findIndex(item => item.id === record.id);
      if(idx >= 0) items[idx] = entry; else items.push(entry);
      items.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
      return items;
    }

    function toggleTableVisibility(ctx, tableName){
      if(!tableName) return;
      ctx.setState(s => {
        const hidden = new Set((s.ui?.hiddenTables || []).map(name => String(name)));
        if(hidden.has(tableName)) hidden.delete(tableName); else hidden.add(tableName);
        const nextHidden = Array.from(hidden);
        let nextData = s.data;
        if(hidden.has(tableName) && s.data?.selection?.table === tableName){
          nextData = { ...(s.data || {}), selection:{ table:null, field:null } };
        }
        return {
          ...s,
          data: nextData,
          ui:{ ...(s.ui || {}), hiddenTables: nextHidden }
        };
      });
      
    }

    function openColumnsManager(ctx, tableName){
      const state = ctx.getState();
      const registry = getRegistry(state);
      const targetName = tableName && registry.get(tableName) ? tableName : (registry.list()[0]?.name || '');
      const tableEntity = targetName ? registry.get(targetName) : null;
      const rows = buildColumnsFormRows(tableEntity);
      ctx.setState(s => ({
        ...s,
        ui:{
          ...(s.ui || {}),
          modals:{ ...(s.ui?.modals || {}), columns:true, columnsUnique:false, columnsIndex:false },
          form:{ ...(s.ui?.form || {}), columns:{ table: targetName, rows }, columnsUnique:null, columnsIndex:null }
        }
      }));
      
    }

    function openRelationModal(ctx, tableName, fieldName){
      ctx.setState(s => ({
        ...s,
        ui:{
          ...(s.ui || {}),
          modals:{ ...(s.ui?.modals || {}), relation:true },
          form:{
            ...(s.ui?.form || {}),
            relation:{
              sourceTable: tableName || s.data?.selection?.table || '',
              sourceField: fieldName || s.data?.selection?.field || '',
              targetTable:'',
              targetField:'',
              onDelete:'CASCADE',
              onUpdate:'CASCADE'
            }
          }
        }
      }));
      
    }

    function autoLayoutDiagram(ctx){
      const state = ctx.getState();
      const registry = getRegistry(state);
      const layout = computeLayout(registry, {});
      let nextState = null;
      ctx.setState(s => {
        const now = Date.now();
        const schemaJSON = registry.toJSON();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: schemaJSON,
          layout,
          canvas: Object.assign({}, s.data.canvas || {}, { mode:'auto' }),
          classes: s.data.classes || [],
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now
        };
        const draft = {
          ...s,
          data:{
            ...s.data,
            schema: schemaJSON,
            layout,
            canvas: Object.assign({}, s.data.canvas || {}, { mode:'auto' }),
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
          }
        };
        nextState = draft;
        return draft;
      });
      
      if(nextState){
        schedulePersist(recordFromState(nextState));
      }
    }

    async function pasteSchemaFromClipboard(ctx){
      if(typeof navigator === 'undefined' || !navigator.clipboard || typeof navigator.clipboard.readText !== 'function'){
        UI.pushToast(ctx, { title:'تعذر الوصول إلى الحافظة', icon:'⚠️' });
        return;
      }
      try{
        const text = await navigator.clipboard.readText();
        if(!text){
          UI.pushToast(ctx, { title:'الحافظة فارغة', icon:'⚠️' });
          return;
        }
        ctx.setState(s => ({
          ...s,
          ui:{
            ...(s.ui || {}),
            modals:{ ...(s.ui?.modals || {}), import:true },
            form:{ ...(s.ui?.form || {}), import:{ name: s.data.schemaMeta?.name || '', title: s.data.schemaMeta?.title || '', targetId: s.data.schemaId || '', text } }
          }
        }));
        
        UI.pushToast(ctx, { title:'تم جلب المخطط من الحافظة', icon:'📋' });
      } catch(error){
        console.warn('[Mishkah][ERD] clipboard paste failed', error);
        UI.pushToast(ctx, { title:'تعذر قراءة الحافظة', message:String(error), icon:'🛑' });
      }
    }

    function toggleFieldProperty(ctx, tableName, fieldName, property){
      if(!tableName || !fieldName || !property) return;
      const state = ctx.getState();
      const registry = getRegistry(state);
      const table = registry.get(tableName);
      if(!table){
        UI.pushToast(ctx, { title:'الجدول غير موجود', icon:'⚠️' });
        return;
      }
      const field = table.getField(fieldName);
      if(!field){
        UI.pushToast(ctx, { title:'الحقل غير موجود', icon:'⚠️' });
        return;
      }
      const patch = {};
      if(property === 'primaryKey'){
        patch.primaryKey = !field.primaryKey;
        if(!field.primaryKey) patch.nullable = false;
      } else if(property === 'nullable'){
        patch.nullable = field.nullable === false;
      } else if(property === 'unique'){
        patch.unique = !field.unique;
      } else if(property === 'index'){
        patch.index = !field.index;
      }
      try{
        table.updateField(fieldName, patch);
      } catch(error){
        console.warn('[Mishkah][ERD] field toggle failed', error);
        UI.pushToast(ctx, { title:'تعذر تحديث الحقل', message:String(error), icon:'🛑' });
        return;
      }
      const schemaJSON = registry.toJSON();
      let nextState = null;
      ctx.setState(s => {
        const now = Date.now();
        const record = {
          id: s.data.schemaId,
          name: s.data.schemaMeta?.name || '',
          title: s.data.schemaMeta?.title || '',
          description: s.data.schemaMeta?.description || '',
          schema: schemaJSON,
          layout: s.data.layout,
          canvas: s.data.canvas,
          classes: s.data.classes || [],
          createdAt: s.data.schemaCreatedAt,
          updatedAt: now
        };
        const draft = {
          ...s,
          data:{
            ...s.data,
            schema: schemaJSON,
            schemaUpdatedAt: now,
            library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
          }
        };
        nextState = draft;
        return draft;
      });
      
      if(nextState){
        schedulePersist(recordFromState(nextState));
      }
      UI.pushToast(ctx, { title:'تم تحديث الحقل', icon:'✅' });
    }

    const schedulePersist = (function(){
      if(!SchemaLibrary.available) return ()=>{};
      const debounced = U.Control.debounce(async (record)=>{
        try{
          await SchemaLibrary.save(record, { bumpUpdatedAt:false });
        } catch(error){
          console.warn('[Mishkah][ERD] persist failed', error);
        }
      }, 600);
      return record => debounced(clone(record));
    })();

    function recordFromState(state){
      const meta = state.data.schemaMeta || {};
      return {
        id: state.data.schemaId,
        name: meta.name || '',
        title: meta.title || '',
        description: meta.description || '',
        schema: state.data.schema,
        layout: state.data.layout,
        canvas: state.data.canvas,
        classes: state.data.classes || [],
        createdAt: state.data.schemaCreatedAt,
        updatedAt: state.data.schemaUpdatedAt
      };
    }

    function getPanelSide(db, panel){
      const dir = (db.env?.dir || db.env?.direction || 'rtl').toLowerCase();
      if(panel === 'library'){
        return dir === 'rtl' ? 'right' : 'left';
      }
      if(panel === 'classification'){
        return dir === 'rtl' ? 'left' : 'right';
      }
      return 'left';
    }

    function SchemaLibraryPanel(db){
      const t = createTranslator(db);
      const panels = db.ui?.panels || {};
      if(panels.libraryOpen === false) return null;
      const library = db.data.library || {};
      const items = library.items || [];
      const activeId = db.data.schemaId;
      const dir = (db.env?.dir || db.env?.direction || 'rtl').toLowerCase();
      const panelSide = getPanelSide(db, 'library');
      const hideArrow = panelSide === 'left' ? '⟵' : '⟶';
      const hideLabel = t('panel.library.hide', 'إخفاء المكتبة');
      const hideText = dir === 'rtl'
        ? (panelSide === 'left' ? `${hideLabel} ${hideArrow}` : `${hideArrow} ${hideLabel}`)
        : (panelSide === 'left' ? `${hideArrow} ${hideLabel}` : `${hideLabel} ${hideArrow}`);
      const listContent = items.length
        ? D.Lists.Ul({ attrs:{ class: tw`flex flex-col gap-2 list-none m-0 p-0` } },
            items.map(item=> D.Lists.Li({ attrs:{ class: tw`rounded-xl border border-[var(--border)]/60 bg-[var(--surface-1)]/70 px-3 py-2 transition ${item.id === activeId ? 'ring-2 ring-[var(--primary)]/60' : 'hover:border-[var(--primary)]/50'}`, gkey:'erd:library:select', 'data-schema-id': item.id } }, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2` }}, [
                D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-0.5` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [item.title || item.name]),
                  D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [item.name])
                ]),
                D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-[10px] text-[var(--muted)]` }}, [U.Time.fmt(item.updatedAt || item.createdAt || Date.now())]),
                  UI.Button({ attrs:{ gkey:'erd:library:delete', 'data-schema-id': item.id, title:t('library.delete.title', 'حذف المخطط'), class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, ['🗑️'])
                ])
              ])
            ])))
        : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [t('library.empty', 'لم يتم حفظ أي مخططات بعد.')]);
      return D.Containers.Aside({ attrs:{ class: tw`flex h-full w-72 flex-shrink-0 flex-col border-l border-[var(--border)] bg-[var(--surface-2)]/70 backdrop-blur` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2 px-4 py-3 border-b border-[var(--border)]` }}, [
          D.Containers.Div({ attrs:{ class: tw`flex flex-col` }}, [
            D.Text.Span({ attrs:{ class: tw`text-base font-semibold` }}, [t('library.title', 'مكتبة المخططات')]),
            D.Text.Span({ attrs:{ class: tw`text-[10px] uppercase tracking-wide text-[var(--muted)]` }}, [library.status === 'indexeddb' ? t('library.storage.indexeddb', 'IndexedDB') : t('library.storage.memory', 'ذاكرة مؤقتة')])
          ]),
          UI.Button({ attrs:{ gkey:'erd:panel:library:toggle', 'data-state':'open', title: hideLabel, class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, [hideText])
        ]),
        D.Containers.Div({ attrs:{ class: tw`px-4 py-3 flex flex-col gap-2` }}, [
          UI.Button({ attrs:{ gkey:'erd:library:new' }, variant:'solid', size:'sm' }, [`➕ ${t('library.new.button', 'مخطط جديد')}`]),
          UI.Button({ attrs:{ gkey:'erd:import:open' }, variant:'ghost', size:'sm' }, [`⬆️ ${t('library.import.button', 'استيراد JSON')}`])
        ]),
        D.Containers.Div({ attrs:{ class: tw`flex-1 overflow-y-auto px-3 pb-4` }}, [listContent])
      ]);
    }

    function SchemaClassificationPanel(db){
      const t = createTranslator(db);
      const panels = db.ui?.panels || {};
      if(panels.classificationOpen === false) return null;
      const form = db.ui?.form?.classification || {};
      const rows = Array.isArray(form.rows) ? form.rows : [];
      const dir = (db.env?.dir || db.env?.direction || 'rtl').toLowerCase();
      const panelSide = getPanelSide(db, 'classification');
      const hideArrow = panelSide === 'left' ? '⟵' : '⟶';
      const hideLabel = t('panel.classification.hide', 'إخفاء التصنيف');
      const hideText = dir === 'rtl'
        ? (panelSide === 'left' ? `${hideLabel} ${hideArrow}` : `${hideArrow} ${hideLabel}`)
        : (panelSide === 'left' ? `${hideArrow} ${hideLabel}` : `${hideLabel} ${hideArrow}`);
      const emptyState = rows.length === 0
        ? D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [t('classification.empty', 'لم يتم تعريف أي فئات بعد.')])
        : null;
      const rowNodes = rows.map((row, index) => {
        const depth = classDepth(row.code || '');
        const indent = depth > 0 ? `padding-inline-start:${depth * 12}px;` : '';
        return D.Containers.Div({ attrs:{ class: tw`grid grid-cols-[96px_minmax(0,1fr)_minmax(0,1fr)_auto] items-center gap-2`, key:`class-row-${index}` }}, [
          UI.Input({ attrs:{ gkey:'erd:classes:update', 'data-index': String(index), 'data-field':'code', value: row.code || '', placeholder:'0101' } }),
          UI.Input({ attrs:{ gkey:'erd:classes:update', 'data-index': String(index), 'data-field':'name', value: row.name || '', placeholder:t('classification.name', 'Name'), style: indent } }),
          UI.Input({ attrs:{ gkey:'erd:classes:update', 'data-index': String(index), 'data-field':'parent', value: row.parent || '', placeholder:'01' } }),
          UI.Button({ attrs:{ gkey:'erd:classes:remove', 'data-index': String(index), class: tw`!px-2 !py-1 text-xs` }, variant:'ghost', size:'xs' }, ['✕'])
        ]);
      });
      const content = rowNodes.length
        ? rowNodes
        : [emptyState];
      const actions = D.Containers.Div({ attrs:{ class: tw`flex flex-wrap gap-2` }}, [
        UI.Button({ attrs:{ gkey:'erd:classes:add' }, variant:'ghost', size:'sm' }, [`➕ ${t('classification.addRow', 'إضافة صف')}`]),
        UI.Button({ attrs:{ gkey:'erd:classes:save' }, variant:'solid', size:'sm' }, [`💾 ${t('classification.save', 'حفظ التصنيف')}`]),
        UI.Button({ attrs:{ gkey:'erd:classes:open-bulk' }, variant:'ghost', size:'sm' }, [`📝 ${t('classification.bulk', 'ترميز الشجرة')}`])
      ]);
      return D.Containers.Aside({ attrs:{ class: tw`hidden xl:flex h-full w-80 flex-shrink-0 flex-col border-r border-[var(--border)] bg-[var(--surface-2)]/70 backdrop-blur` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2 px-4 py-3 border-b border-[var(--border)]` }}, [
          D.Text.Span({ attrs:{ class: tw`text-base font-semibold` }}, [t('classification.title', 'sche_Tree')]),
          UI.Button({ attrs:{ gkey:'erd:panel:classification:toggle', 'data-state':'open', title: hideLabel, class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, [hideText])
        ]),
        D.Containers.Div({ attrs:{ class: tw`px-4 py-3 flex flex-col gap-3` }}, [actions]),
        D.Containers.Div({ attrs:{ class: tw`flex-1 overflow-y-auto px-4 pb-4 flex flex-col gap-3` }}, content)
      ]);
    }

    function CollapsedPanelReveal(db, panel){
      const t = createTranslator(db);
      const isLibrary = panel === 'library';
      const labelKey = isLibrary ? 'panel.library.show' : 'panel.classification.show';
      const fallback = isLibrary ? 'إظهار المكتبة' : 'إظهار التصنيف';
      const label = t(labelKey, fallback);
      const gkey = isLibrary ? 'erd:panel:library:toggle' : 'erd:panel:classification:toggle';
      const dir = (db.env?.dir || db.env?.direction || 'rtl').toLowerCase();
      const side = getPanelSide(db, panel);
      const icon = side === 'left' ? '⟶' : '⟵';
      const buttonLabel = dir === 'rtl'
        ? (side === 'left' ? `${label} ${icon}` : `${icon} ${label}`)
        : (side === 'left' ? `${icon} ${label}` : `${label} ${icon}`);
      const baseClass = tw`absolute top-4 z-[2147482000]`;
      const containerClass = `${baseClass} ${side === 'left' ? 'left-4' : 'right-4'}`;
      return D.Containers.Div({ attrs:{ class: tw`pointer-events-none` }}, [
        D.Containers.Div({ attrs:{ class: containerClass }}, [
          UI.Button({ attrs:{ gkey, 'data-state':'closed', class: tw`pointer-events-auto !px-3 !py-2 rounded-full border border-[var(--border)] bg-[var(--surface-1)]/95 shadow-lg backdrop-blur`, title: label }, variant:'soft', size:'sm' }, [
            buttonLabel
          ])
        ])
      ]);
    }

    function TemplateOverlay(db, tables){
      const templateState = db.ui?.template || {};
      if(templateState.open === false) return null;
      const t = createTranslator(db);
      const registryTables = Array.isArray(tables) ? tables : getRegistry(db).list();
      const previewTables = registryTables.slice(0, 6);
      const cards = previewTables.length
        ? previewTables.map(table => {
            const fieldCount = (table.fields || []).length;
            const relationCount = (table.fields || []).filter(field => field.references).length;
            return D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)]/70 bg-[var(--surface-2)]/60 px-4 py-3 flex flex-col gap-2 shadow-sm` }}, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2` }}, [
                D.Containers.Div({ attrs:{ class: tw`flex flex-col` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [formatIdentifier(table.name)]),
                  table.label ? D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [table.label]) : null
                ].filter(Boolean)),
                UI.Button({ attrs:{ gkey:'erd:field:add:table', 'data-table': table.name, title:t('template.overlay.add-column.title', 'إضافة عمود جديد لهذا الجدول') }, variant:'ghost', size:'sm' }, [`➕ ${t('modal.columns.addColumn', 'عمود جديد')}`])
              ]),
              D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [`Fields: ${fieldCount} · Relations: ${relationCount}`])
            ].filter(Boolean));
          })
        : [
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [t('template.overlay.empty', 'ابدأ بإضافة جدول لإنشاء قالب المخطط.')])
          ];
      return D.Containers.Div({ attrs:{ class: tw`absolute bottom-4 left-4 z-20 w-80 max-w-full pointer-events-auto` }}, [
        D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)] bg-[var(--surface-1)]/95 shadow-xl backdrop-blur flex flex-col` }}, [
          D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between px-4 py-3 border-b border-[var(--border)]/80` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-semibold flex items-center gap-2` }}, ['🧩 ', t('template.overlay.heading', 'ملخص القالب الحالي')]),
            UI.Button({ attrs:{ gkey:'erd:template:toggle', title:t('template.overlay.hide-title', 'إخفاء الملخص'), class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, [t('template.overlay.hide', 'إخفاء')])
          ]),
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2 px-4 py-3 max-h-60 overflow-y-auto` }}, cards),
          D.Containers.Div({ attrs:{ class: tw`px-4 py-2 border-t border-[var(--border)]/60` }}, [
            D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)] leading-relaxed` }}, [t('template.overlay.description', 'هذا الملخص يوضح الجداول النشطة وعدد الحقول والعلاقات، مما يساعدك على فهم شكل المخطط بسرعة.')])
          ])
        ])
      ]);
    }

    function SchemaCanvas(db){
      const registry = getRegistry(db);
      const tables = registry.list();
      scheduleDiagramRender(db);
      const hasTables = tables.length > 0;
      const t = createTranslator(db);
      const emptyState = !hasTables
        ? D.Containers.Div({ attrs:{ class: tw`absolute inset-0 flex items-center justify-center pointer-events-none` }}, [
            D.Containers.Div({ attrs:{ class: tw`rounded-3xl border border-dashed border-[var(--border)] bg-[var(--surface-2)]/70 px-6 py-5 text-center text-sm text-[var(--muted)] max-w-md` }}, [t('canvas.empty', 'أضف جدولًا جديدًا لبدء بناء المخطط.')])
          ])
        : null;
      const overlay = TemplateOverlay(db, tables);
      return D.Containers.Div({ attrs:{ class: tw`relative flex-1 bg-[var(--surface-1)]` }}, [
        D.Containers.Div({ attrs:{ id:'erd-diagram', class: tw`absolute inset-0` }}, []),
        overlay,
        emptyState
      ].filter(Boolean));
    }

    function ToolbarExportMenu(db){
      const t = createTranslator(db);
      const open = db.ui?.toolbar?.exportOpen;
      const toggle = UI.Button({
        attrs:{
          gkey:'erd:toolbar:export',
          'data-state': open ? 'open' : 'closed',
          'aria-expanded': open ? 'true' : 'false',
          'aria-controls':'erd-toolbar-export-menu',
          type:'button',
          class: tw`!gap-2 !h-9 !rounded-full !px-4 !font-semibold min-w-max`
        },
        variant: open ? 'soft' : 'ghost',
        size:'sm'
      }, [
        D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [t('toolbar.export', 'تصدير')]),
        D.Text.Span({ attrs:{ class: tw`text-xs opacity-70` }}, ['⯆'])
      ]);
      const button = D.Containers.Div({ attrs:{ class: tw`relative overflow-visible`, style:'z-index:2147482000;' }}, [toggle]);
      const formats = [
        { id:'sql:postgres', label:'SQL — Postgres', format:'sql', dialect:'postgres' },
        { id:'sql:mysql', label:'SQL — MySQL', format:'sql', dialect:'mysql' },
        { id:'sql:sqlserver', label:'SQL — SQL Server', format:'sql', dialect:'sqlserver' },
        { id:'json', label:'JSON', format:'json' },
        { id:'png', label:'PNG', format:'png' },
        { id:'svg', label:'SVG', format:'svg' }
      ];
      const list = D.Lists.Ul({ attrs:{ class: tw`flex flex-col gap-1 p-2` }}, formats.map(item =>
        D.Lists.Li({ attrs:{ class: tw`list-none` }}, [
          UI.Button({
            attrs:{
              gkey:'erd:export:run',
              'data-format': item.format,
              'data-dialect': item.dialect || '',
              'data-option-id': item.id,
              class: tw`w-full justify-start text-sm`
            },
            variant:'ghost',
            size:'sm'
          }, [item.label])
        ])
      ));
      if(!open){
        return { button, overlay:null };
      }
      const dir = (db.env?.dir || db.env?.direction || 'rtl').toLowerCase();
      const anchor = db.ui?.toolbar?.exportAnchor || null;
      const topOffset = typeof anchor?.top === 'number' ? anchor.top : 56;
      const offsetY = 12;
      const topValue = Math.max(0, Math.round(topOffset + offsetY));
      const fallbackSpacing = 16;
      const horizontalValue = dir === 'rtl'
        ? Math.max(fallbackSpacing, Math.round(typeof anchor?.right === 'number' ? anchor.right : fallbackSpacing))
        : Math.max(fallbackSpacing, Math.round(typeof anchor?.left === 'number' ? anchor.left : fallbackSpacing));
      const positionStyle = dir === 'rtl'
        ? `top:${topValue}px;right:${horizontalValue}px;`
        : `top:${topValue}px;left:${horizontalValue}px;`;
      const overlay = D.Containers.Div({ attrs:{ class: tw`absolute inset-0 pointer-events-none` }}, [
        D.Containers.Div({ attrs:{ class: tw`absolute inset-0 pointer-events-auto`, gkey:'erd:toolbar:export:close' }}, []),
        D.Containers.Div({ attrs:{ class: tw`absolute pointer-events-auto`, style: positionStyle }}, [
          D.Containers.Div({ attrs:{ id:'erd-toolbar-export-menu', class: tw`min-w-[240px] rounded-2xl border border-[var(--border)] bg-[var(--surface-1)]/95 shadow-xl backdrop-blur-md pointer-events-auto` }}, [list])
        ])
      ]);
      return { button, overlay };
    }

    function ToolbarStatChip(icon, label, value){
      const displayValue = value != null && value !== '' ? String(value) : '0';
      return D.Containers.Div({ attrs:{ class: tw`flex items-center gap-2 rounded-full border border-[var(--border)]/60 bg-[var(--surface-1)]/80 px-3 py-1 shadow-sm` }}, [
        D.Text.Span({ attrs:{ class: tw`text-base` }}, [icon]),
        D.Containers.Div({ attrs:{ class: tw`flex items-baseline gap-1` }}, [
          D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [displayValue]),
          D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [label])
        ])
      ]);
    }

    function EnvironmentControls(db){
      const t = createTranslator(db);
      const theme = (db.env?.theme || 'dark').toLowerCase();
      const lang = (db.env?.lang || db.i18n?.lang || 'ar').toLowerCase();
      const isDark = theme === 'dark';
      const langButtons = D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1 rounded-full bg-[var(--surface-0)]/90 px-1 py-0.5 shadow-inner` }}, [
        UI.Button({
          attrs:{
            gkey:'ui:lang-ar',
            title:'العربية',
            'aria-pressed': lang === 'ar' ? 'true' : 'false',
            class: tw`${lang === 'ar' ? '!bg-[var(--primary)] !text-[var(--primary-foreground)] shadow-sm' : '!text-[var(--muted-foreground)] hover:!text-[var(--foreground)]'} !h-7 !min-w-[2.75rem] !rounded-full !px-3 text-[11px] font-semibold uppercase tracking-[0.14em]`
          },
          variant:'ghost',
          size:'sm'
        }, ['AR']),
        UI.Button({
          attrs:{
            gkey:'ui:lang-en',
            title:'English',
            'aria-pressed': lang === 'en' ? 'true' : 'false',
            class: tw`${lang === 'en' ? '!bg-[var(--primary)] !text-[var(--primary-foreground)] shadow-sm' : '!text-[var(--muted-foreground)] hover:!text-[var(--foreground)]'} !h-7 !min-w-[2.75rem] !rounded-full !px-3 text-[11px] font-semibold uppercase tracking-[0.14em]`
          },
          variant:'ghost',
          size:'sm'
        }, ['EN'])
      ]);
      const themeTitle = isDark
        ? t('toolbar.ui.theme.light', 'تفعيل الوضع النهاري')
        : t('toolbar.ui.theme.dark', 'تفعيل الوضع الليلي');
      const themeToggle = UI.Button({
        attrs:{
          gkey:'ui:theme-toggle',
          title: themeTitle,
          'aria-pressed': isDark ? 'true' : 'false',
          class: tw`!relative !h-8 !w-16 !rounded-full !border !border-[var(--border)]/60 !bg-[var(--surface-0)]/90 !p-1 transition-all duration-200 ease-out`
        },
        variant:'ghost',
        size:'sm'
      }, [
        D.Containers.Div({ attrs:{ class: tw`absolute inset-0 flex items-center justify-between px-2 text-base` }}, [
          D.Text.Span({ attrs:{ class: tw`${isDark ? 'opacity-50' : 'opacity-100'} leading-none` }}, ['🌞']),
          D.Text.Span({ attrs:{ class: tw`${isDark ? 'opacity-100' : 'opacity-50'} leading-none` }}, ['🌙'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`absolute top-1/2 h-6 w-6 -translate-y-1/2 rounded-full bg-[var(--primary)] shadow-md transition-all duration-200 ease-out`, style: isDark ? 'left: calc(100% - 28px);' : 'left:4px;' }}, [])
      ]);
      return D.Containers.Div({ attrs:{ class: tw`shrink-0 flex items-center gap-2 rounded-full border border-[var(--border)]/70 bg-[color-mix(in oklab,var(--surface-1) 90%, transparent)] px-2 py-1 shadow-sm` }}, [
        langButtons,
        themeToggle
      ]);
    }

    function Toolbar(db){
      const t = createTranslator(db);
      const zoom = db.data.canvas?.zoom || 1;
      const templateOpen = db.ui?.template?.open !== false;
      const panels = db.ui?.panels || {};
      const libraryOpen = panels.libraryOpen !== false;
      const exportMenu = ToolbarExportMenu(db);
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableCount = tables.length;
      const fieldCount = tables.reduce((total, table)=> total + (Array.isArray(table.fields) ? table.fields.length : 0), 0);
      const relationCount = tables.reduce((total, table)=> total + (Array.isArray(table.fields) ? table.fields.filter(field => field && field.references).length : 0), 0);
      const metaTitle = db.data.schemaMeta?.title || t('schema.untitled', 'مخطط بدون اسم');
      const schemaIdentifier = db.data.schemaMeta?.name ? formatIdentifier(db.data.schemaMeta.name) : '';
      const driverName = (db.env?.graph?.driver || 'fake').toUpperCase();

      const schemaSection = D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3 min-w-0` }}, [
        D.Containers.Div({ attrs:{ class: tw`hidden sm:flex h-11 w-11 items-center justify-center rounded-2xl bg-[var(--primary)]/15 text-xl text-[var(--primary)]` }}, ['🗂️']),
        D.Containers.Div({ attrs:{ class: tw`flex min-w-0 flex-col` }}, [
          D.Text.Span({ attrs:{ class: tw`text-[10px] font-semibold uppercase tracking-[0.28em] text-[var(--muted)]` }}, [t('toolbar.schema.group', 'المخطط')]),
          D.Text.Span({ attrs:{ class: tw`truncate text-lg font-bold leading-tight` }}, [metaTitle]),
          schemaIdentifier ? D.Text.Span({ attrs:{ class: tw`truncate text-[11px] text-[var(--muted)]` }}, [`#${schemaIdentifier}`]) : null
        ].filter(Boolean)),
        UI.Button({ attrs:{ gkey:'erd:schema:meta:open', class: tw`!h-9 !rounded-full !px-3 !text-sm !font-semibold` }, variant:'ghost', size:'sm' }, [`✏️ ${t('toolbar.schema.edit', 'خصائص المخطط')}`])
      ]);

      const statsRow = D.Containers.Div({ attrs:{ class: tw`hidden xl:flex flex-wrap items-center gap-2` }}, [
        ToolbarStatChip('🧱', t('toolbar.stats.tables', 'جداول'), tableCount),
        ToolbarStatChip('🧮', t('toolbar.stats.fields', 'حقول'), fieldCount),
        ToolbarStatChip('🔗', t('toolbar.stats.relations', 'علاقات'), relationCount),
        ToolbarStatChip('⚙️', t('toolbar.schema.driver', 'المحرك'), driverName)
      ]);

      const templateToggle = UI.Button({
        attrs:{
          gkey:'erd:template:toggle',
          'data-next-state': templateOpen ? 'closed' : 'open',
          class: tw`${templateOpen ? '!bg-[var(--primary)] !text-[var(--primary-foreground)] shadow-sm' : '!text-[var(--muted-foreground)] hover:!text-[var(--foreground)]'} !h-9 !rounded-full !px-3 !text-sm !font-semibold`
        },
        variant: templateOpen ? 'soft' : 'ghost',
        size:'sm'
      }, [templateOpen ? `🧩 ${t('toolbar.templates.hide', 'إخفاء القالب')}` : `🧩 ${t('toolbar.templates.show', 'عرض القالب')}`]);

      const startSection = D.Containers.Div({ attrs:{ class: tw`flex flex-shrink-0 items-center gap-4 min-w-0` }}, [
        schemaSection,
        templateToggle,
        statsRow
      ]);

      const newDiagramButton = UI.Button({ attrs:{ gkey:'erd:library:new', class: tw`!h-10 !rounded-full !px-4 !font-semibold shadow-sm` }, variant:'soft', size:'sm' }, [`➕ ${t('library.new.button', 'مخطط جديد')}`]);
      const quickButtons = [
        UI.Button({ attrs:{ gkey:'erd:table:add', class: tw`!h-10 !rounded-full !px-4 !font-semibold` }, variant:'ghost', size:'sm' }, [`➕ ${t('toolbar.structure.addTable', 'جدول')}`]),
        UI.Button({ attrs:{ gkey:'erd:field:add', class: tw`!h-10 !rounded-full !px-4 !font-semibold` }, variant:'ghost', size:'sm' }, [`➕ ${t('toolbar.structure.addField', 'حقل')}`]),
        UI.Button({ attrs:{ gkey:'erd:relation:add', class: tw`!h-10 !rounded-full !px-4 !font-semibold` }, variant:'ghost', size:'sm' }, [`🔗 ${t('toolbar.structure.addRelation', 'علاقة')}`]),
        UI.Button({ attrs:{ gkey:'erd:columns:open', class: tw`!h-10 !rounded-full !px-4 !font-semibold` }, variant:'ghost', size:'sm' }, [`🗂️ ${t('toolbar.structure.columns', 'الأعمدة')}`])
      ];

      const libraryToggle = D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1 rounded-full border border-[var(--border)]/60 bg-[var(--surface-1)]/80 px-1.5 py-1 shadow-sm` }}, [
        UI.Button({
          attrs:{
            gkey:'erd:panel:library:toggle',
            'data-next-state':'open',
            class: tw`${libraryOpen ? '!bg-[var(--primary)] !text-[var(--primary-foreground)] shadow-sm' : '!text-[var(--muted-foreground)] hover:!text-[var(--foreground)]'} !h-8 !rounded-full !px-3 text-xs font-semibold`
          },
          variant:'ghost',
          size:'sm'
        }, [t('panel.library.show', 'إظهار المكتبة')]),
        UI.Button({
          attrs:{
            gkey:'erd:panel:library:toggle',
            'data-next-state':'closed',
            class: tw`${!libraryOpen ? '!bg-[var(--primary)] !text-[var(--primary-foreground)] shadow-sm' : '!text-[var(--muted-foreground)] hover:!text-[var(--foreground)]'} !h-8 !rounded-full !px-3 text-xs font-semibold`
          },
          variant:'ghost',
          size:'sm'
        }, [t('panel.library.hide', 'إخفاء المكتبة')])
      ]);

      const quickActionsRow = D.Containers.Div({ attrs:{ class: tw`flex flex-wrap items-center justify-center gap-2` }}, [
        newDiagramButton,
        ...quickButtons,
        libraryToggle
      ]);

      const quickActions = D.Containers.Div({ attrs:{ class: tw`flex flex-1 items-center justify-center gap-2 min-w-0` }}, [quickActionsRow]);

      const historyControls = D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1 rounded-full border border-[var(--border)]/60 bg-[var(--surface-1)]/80 px-1.5 py-1 shadow-sm` }}, [
        UI.Button({ attrs:{ gkey:'erd:undo', title:t('toolbar.history.undo.title', 'تراجع'), class: tw`!h-8 !w-8 !rounded-full` }, variant:'ghost', size:'sm' }, ['↺']),
        UI.Button({ attrs:{ gkey:'erd:redo', title:t('toolbar.history.redo.title', 'إعادة'), class: tw`!h-8 !w-8 !rounded-full` }, variant:'ghost', size:'sm' }, ['↻']),
        UI.Button({ attrs:{ gkey:'erd:fit', title:t('toolbar.history.fit.title', 'ملاءمة المخطط للشاشة'), class: tw`!h-8 !w-8 !rounded-full` }, variant:'ghost', size:'sm' }, ['🗺️'])
      ]);

      const exportControl = D.Containers.Div({ attrs:{ class: tw`flex items-center rounded-full border border-[var(--border)]/60 bg-[var(--surface-1)]/80 px-1.5 py-1 shadow-sm` }}, [exportMenu.button]);

      const zoomControls = D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1 rounded-full border border-[var(--border)]/60 bg-[var(--surface-1)]/80 px-2.5 py-1 shadow-sm` }}, [
        UI.Button({ attrs:{ gkey:'erd:zoom:out', title:t('toolbar.zoom.out.title', 'تصغير'), class: tw`!h-8 !w-8 !rounded-full` }, variant:'ghost', size:'sm' }, ['➖']),
        UI.Button({ attrs:{ gkey:'erd:zoom:reset', title:t('toolbar.zoom.reset.title', 'إعادة الحجم'), class: tw`!h-8 !w-8 !rounded-full` }, variant:'ghost', size:'sm' }, ['⟳']),
        UI.Button({ attrs:{ gkey:'erd:zoom:in', title:t('toolbar.zoom.in.title', 'تكبير'), class: tw`!h-8 !w-8 !rounded-full` }, variant:'ghost', size:'sm' }, ['➕']),
        D.Text.Span({ attrs:{ class: tw`text-sm font-semibold min-w-[3ch] text-center` }}, [`${Math.round(zoom * 100)}%`])
      ]);

      const utilities = D.Containers.Div({ attrs:{ class: tw`flex flex-shrink-0 items-center gap-2 ms-auto` }}, [
        historyControls,
        exportControl,
        zoomControls,
        EnvironmentControls(db)
      ]);

      const view = D.Containers.Header({ attrs:{ class: tw`sticky top-0 z-[520] flex w-full border-b border-[var(--border)] bg-[color-mix(in oklab,var(--background) 88%, transparent)]/90 px-3 py-2 backdrop-blur supports-[backdrop-filter]:bg-[color-mix(in oklab,var(--background) 84%, transparent)]/70` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex w-full items-center gap-3 overflow-x-auto` }}, [
          startSection,
          quickActions,
          utilities
        ])
      ]);
      const overlays = exportMenu.overlay ? [exportMenu.overlay] : [];
      return { view, overlays };
    }

    function ModalImport(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.import;
      const form = db.ui?.form?.import || { name:'', title:'', targetId:'', text:'' };
      const library = db.data.library || {};
      const items = library.items || [];
      return UI.Modal({
        open,
        size:'lg',
        title:t('modal.import.title', 'استيراد مخطط JSON'),
        description:t('modal.import.description', 'ألصق بيانات المخطط أو استبدل مخططًا موجودًا.'),
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'name', value: form.name || '', placeholder:t('modal.import.name.placeholder', 'المعرف الفريد للمخطط (name)') } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'title', value: form.title || '', placeholder:t('modal.import.title.placeholder', 'العنوان المعروض') } }),
            UI.Select({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'targetId', value: form.targetId || '' }, options:[
              { value:'', label:t('modal.import.target.new', 'إنشاء مخطط جديد') },
              ...items.map(item=> ({ value:item.id, label:`${t('modal.import.target.replace', 'استبدال:')} ${item.title || item.name}` }))
            ] }),
            JsonEditorTabs(db, {
              id:'import',
              text: form.text || '',
              gkey:'erd:form:update',
              formKey:'import',
              fieldKey:'text',
              placeholder:'{"schema":{...}}',
              height:384,
              rows:22,
              t
            })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:import:apply', variant:'solid', size:'sm' }}, [t('modal.import.submit', 'استيراد وتخزين')]),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('modal.close', 'إغلاق')])
        ]
      });
    }

    function ModalExportJson(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.exportJson;
      const text = db.ui?.form?.export?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:t('modal.exportJson.title', 'مخطط JSON'),
        description:t('modal.exportJson.description', 'انسخ المحتوى للاستخدام في أماكن أخرى.'),
        closeGkey:'erd:modal:close',
        content:[
          JsonEditorTabs(db, {
            id:'exportJson',
            text,
            gkey:'erd:form:update',
            formKey:'export',
            fieldKey:'text',
            height:384,
            rows:22,
            t
          })
        ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('modal.done', 'تم')]) ]
      });
    }

    function ModalExportSql(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.exportSql;
      const text = db.ui?.form?.sql?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:t('modal.exportSql.title', 'نص SQL'),
        description:t('modal.exportSql.description', 'هذا النص يمثل أوامر إنشاء الجداول PostgreSQL.'),
        closeGkey:'erd:modal:close',
        content:[ UI.Textarea({ attrs:{ readonly:true, value: text, rows:16, class: tw`w-full font-mono text-xs` } }) ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('modal.done', 'تم')]) ]
      });
    }

    function ModalSchemaMeta(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.schemaMeta;
      const form = db.ui?.form?.schemaMeta || { name:'', title:'', description:'' };
      return UI.Modal({
        open,
        size:'md',
        title:t('modal.schemaMeta.title', 'خصائص المخطط'),
        description:t('modal.schemaMeta.description', 'قم بتحديث اسم التعريف والعنوان والوصف.'),
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'name', value: form.name || '', placeholder:'Name (snake_case)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'title', value: form.title || '', placeholder:'Title' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'description', value: form.description || '', rows:4, placeholder:t('modal.schemaMeta.description.placeholder', 'وصف مختصر للمخطط') } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:schema:meta:save', variant:'solid', size:'sm' }}, [t('modal.schemaMeta.save', 'حفظ التعديلات')]),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('common.cancel', 'إلغاء')])
        ]
      });
    }

    function ModalAddTable(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.table;
      const form = db.ui?.form?.table || { name:'', nameInput:'', label:'', comment:'', includeId:true };
      const registry = getRegistry(db);
      const sanitizedName = form.name || '';
      const suggestedName = sanitizedName || (form.label ? sanitizeSqlIdentifier(form.label) : '');
      const helperTemplate = suggestedName
        ? t('table.create.helper.suggested', `سيتم حفظ الجدول في قاعدة البيانات بالاسم: ${suggestedName} مع ضمان عدم تكرار المعرف داخل المخطط.`)
        : t('table.create.helper.prompt', 'اكتب اسمًا إنجليزيًا، وسيتم تحويل المسافات والمحارف الخاصة تلقائيًا إلى صيغة SQL سليمة.');
      const helperText = helperTemplate.replace('{name}', suggestedName);
      const classRows = Array.isArray(db.data?.classes) ? db.data.classes : [];
      const leafClasses = computeClassLeaves(classRows);
      const classOptions = leafClasses.map(item => ({
        value: item.code,
        label: item.name ? `${item.code} — ${item.name}` : item.code
      }));
      return UI.Modal({
        open,
        size:'md',
        title:t('modal.table.title', 'إنشاء جدول جديد'),
        description:t('modal.table.description', 'الاسم الإنجليزي مطلوب وسيُستخدم كاسم الجدول في قاعدة البيانات. يمكنك إضافة مسمى بلغة أخرى اختياريًا.'),
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'name', value: form.nameInput || '', placeholder:t('modal.table.name.placeholder', 'English name (مثال: Sales Orders)') } }),
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [helperText]),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'label', value: form.label || '', placeholder:t('modal.table.label.placeholder', 'اسم الجدول بلغة ثانية (اختياري)') } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'comment', value: form.comment || '', rows:3, placeholder:t('common.notes.placeholder', 'ملاحظات') } }),
            UI.Select({
              attrs:{
                gkey:'erd:form:update',
                'data-form':'table',
                'data-field':'classCode',
                value: form.classCode || ''
              },
              options:[{ value:'', label:t('modal.table.class.placeholder', 'اختر الفئة') }, ...classOptions]
            }),
            classOptions.length ? null : D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [t('classification.leaf.only', 'يرجى اختيار كود نهائي من الشجرة.')]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-2` }}, [
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'table', 'data-field':'includeId', type:'checkbox', checked: form.includeId !== false } }),
              UI.Label({ text:t('modal.table.includeId', 'إنشاء حقل id افتراضي؟') })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:table:create', variant:'solid', size:'sm' }}, [t('common.create', 'إنشاء')]),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('common.cancel', 'إلغاء')])
        ]
      });
    }

    function ModalAddField(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.field;
      const form = db.ui?.form?.field || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} — ${table.label}`
          : formatIdentifier(table.name)
      }));
      const selectedTable = form.table && registry.get(form.table)
        ? form.table
        : (tableOptions[0]?.value || '');
      const currentTable = selectedTable ? registry.get(selectedTable) : null;
      const previewFieldName = form.name || (form.label ? computeFieldIdentifier(currentTable, form.label) : '');
      const englishInputValue = form.nameInput != null ? form.nameInput : (form.name || '');
      const selectedReferenceTable = form.references?.table && registry.get(form.references.table)
        ? form.references.table
        : '';
      const referenceTableEntity = selectedReferenceTable ? registry.get(selectedReferenceTable) : null;
      const referenceFieldOptions = referenceTableEntity
        ? referenceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const selectedReferenceField = referenceFieldOptions.some(opt => opt.value === form.references?.column)
        ? form.references?.column
        : '';
      return UI.Modal({
        open,
        size:'lg',
        title:t('modal.field.title', 'إضافة حقل'),
        description:t('modal.field.description', 'حدد تفاصيل الحقل الجديد مع اسم إنجليزي متوافق مع SQL ومسمى عربي اختياري.'),
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{
                gkey:'erd:form:update',
                'data-form':'field',
                'data-field':'table',
                value: selectedTable || ''
              },
              options:[{ value:'', label:t('modal.field.table.placeholder', 'اختر الجدول') }, ...tableOptions]
            }),
            UI.Input({
              attrs:{
                gkey:'erd:form:update',
                'data-form':'field',
                'data-field':'name',
                value: englishInputValue,
                placeholder:'English column name (snake_case)'
              }
            }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'label', value: form.label || '', placeholder:t('modal.field.label.placeholder', 'المسمى العربي للحقل') } }),
            D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--accent-foreground)]/80 md:col-span-2` }}, [previewFieldName ? t('modal.field.identifier.preview', `المعرف النهائي: ${previewFieldName}`).replace('{name}', previewFieldName) : t('modal.field.identifier.pending', 'سيتم توليد المعرف تلقائيًا عند الكتابة.')]),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'type', value: form.type || 'string' },
              options: FIELD_TYPE_OPTIONS
            }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'defaultValue', value: form.defaultValue || '', placeholder:t('modal.field.default.placeholder', 'قيمة افتراضية') } }),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:t('modal.field.nullable', 'Nullable؟') }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'nullable', type:'checkbox', checked: form.nullable !== false } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:t('modal.field.primaryKey', 'Primary Key؟') }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'primaryKey', type:'checkbox', checked: !!form.primaryKey } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:t('modal.field.unique', 'Unique؟') }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'unique', type:'checkbox', checked: !!form.unique } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`col-span-full flex flex-col gap-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, [t('modal.field.reference.title', 'علاقة مرجعية اختيارية')]),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'table',
                  value: selectedReferenceTable
                },
                options:[{ value:'', label:t('modal.field.reference.none', 'بدون علاقة') }, ...tableOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'column',
                  value: selectedReferenceField
                },
                options:[{ value:'', label:t('modal.field.reference.selectField', 'اختر الحقل') }, ...referenceFieldOptions]
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onDelete',
                  value: form.references?.onDelete || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              }),
              UI.Select({
                attrs:{
                  gkey:'erd:form:update',
                  'data-form':'fieldRef',
                  'data-field':'onUpdate',
                  value: form.references?.onUpdate || 'CASCADE'
                },
                options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
              })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:field:create', variant:'solid', size:'sm' }}, [t('common.add', 'إضافة')]),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('common.cancel', 'إلغاء')])
        ]
      });
    }

    function ModalRelation(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.relation;
      const form = db.ui?.form?.relation || {};
      const registry = getRegistry(db);
      const tables = registry.list();
      const tableOptions = tables.map(table => ({
        value: table.name,
        label: table.label && table.label !== table.name
          ? `${formatIdentifier(table.name)} — ${table.label}`
          : formatIdentifier(table.name)
      }));
      const sourceTableValue = form.sourceTable && registry.get(form.sourceTable)
        ? form.sourceTable
        : '';
      const sourceTableEntity = sourceTableValue ? registry.get(sourceTableValue) : null;
      const sourceFieldOptions = sourceTableEntity
        ? sourceTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const sourceFieldValue = sourceFieldOptions.some(opt => opt.value === form.sourceField)
        ? form.sourceField
        : '';
      const targetTableValue = form.targetTable && registry.get(form.targetTable)
        ? form.targetTable
        : '';
      const targetTableEntity = targetTableValue ? registry.get(targetTableValue) : null;
      const targetFieldOptions = targetTableEntity
        ? targetTableEntity.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
        : [];
      const targetFieldValue = targetFieldOptions.some(opt => opt.value === form.targetField)
        ? form.targetField
        : '';
      return UI.Modal({
        open,
        size:'md',
        title:t('modal.relation.title', 'إنشاء علاقة بين الجداول'),
        description:t('modal.relation.description', 'حدد الجدول المصدر والهدف وأسلوب التحديث.'),
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceTable', value: sourceTableValue },
              options:[{ value:'', label:t('modal.relation.sourceTable', 'اختر الجدول المصدر') }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceField', value: sourceFieldValue },
              options:[{ value:'', label:t('modal.relation.sourceField', 'اختر الحقل المصدر') }, ...sourceFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetTable', value: targetTableValue },
              options:[{ value:'', label:t('modal.relation.targetTable', 'اختر الجدول الهدف') }, ...tableOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetField', value: targetFieldValue },
              options:[{ value:'', label:t('modal.relation.targetField', 'اختر الحقل الهدف') }, ...targetFieldOptions]
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onDelete', value: form.onDelete || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            }),
            UI.Select({
              attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onUpdate', value: form.onUpdate || 'CASCADE' },
              options: RELATION_ACTION_OPTIONS.map(action => ({ value: action, label: action }))
            })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:relation:create', variant:'solid', size:'sm' }}, [t('modal.relation.save', 'حفظ العلاقة')]),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('common.cancel', 'إلغاء')])
        ]
      });
    }

    function ModalColumnsManager(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.columns;
      if(!open) return null;
      const registry = getRegistry(db);
      const tables = registry.list();
      if(!tables.length){
        return UI.Modal({
          open,
          size:'full',
          title:t('modal.columns.empty.title', 'محرر الأعمدة'),
          description:t('modal.columns.empty.description', 'لا توجد جداول في المخطط بعد. قم بإضافة جدول لبدء إدارة الأعمدة.'),
          closeGkey:'erd:modal:close',
          content:[ D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [t('modal.columns.empty.action', 'أضف جدولًا جديدًا من شريط الأدوات ثم عد إلى هنا.')]) ],
          actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('modal.close', 'إغلاق')]) ]
        });
      }
      const form = db.ui?.form?.columns || {};
      const currentTableName = form.table && registry.get(form.table)
        ? form.table
        : (tables[0]?.name || '');
      const currentTable = currentTableName ? registry.get(currentTableName) : null;
      const rows = Array.isArray(form.rows) && form.rows.length ? form.rows : buildColumnsFormRows(currentTable);
      const tableNav = D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-1` }}, tables.map(table => UI.Button({
        attrs:{
          gkey:'erd:columns:select-table',
          'data-table': table.name,
          class: tw`${table.name === currentTableName ? '!bg-[var(--accent)] !text-[var(--accent-foreground)]' : ''}`
        },
        variant: table.name === currentTableName ? 'soft' : 'ghost',
        size:'sm'
      }, [formatIdentifier(table.name)])));
      const columnHeaders = [
        t('modal.columns.table.header.name', 'الاسم'),
        t('modal.columns.table.header.type', 'النوع'),
        t('modal.columns.table.header.length', 'الطول / الدقة'),
        t('modal.columns.table.header.nullable', 'NULL؟'),
        t('modal.columns.table.header.pk', 'PK'),
        t('modal.columns.table.header.default', 'القيمة الافتراضية'),
        t('modal.columns.table.header.references', 'المفتاح الأجنبي'),
        t('modal.columns.table.header.actions', 'إجراءات')
      ];
      const columnHeaderRow = D.Tables.Tr({}, columnHeaders.map((label, index) =>
        D.Tables.Th({ attrs:{ key:`col-head-${index}`, class: tw`px-3 py-2 text-xs font-semibold text-[var(--muted-foreground)] text-right` }}, [label])
      ));
      const columnBodyRows = rows.length
        ? rows.map((row, index) => {
            const key = row.key || row.originalName || `${currentTableName}:${index}`;
            const typeOptions = FIELD_TYPE_OPTIONS;
            const supportsLength = typeSupportsLength(row.type);
            const supportsPrecision = typeSupportsPrecision(row.type);
            const sizeControls = [];
            if(supportsLength){
              sizeControls.push(UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'length', value: row.length || '', placeholder:t('modal.columns.length.placeholder', 'الطول'), class: tw`w-full`, type:'number', min:'1' } }));
            }
            if(supportsPrecision){
              sizeControls.push(D.Containers.Div({ attrs:{ class: tw`grid grid-cols-2 gap-2` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'precision', value: row.precision || '', placeholder:t('modal.columns.precision.placeholder', 'الدقة'), class: tw`w-full`, type:'number', min:'1' } }),
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'scale', value: row.scale || '', placeholder:t('modal.columns.scale.placeholder', 'المقياس'), class: tw`w-full`, type:'number', min:'0' } })
              ]));
            }
            const refTableValue = row.references?.table || '';
            const referenceTableOptions = [{ value:'', label:t('modal.columns.reference.table', 'جدول المرجع') }].concat(
              tables.map(table => ({ value: table.name, label: formatIdentifier(table.name) }))
            );
            const referenceTableEntity = refTableValue ? registry.get(refTableValue) : null;
            const compatibleColumns = referenceTableEntity && Array.isArray(referenceTableEntity.fields)
              ? referenceTableEntity.fields.filter(field => typesAreCompatible(row.type || '', field.type))
              : [];
            const referenceColumnOptions = [{ value:'', label:t('modal.columns.reference.column', 'حقل المرجع') }].concat(
              compatibleColumns.map(field => ({ value: field.name, label: formatIdentifier(field.name) }))
            );
            const selectedRefColumn = referenceColumnOptions.some(opt => opt.value === (row.references?.column || ''))
              ? row.references?.column || ''
              : '';
            const referenceControls = compatibleColumns.length
              ? [
                  UI.Select({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'refTable', value: refTableValue }, options: referenceTableOptions }),
                  UI.Select({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'refColumn', value: selectedRefColumn }, options: referenceColumnOptions })
                ]
              : [
                  UI.Select({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'refTable', value: refTableValue }, options: referenceTableOptions }),
                  D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [t('modal.columns.reference.noMatch', 'لا توجد أعمدة متوافقة في الجدول المحدد.')])
                ];
            const quickActions = D.Containers.Div({ attrs:{ class: tw`flex items-center justify-end gap-2` }}, [
              UI.Button({ attrs:{ gkey:'erd:columns:open-relation', 'data-row': key, 'data-table': currentTableName, class: tw`!px-2 !py-1 text-xs` }, variant:'ghost', size:'xs' }, ['FK']),
              UI.Button({ attrs:{ gkey:'erd:columns:focus', 'data-row': key, 'data-table': currentTableName, class: tw`!px-2 !py-1 text-xs` }, variant:'ghost', size:'xs' }, [t('modal.columns.focus', 'عرض في المخطط')]),
              UI.Button({ attrs:{ gkey:'erd:columns:delete-row', 'data-row': key, 'data-table': currentTableName, title: t('modal.columns.delete', 'حذف العمود'), class: tw`!px-2 !py-1 text-xs text-[var(--destructive)]` }, variant:'ghost', size:'xs' }, ['🗑️'])
            ]);
            return D.Tables.Tr({ attrs:{ key, class: tw`bg-[var(--surface-1)]` }}, [
              D.Tables.Td({ attrs:{ class: tw`px-3 py-3 align-top` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'name', value: row.name || '', placeholder:t('modal.columns.name.placeholder', 'اسم العمود (snake_case)') } })
              ]),
              D.Tables.Td({ attrs:{ class: tw`px-3 py-3 align-top` }}, [
                UI.Select({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'type', value: row.type || 'string' }, options: typeOptions })
              ]),
              D.Tables.Td({ attrs:{ class: tw`px-3 py-3 align-top` }}, sizeControls.length ? [D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, sizeControls )] : [D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, ['—'])]),
              D.Tables.Td({ attrs:{ class: tw`px-3 py-3 align-top text-center` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'nullable', type:'checkbox', checked: row.nullable !== false } })
              ]),
              D.Tables.Td({ attrs:{ class: tw`px-3 py-3 align-top text-center` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'primaryKey', type:'checkbox', checked: !!row.primaryKey } })
              ]),
              D.Tables.Td({ attrs:{ class: tw`px-3 py-3 align-top` }}, [
                UI.Input({ attrs:{ gkey:'erd:columns:update', 'data-row': key, 'data-field':'defaultValue', value: row.defaultValue || '', placeholder:t('modal.columns.default.placeholder', 'القيمة الافتراضية') } })
              ]),
              D.Tables.Td({ attrs:{ class: tw`px-3 py-3 align-top` }}, referenceControls),
              D.Tables.Td({ attrs:{ class: tw`px-3 py-3 align-top` }}, [quickActions])
            ]);
          })
        : [
            D.Tables.Tr({ attrs:{ class: tw`bg-[var(--surface-1)]` }}, [
              D.Tables.Td({ attrs:{ class: tw`px-3 py-3 text-sm text-[var(--muted)]`, colspan: columnHeaders.length }}, [t('modal.columns.noColumns', 'لا توجد أعمدة بعد لهذا الجدول.')])
            ])
          ];
      const columnsTable = D.Tables.Table({ attrs:{ class: tw`w-full text-sm border-separate [border-spacing:0_8px] align-top` }}, [
        D.Tables.Thead({}, [columnHeaderRow]),
        D.Tables.Tbody({}, columnBodyRows)
      ]);
      const columnsHeader = D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2 md:flex-row md:items-center md:justify-between` }}, [
        D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [
          currentTableName
            ? t('modal.columns.header.withName', `أعمدة الجدول: ${formatIdentifier(currentTableName)}`).replace('{name}', formatIdentifier(currentTableName))
            : t('modal.columns.header', 'أعمدة الجدول')
        ])
      ]);
      const addColumnButton = UI.Button({
        attrs:{ gkey:'erd:columns:add-row', 'data-table': currentTableName || '' },
        variant:'soft',
        size:'sm'
      }, [`➕ ${t('modal.columns.addColumn', 'عمود جديد')}`]);
      const columnsFooter = D.Containers.Div({ attrs:{ class: tw`flex justify-end pt-2` }}, [addColumnButton]);
      const columnsSection = D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)]/70 bg-[var(--surface-1)]/80 p-4 space-y-3` }}, [
        columnsHeader,
        D.Containers.Div({ attrs:{ class: tw`overflow-auto` }}, [columnsTable]),
        columnsFooter
      ]);
      const indexes = getTableIndexes(currentTable);
      const uniqueConstraints = indexes.filter(index => index.unique);
      const nonUniqueIndexes = indexes.filter(index => !index.unique);
      const uniqueContent = uniqueConstraints.length
        ? D.Tables.Table({ attrs:{ class: tw`w-full text-sm border-separate [border-spacing:0_6px]` }}, [
            D.Tables.Thead({}, [D.Tables.Tr({}, [
              D.Tables.Th({ attrs:{ class: tw`px-3 py-2 text-xs font-semibold text-[var(--muted-foreground)] text-right` }}, [t('modal.columns.table.header.name', 'الاسم')]),
              D.Tables.Th({ attrs:{ class: tw`px-3 py-2 text-xs font-semibold text-[var(--muted-foreground)] text-right` }}, [t('modal.columns.unique.modal.columns', 'الأعمدة المرتبطة')]),
              D.Tables.Th({ attrs:{ class: tw`px-3 py-2 text-xs font-semibold text-[var(--muted-foreground)] text-right` }}, [t('modal.columns.table.header.actions', 'إجراءات')])
            ])]),
            D.Tables.Tbody({}, uniqueConstraints.map(index => {
              const list = (index.columns || []).map(col => formatIdentifier(col)).join(', ') || '—';
              const indexId = index.name || (Array.isArray(index.columns) ? index.columns.join('__') : '');
              return D.Tables.Tr({ attrs:{ key:`unique-${indexId || 'unnamed'}`, class: tw`bg-[var(--surface-1)]` }}, [
                D.Tables.Td({ attrs:{ class: tw`px-3 py-2 text-sm font-semibold` }}, [formatIdentifier(index.name || '') || '—']),
                D.Tables.Td({ attrs:{ class: tw`px-3 py-2 text-sm` }}, [list || '—']),
                D.Tables.Td({ attrs:{ class: tw`px-3 py-2 text-sm` }}, [
                  D.Containers.Div({ attrs:{ class: tw`flex items-center justify-end gap-2` }}, [
                    UI.Button({ attrs:{ gkey:'erd:columns:unique:open', 'data-table': currentTableName, 'data-index': indexId, class: tw`!px-2 !py-1 text-xs` }, variant:'ghost', size:'xs' }, [t('modal.columns.unique.edit', 'تعديل')]),
                    UI.Button({ attrs:{ gkey:'erd:columns:unique:delete', 'data-table': currentTableName, 'data-index': indexId, class: tw`!px-2 !py-1 text-xs text-[var(--destructive)]` }, variant:'ghost', size:'xs' }, [t('modal.columns.unique.delete', 'حذف')])
                  ])
                ])
              ]);
            }))
          ])
        : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [t('modal.columns.unique.empty', 'لا توجد قيود فريدة لهذا الجدول.')]);
      const uniqueSection = D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)]/70 bg-[var(--surface-1)]/80 p-4 space-y-3` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2 md:flex-row md:items-center md:justify-between` }}, [
          D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [t('modal.columns.section.unique', 'القيود الفريدة')]),
          UI.Button({ attrs:{ gkey:'erd:columns:unique:open', 'data-table': currentTableName || '', class: tw`w-full md:w-auto` }, variant:'soft', size:'sm' }, [`➕ ${t('modal.columns.unique.add', 'إضافة قيد فريد')}`])
        ]),
        uniqueContent
      ]);
      const indexContent = nonUniqueIndexes.length
        ? D.Tables.Table({ attrs:{ class: tw`w-full text-sm border-separate [border-spacing:0_6px]` }}, [
            D.Tables.Thead({}, [D.Tables.Tr({}, [
              D.Tables.Th({ attrs:{ class: tw`px-3 py-2 text-xs font-semibold text-[var(--muted-foreground)] text-right` }}, [t('modal.columns.table.header.name', 'الاسم')]),
              D.Tables.Th({ attrs:{ class: tw`px-3 py-2 text-xs font-semibold text-[var(--muted-foreground)] text-right` }}, [t('modal.columns.index.modal.columns', 'الأعمدة المرتبطة')]),
              D.Tables.Th({ attrs:{ class: tw`px-3 py-2 text-xs font-semibold text-[var(--muted-foreground)] text-right` }}, [t('modal.columns.index.modal.method', 'طريقة الفهرسة')]),
              D.Tables.Th({ attrs:{ class: tw`px-3 py-2 text-xs font-semibold text-[var(--muted-foreground)] text-right` }}, [t('modal.columns.index.modal.where', 'شرط التصفية (اختياري)')]),
              D.Tables.Th({ attrs:{ class: tw`px-3 py-2 text-xs font-semibold text-[var(--muted-foreground)] text-right` }}, [t('modal.columns.table.header.actions', 'إجراءات')])
            ])]),
            D.Tables.Tbody({}, nonUniqueIndexes.map(index => {
              const list = (index.columns || []).map(col => formatIdentifier(col)).join(', ') || '—';
              const indexId = index.name || (Array.isArray(index.columns) ? index.columns.join('__') : '');
              return D.Tables.Tr({ attrs:{ key:`index-${indexId || 'unnamed'}`, class: tw`bg-[var(--surface-1)]` }}, [
                D.Tables.Td({ attrs:{ class: tw`px-3 py-2 text-sm font-semibold` }}, [formatIdentifier(index.name || '') || '—']),
                D.Tables.Td({ attrs:{ class: tw`px-3 py-2 text-sm` }}, [list || '—']),
                D.Tables.Td({ attrs:{ class: tw`px-3 py-2 text-sm` }}, [index.method ? String(index.method).toUpperCase() : 'BTREE']),
                D.Tables.Td({ attrs:{ class: tw`px-3 py-2 text-sm` }}, [index.where || '—']),
                D.Tables.Td({ attrs:{ class: tw`px-3 py-2 text-sm` }}, [
                  D.Containers.Div({ attrs:{ class: tw`flex items-center justify-end gap-2` }}, [
                    UI.Button({ attrs:{ gkey:'erd:columns:index:open', 'data-table': currentTableName, 'data-index': indexId, class: tw`!px-2 !py-1 text-xs` }, variant:'ghost', size:'xs' }, [t('modal.columns.indexes.edit', 'تعديل')]),
                    UI.Button({ attrs:{ gkey:'erd:columns:index:delete', 'data-table': currentTableName, 'data-index': indexId, class: tw`!px-2 !py-1 text-xs text-[var(--destructive)]` }, variant:'ghost', size:'xs' }, [t('modal.columns.indexes.delete', 'حذف')])
                  ])
                ])
              ]);
            }))
          ])
        : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [t('modal.columns.indexes.empty', 'لا توجد فهارس إضافية لهذا الجدول.')]);
      const indexSection = D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)]/70 bg-[var(--surface-1)]/80 p-4 space-y-3` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2 md:flex-row md:items-center md:justify-between` }}, [
          D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [t('modal.columns.section.indexes', 'الفهارس')]),
          UI.Button({ attrs:{ gkey:'erd:columns:index:open', 'data-table': currentTableName || '', class: tw`w-full md:w-auto` }, variant:'soft', size:'sm' }, [`➕ ${t('modal.columns.indexes.add', 'إضافة فهرس')}`])
        ]),
        indexContent
      ]);
      return UI.Modal({
        open,
        size:'full',
        title:t('modal.columns.title', 'محرر الأعمدة'),
        description:t('modal.columns.description', 'تحكم في أعمدة الجدول المحدد بسرعة عبر واجهة واحدة.'),
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 xl:grid-cols-[260px_minmax(0,1fr)] gap-4` }}, [
            D.Containers.Div({ attrs:{ class: tw`rounded-2xl border border-[var(--border)]/70 bg-[var(--surface-2)]/60 p-3 space-y-3` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [t('modal.columns.tables', 'الجداول')]),
              D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2 max-h-[70vh] overflow-y-auto pr-1` }}, [tableNav])
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-4` }}, [
              columnsSection,
              uniqueSection,
              indexSection
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:columns:save', variant:'solid', size:'sm' }}, [t('modal.columns.save', 'حفظ الأعمدة')]),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('modal.close', 'إغلاق')])
        ]
      });
    }

    function ModalColumnsUniqueEditor(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.columnsUnique;
      if(!open) return null;
      const form = db.ui?.form?.columnsUnique || {};
      const registry = getRegistry(db);
      const table = form.table ? registry.get(form.table) : null;
      const selectedColumns = Array.isArray(form.columns) ? form.columns : [];
      const tableColumns = table && Array.isArray(table.fields)
        ? table.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name), type: field.type }))
        : [];
      const columnChecklist = tableColumns.length
        ? D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2` }}, tableColumns.map((col, idx) => {
            const inputId = `unique-${col.value}-${idx}`;
            const checked = selectedColumns.includes(col.value);
            return D.Containers.Div({ attrs:{ class: tw`flex items-center gap-2 rounded-xl border border-[var(--border)]/60 bg-[var(--surface-0)]/80 px-3 py-2` }}, [
              UI.Input({ attrs:{ id: inputId, gkey:'erd:columns:unique:toggle', 'data-column': col.value, type:'checkbox', checked } }),
              UI.Label({ attrs:{ class: tw`text-sm` }, forId: inputId, text:`${col.label || formatIdentifier(col.value)} (${col.type})` })
            ]);
          }))
        : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [t('modal.columns.noColumns', 'لا توجد أعمدة بعد لهذا الجدول.')]);
      return UI.Modal({
        open,
        size:'lg',
        title:t('modal.columns.unique.modal.title', 'قيد فريد'),
        description:t('modal.columns.unique.modal.description', 'حدد الأعمدة التي يجب أن تكون قيمها فريدة.'),
        closeGkey:'erd:columns:unique:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`space-y-4` }}, [
            UI.Input({ attrs:{ gkey:'erd:columns:unique:update', 'data-field':'name', value: form.name || '', placeholder:t('modal.columns.unique.modal.name', 'اسم القيد') } }),
            D.Containers.Div({ attrs:{ class: tw`space-y-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [t('modal.columns.unique.modal.columns', 'الأعمدة المرتبطة')]),
              columnChecklist
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:columns:unique:save', variant:'solid', size:'sm' }}, [t('modal.columns.unique.save', 'حفظ القيد')]),
          UI.Button({ attrs:{ gkey:'erd:columns:unique:close', variant:'ghost', size:'sm' }}, [t('modal.close', 'إغلاق')])
        ]
      });
    }

    function ModalColumnsIndexEditor(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.columnsIndex;
      if(!open) return null;
      const form = db.ui?.form?.columnsIndex || {};
      const registry = getRegistry(db);
      const table = form.table ? registry.get(form.table) : null;
      const selectedColumns = Array.isArray(form.columns) ? form.columns : [];
      const tableColumns = table && Array.isArray(table.fields)
        ? table.fields.map(field => ({ value: field.name, label: formatIdentifier(field.name), type: field.type }))
        : [];
      const methodOptions = INDEX_METHOD_OPTIONS.map(method => ({ value: method, label: method.toUpperCase() }));
      const columnChecklist = tableColumns.length
        ? D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2` }}, tableColumns.map((col, idx) => {
            const inputId = `index-${col.value}-${idx}`;
            const checked = selectedColumns.includes(col.value);
            return D.Containers.Div({ attrs:{ class: tw`flex items-center gap-2 rounded-xl border border-[var(--border)]/60 bg-[var(--surface-0)]/80 px-3 py-2` }}, [
              UI.Input({ attrs:{ id: inputId, gkey:'erd:columns:index:toggle', 'data-column': col.value, type:'checkbox', checked } }),
              UI.Label({ attrs:{ class: tw`text-sm` }, forId: inputId, text:`${col.label || formatIdentifier(col.value)} (${col.type})` })
            ]);
          }))
        : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [t('modal.columns.noColumns', 'لا توجد أعمدة بعد لهذا الجدول.')]);
      return UI.Modal({
        open,
        size:'lg',
        title:t('modal.columns.index.modal.title', 'فهرس جديد'),
        description:t('modal.columns.index.modal.description', 'اختر الأعمدة وطريقة الفهرسة المفضلة.'),
        closeGkey:'erd:columns:index:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`space-y-4` }}, [
            UI.Input({ attrs:{ gkey:'erd:columns:index:update', 'data-field':'name', value: form.name || '', placeholder:t('modal.columns.index.modal.name', 'اسم الفهرس') } }),
            D.Containers.Div({ attrs:{ class: tw`space-y-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [t('modal.columns.index.modal.method', 'طريقة الفهرسة')]),
              UI.Select({ attrs:{ gkey:'erd:columns:index:update', 'data-field':'method', value: form.method || 'btree' }, options: methodOptions })
            ]),
            UI.Input({ attrs:{ gkey:'erd:columns:index:update', 'data-field':'where', value: form.where || '', placeholder:t('modal.columns.index.modal.where', 'شرط التصفية (اختياري)') } }),
            D.Containers.Div({ attrs:{ class: tw`space-y-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [t('modal.columns.index.modal.columns', 'الأعمدة المرتبطة')]),
              columnChecklist
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:columns:index:save', variant:'solid', size:'sm' }}, [t('modal.columns.index.save', 'حفظ الفهرس')]),
          UI.Button({ attrs:{ gkey:'erd:columns:index:close', variant:'ghost', size:'sm' }}, [t('modal.close', 'إغلاق')])
        ]
      });
    }

    function ModalClassificationBulk(db){
      const t = createTranslator(db);
      const open = db.ui?.modals?.classification;
      const form = db.ui?.form?.classification || {};
      const text = form.bulkText || '';
      return UI.Modal({
        open,
        size:'lg',
        title:t('modal.classification.title', 'إدارة ترميز الشجرة'),
        description:t('modal.classification.description', 'حرر قائمة الفئات بصيغة JSON (code، name، parent).'),
        closeGkey:'erd:modal:close',
        content:[
          JsonEditorTabs(db, {
            id:'classification',
            text,
            gkey:'erd:classes:update-bulk',
            formKey:'classification',
            fieldKey:'bulkText',
            placeholder:t('modal.classification.placeholder', '[{"code":"01","name":"Root","parent":null}]'),
            height:384,
            rows:22,
            t
          })
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:classes:apply-bulk', variant:'solid', size:'sm' }}, [t('modal.classification.apply', 'تطبيق')]),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, [t('common.cancel', 'إلغاء')])
        ]
      });
    }

    function buildContextMenuSections(menu, db){
      const sections = [];
      const registry = getRegistry(db);
      const hiddenTables = new Set((db.ui?.hiddenTables || []).map(name => String(name)));
      const t = createTranslator(db);
      if(menu.type === 'canvas'){
        sections.push({
          label:t('context.section.schema', 'المخطط'),
          items:[
            { id:'canvas:new-table', label:'Create New Table | إنشاء جدول', icon:'➕' },
            { id:'canvas:auto-layout', label:'Auto-Layout', icon:'📐' },
            { id:'canvas:fit', label:'Fit to Screen', icon:'🗺️' },
            { id:'canvas:paste', label:'Paste', icon:'📋' },
            { id:'canvas:import', label:'Import…', icon:'⬇️' }
          ]
        });
        return sections;
      }
      if(menu.type === 'table'){
        const table = menu.table ? registry.get(menu.table) : null;
        const tableLabel = table ? formatIdentifier(table.name) : (menu.table || 'جدول');
        const isHidden = menu.table && hiddenTables.has(menu.table);
        sections.push({
          label:`${tableLabel}`,
          items:[
            { id:'table:rename', label:t('context.table.rename', 'إعادة تسمية الجدول'), icon:'✏️', table: menu.table },
            { id:'table:duplicate', label:t('context.table.duplicate', 'تكرار الجدول'), icon:'🧬', table: menu.table },
            { id:'table:delete', label:t('context.table.delete', 'حذف الجدول'), icon:'🗑️', table: menu.table }
          ]
        });
        sections.push({
          label:t('context.section.structure', 'البنية'),
          items:[
            { id:'table:columns', label:t('context.table.columns', 'إدارة الأعمدة'), icon:'🗂️', table: menu.table },
            { id:'table:add-unique', label:t('context.table.addUnique', 'إضافة قيد فريد'), icon:'☆', table: menu.table },
            { id:'table:add-index', label:t('context.table.addIndex', 'إضافة فهرس'), icon:'#', table: menu.table },
            { id:'table:generate-fk', label:t('context.table.generateFk', 'توليد علاقة خارجية'), icon:'🔗', table: menu.table }
          ]
        });
        sections.push({
          label:t('context.section.outputs', 'المخرجات'),
          items:[
            { id:'table:export-sql', label:t('context.table.exportSql', 'تصدير هذا الجدول (SQL)'), icon:'💾', table: menu.table },
            { id:'table:export-json', label:t('context.table.exportJson', 'تصدير هذا الجدول (JSON)'), icon:'📤', table: menu.table },
            { id:'table:toggle-visibility', label: isHidden ? t('context.table.show', 'إظهار في المشهد') : t('context.table.hide', 'إخفاء في المشهد'), icon: isHidden ? '👁️' : '🚫', table: menu.table }
          ]
        });
        return sections;
      }
      if(menu.type === 'field'){
        const table = menu.table ? registry.get(menu.table) : null;
        const field = table && menu.field ? table.getField(menu.field) : null;
        const label = field ? formatIdentifier(field.name) : (menu.field || 'حقل');
        sections.push({
          label:`${label}`,
          items:[
            { id:'field:rename', label:t('context.field.rename', 'إعادة تسمية الحقل'), icon:'✏️', table: menu.table, field: menu.field },
            { id:'field:type', label:t('context.field.type', 'تغيير نوع الحقل'), icon:'🔄', table: menu.table, field: menu.field },
            { id:'field:length', label:t('context.field.length', 'ضبط الطول/الدقة'), icon:'📏', table: menu.table, field: menu.field }
          ]
        });
        if(field){
          sections.push({
            label:t('context.field.properties', 'الخصائص'),
            items:[
              { id:'field:pk', label: field.primaryKey ? t('context.field.pk.remove', 'إلغاء المفتاح الأساسي') : t('context.field.pk.add', 'تعيين كمفتاح أساسي'), icon:'🔑', table: menu.table, field: menu.field },
              { id:'field:null', label: field.nullable === false ? t('context.field.null.allow', 'السماح بالقيم الفارغة') : t('context.field.null.disallow', 'فرض Not Null'), icon:'∅', table: menu.table, field: menu.field },
              { id:'field:unique', label: field.unique ? t('context.field.unique.remove', 'إزالة من القيد الفريد') : t('context.field.unique.add', 'إضافة إلى القيد الفريد'), icon:'☆', table: menu.table, field: menu.field },
              { id:'field:index', label: field.index ? t('context.field.index.remove', 'إزالة من الفهرس') : t('context.field.index.add', 'إضافة إلى الفهرس'), icon:'#', table: menu.table, field: menu.field }
            ]
          });
        }
        sections.push({
          label:t('context.section.relationships', 'العلاقات'),
          items:[
            { id:'field:create-fk', label:t('context.field.createFk', 'Create FK from this field'), icon:'🔗', table: menu.table, field: menu.field }
          ]
        });
        return sections;
      }
      return sections;
    }

    function ContextMenu(db){
      const menu = db.ui?.contextMenu || {};
      if(!menu.open) return null;
      const sections = buildContextMenuSections(menu, db).filter(section => Array.isArray(section.items) && section.items.length);
      if(!sections.length) return null;
      const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : 0;
      const viewportHeight = typeof window !== 'undefined' ? window.innerHeight : 0;
      const menuWidth = 260;
      const estimatedHeight = Math.max(180, sections.reduce((total, section)=>{
        const count = (section.items || []).length;
        return total + (section.label ? 32 : 0) + count * 36 + 16;
      }, 0));
      const margin = 12;
      const safeLeft = viewportWidth
        ? Math.max(margin, Math.min(menu.x, viewportWidth - menuWidth - margin))
        : menu.x;
      const safeTop = viewportHeight
        ? Math.max(margin, Math.min(menu.y, viewportHeight - estimatedHeight - margin))
        : menu.y;
      const sectionNodes = sections.map(section => {
        const header = section.label
          ? D.Text.Span({ attrs:{ class: tw`px-2 text-[11px] font-semibold uppercase tracking-[0.18em] text-[var(--muted)]` }}, [section.label])
          : null;
        const items = section.items.map(item => UI.Button({
          attrs:{
            gkey:'erd:context:action',
            'data-action': item.id,
            'data-table': item.table || menu.table || '',
            'data-field': item.field || menu.field || '',
            class: tw`w-full justify-start gap-2`
          },
          disabled: !!item.disabled,
          variant:'ghost',
          size:'sm'
        }, [
          item.icon ? D.Text.Span({ attrs:{ class: tw`text-base` }}, [item.icon]) : null,
          D.Text.Span({ attrs:{ class: tw`text-sm` }}, [item.label])
        ].filter(Boolean)));
        return D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-1` }}, [header, ...items.filter(Boolean)].filter(Boolean));
      });
      return D.Containers.Div({ attrs:{ class: tw`absolute inset-0 pointer-events-none` }}, [
        D.Containers.Div({ attrs:{ class: tw`absolute inset-0 pointer-events-auto`, gkey:'erd:context:close' }}, []),
        D.Containers.Div({ attrs:{ class: tw`absolute pointer-events-auto`, style:`left:${Math.round(safeLeft)}px;top:${Math.round(safeTop)}px;` }}, [
          D.Containers.Div({ attrs:{ class: tw`min-w-[220px] max-w-[280px] rounded-2xl border border-[var(--border)] bg-[var(--surface-1)]/[0.98] p-2 shadow-2xl backdrop-blur-md flex flex-col gap-2` }}, sectionNodes)
        ])
      ]);
    }

    function Modals(db){
      return [
        ModalImport(db),
        ModalExportJson(db),
        ModalExportSql(db),
        ModalSchemaMeta(db),
        ModalAddTable(db),
        ModalAddField(db),
        ModalRelation(db),
        ModalColumnsManager(db),
        ModalColumnsUniqueEditor(db),
        ModalColumnsIndexEditor(db),
        ModalClassificationBulk(db)
      ];
    }

    function OverlayLayer(children){
      const nodes = Array.isArray(children) ? children.filter(Boolean) : [];
      if(!nodes.length) return null;
      return D.Containers.Div({ attrs:{ id:'erd-overlay-root', class: tw`fixed inset-0 pointer-events-none z-[2147483000]` }}, nodes);
    }

    function AppView(db){
      const toolbarResult = Toolbar(db);
      const toolbarView = toolbarResult && toolbarResult.view ? toolbarResult.view : toolbarResult;
      const toolbarOverlays = (toolbarResult && Array.isArray(toolbarResult.overlays) ? toolbarResult.overlays : []).filter(Boolean);
      const panels = db.ui?.panels || {};
      const libraryOpen = panels.libraryOpen !== false;
      const classificationOpen = panels.classificationOpen !== false;
      const libraryPanel = libraryOpen ? SchemaLibraryPanel(db) : null;
      const classificationPanel = classificationOpen ? SchemaClassificationPanel(db) : null;
      const collapsedButtons = [];
      if(!classificationOpen) collapsedButtons.push(CollapsedPanelReveal(db, 'classification'));
      const overlayNodes = [
        ...toolbarOverlays,
        ContextMenu(db),
        ...Modals(db)
      ].filter(Boolean);
      const overlayRoot = OverlayLayer(overlayNodes);
      return D.Containers.Div({ attrs:{ class: tw`flex h-screen w-full flex-col bg-[var(--surface-0)] text-[var(--foreground)]` }}, [
        toolbarView,
        D.Containers.Div({ attrs:{ class: tw`flex flex-1 min-h-0 w-full` }}, [
          libraryPanel,
          D.Containers.Div({ attrs:{ class: tw`relative flex flex-1 flex-col min-h-0` }}, [
            SchemaCanvas(db),
            ...collapsedButtons
          ].filter(Boolean)),
          classificationPanel
        ].filter(Boolean)),
        overlayRoot
      ].filter(Boolean));
    }

    const erdOrders = {
      'erd.fit':{
        on:['click'],
        gkeys:['erd:fit'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.fitToScreen === 'function'){
            try { driver.fitToScreen(16); }
            catch(error){ console.warn('[Mishkah][ERD] fit failed', error); }
          } else {
            UI.pushToast(ctx, { title:'لم يتم تفعيل أداة الرسم بعد', icon:'⚠️' });
          }
        }
      },
      'erd.undo':{
        on:['click'],
        gkeys:['erd:undo'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.undo === 'function'){
            try { driver.undo(); }
            catch(error){ console.warn('[Mishkah][ERD] undo failed', error); }
          }
        }
      },
      'erd.redo':{
        on:['click'],
        gkeys:['erd:redo'],
        handler:(e,ctx)=>{
          const driver = ensureDriverInstance(ctx.getState());
          if(driver && typeof driver.redo === 'function'){
            try { driver.redo(); }
            catch(error){ console.warn('[Mishkah][ERD] redo failed', error); }
          }
        }
      },
      'erd.zoom.in':{
        on:['click'],
        gkeys:['erd:zoom:in'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.min(MAX_CANVAS_ZOOM, (s.data.canvas?.zoom || 1) + 0.1);
            const canvas = { ...(s.data.canvas || {}), zoom, mode:'manual' };
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas,
              classes: s.data.classes || [],
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.out':{
        on:['click'],
        gkeys:['erd:zoom:out'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.max(MIN_CANVAS_ZOOM, (s.data.canvas?.zoom || 1) - 0.1);
            const canvas = { ...(s.data.canvas || {}), zoom, mode:'manual' };
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas,
              classes: s.data.classes || [],
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.reset':{
        on:['click'],
        gkeys:['erd:zoom:reset'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const canvas = { ...(s.data.canvas || {}), zoom:1, mode:'auto' };
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas,
              classes: s.data.classes || [],
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.toolbar.export.toggle':{
        on:['click'],
        gkeys:['erd:toolbar:export'],
        handler:(e,ctx)=>{
          let anchor = null;
          const rawTarget = e ? (e.target || e.currentTarget) : null;
          const button = rawTarget && typeof rawTarget.closest === 'function'
            ? rawTarget.closest('button')
            : (e && e.currentTarget && e.currentTarget.nodeType === 1 ? e.currentTarget : null);
          if(button && typeof button.getBoundingClientRect === 'function'){
            const rect = button.getBoundingClientRect();
            const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : null;
            anchor = {
              top: rect.bottom,
              left: rect.left,
              right: viewportWidth != null ? Math.max(0, viewportWidth - rect.right) : null,
              width: rect.width
            };
          }
          ctx.setState(s=>{
            const currentOpen = s.ui?.toolbar?.exportOpen;
            const nextOpen = !currentOpen;
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                toolbar:{
                  ...(s.ui?.toolbar || {}),
                  exportOpen: nextOpen,
                  exportAnchor: nextOpen ? anchor : null
                }
              }
            };
          });
          
        }
      },
      'erd.toolbar.export.close':{
        on:['click'],
        gkeys:['erd:toolbar:export:close'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              toolbar:{ ...(s.ui?.toolbar || {}), exportOpen:false, exportAnchor:null }
            }
          }));
          
        }
      },
      'erd.export.run':{
        on:['click'],
        gkeys:['erd:export:run'],
        handler: async (e,ctx)=>{
          const target = e.target.closest('[data-format]');
          if(!target) return;
          const format = target.getAttribute('data-format') || '';
          const dialect = target.getAttribute('data-dialect') || '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              toolbar:{ ...(s.ui?.toolbar || {}), exportOpen:false, exportAnchor:null }
            }
          }));
          
          const state = ctx.getState();
          if(format === 'svg'){
            const driver = ensureDriverInstance(state);
            if(!driver || typeof driver.exportSVG !== 'function'){
              UI.pushToast(ctx, { title:'سائق الرسم لا يدعم تصدير SVG', icon:'⚠️' });
              return;
            }
            try{
              const svg = await driver.exportSVG();
              const blob = svg instanceof Blob ? svg : new Blob([svg], { type:'image/svg+xml' });
              const url = URL.createObjectURL(blob);
              const link = document.createElement('a');
              const name = state.data?.schemaMeta?.name || 'schema';
              link.href = url;
              link.download = `${name}.svg`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);
              UI.pushToast(ctx, { title:'تم تصدير الرسم بصيغة SVG', icon:'✅' });
            } catch(error){
              console.warn('[Mishkah][ERD] export SVG failed', error);
              UI.pushToast(ctx, { title:'تعذر تصدير SVG', message:String(error), icon:'🛑' });
            }
            return;
          }
          if(format === 'png'){
            const driver = ensureDriverInstance(state);
            if(!driver || typeof driver.exportPNG !== 'function'){
              UI.pushToast(ctx, { title:'سائق الرسم لا يدعم تصدير PNG', icon:'⚠️' });
              return;
            }
            try{
              const blob = await driver.exportPNG({ background: currentPalette().background || '#ffffff' });
              const url = URL.createObjectURL(blob);
              const link = document.createElement('a');
              const name = state.data?.schemaMeta?.name || 'schema';
              link.href = url;
              link.download = `${name}.png`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);
              UI.pushToast(ctx, { title:'تم تصدير الرسم بصيغة PNG', icon:'✅' });
            } catch(error){
              console.warn('[Mishkah][ERD] export PNG failed', error);
              UI.pushToast(ctx, { title:'تعذر تصدير PNG', message:String(error), icon:'🛑' });
            }
            return;
          }
          if(format === 'json'){
            const payload = {
              name: state.data.schemaMeta?.name || '',
              title: state.data.schemaMeta?.title || '',
              description: state.data.schemaMeta?.description || '',
              schema: state.data.schema,
              layout: state.data.layout,
              canvas: state.data.canvas,
              createdAt: state.data.schemaCreatedAt,
              updatedAt: state.data.schemaUpdatedAt,
            };
            ctx.setState(s=>({
              ...s,
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), exportJson:true },
                form:{ ...(s.ui?.form || {}), export:{ text: JSON.stringify(payload, null, 2) } }
              }
            }));
            
            return;
          }
          if(format === 'sql'){
            const registry = getRegistry(state);
            let sql = '';
            try {
              sql = registry.generateSQL({ schemaName:'public', dialect: dialect || 'postgres' });
            } catch(error){
              console.warn('[Mishkah][ERD] generateSQL failed', error);
              sql = registry.generateSQL({ schemaName:'public' });
            }
            ctx.setState(s=>({
              ...s,
              data:{ ...s.data, sqlPreview: sql },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), exportSql:true },
                form:{ ...(s.ui?.form || {}), sql:{ text: sql } }
              }
            }));
            
            return;
          }
        }
      },
      'erd.table.select':{
        on:['click'],
        gkeys:['erd:table:select'],
        handler:(e,ctx)=>{
          const card = e.target.closest('[data-table-name]');
          if(!card) return;
          const tableName = card.getAttribute('data-table-name');
          ctx.setState(s => withTableSelection(s, tableName));
          
        }
      },
      'erd.field.select':{
        on:['click'],
        gkeys:['erd:field:select'],
        handler:(e,ctx)=>{
          const row = e.target.closest('[data-field-name]');
          if(!row) return;
          const tableName = row.getAttribute('data-table-name');
          const fieldName = row.getAttribute('data-field-name');
          ctx.setState(s => withFieldSelection(s, tableName, fieldName));
          
        }
      },
      'erd.import.open':{
        on:['click'],
        gkeys:['erd:import:open'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas,
            classes: state.data.classes || []
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), import:true },
              form:{ ...(s.ui?.form || {}), import:{ name: payload.name, title: payload.title, targetId: s.data.schemaId || '', text: JSON.stringify(payload, null, 2) } }
            }
          }));
          
        }
      },
      'erd.modal.close':{
        on:['click'],
        gkeys:['erd:modal:close','ui:modal:close'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false, columns:false, columnsUnique:false, columnsIndex:false, classification:false } }
          }));
          
        }
      },
        'erd.template.toggle':{
          on:['click'],
          gkeys:['erd:template:toggle'],
          handler:(e,ctx)=>{
            const target = e?.target ? e.target.closest('[data-next-state]') : null;
            const desired = target ? target.getAttribute('data-next-state') : null;
            let changed = false;
            let nextOpen = null;
            ctx.setState(s=>{
              const currentOpen = s.ui?.template?.open !== false;
              const requested = desired === 'open' ? true : desired === 'closed' ? false : !currentOpen;
              if(requested === currentOpen){
                nextOpen = currentOpen;
                return s;
              }
              changed = true;
              nextOpen = requested;
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  template:{ ...(s.ui?.template || {}), open: requested }
                }
              };
            });

            if(changed){
              persistTemplatePreference(nextOpen);
            }
          }
        },
        'erd.panel.library.toggle':{
          on:['click'],
          gkeys:['erd:panel:library:toggle'],
          handler:(e,ctx)=>{
            if(e){
              if(typeof e.preventDefault === 'function') e.preventDefault();
              if(typeof e.stopPropagation === 'function') e.stopPropagation();
            }
            const target = e?.target ? e.target.closest('[data-next-state]') : null;
            const desired = target ? target.getAttribute('data-next-state') : null;
            let changed = false;
            let nextOpen = null;
            ctx.setState(s=>{
              const currentOpen = s.ui?.panels?.libraryOpen !== false;
              const requested = desired === 'open' ? true : desired === 'closed' ? false : !currentOpen;
              if(requested === currentOpen){
                nextOpen = currentOpen;
                return s;
              }
              changed = true;
              nextOpen = requested;
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  panels:{ ...(s.ui?.panels || {}), libraryOpen: requested }
                }
              };
            });

            if(!changed) return;

            persistPanelPreference('libraryOpen', nextOpen);
            const rerender = ()=> scheduleDiagramRender(ctx.getState());
            if(typeof requestAnimationFrame === 'function'){
              requestAnimationFrame(rerender);
            } else {
              setTimeout(rerender, 16);
            }
          }
        },
        'erd.panel.classification.toggle':{
          on:['click'],
          gkeys:['erd:panel:classification:toggle'],
          handler:(e,ctx)=>{
            let nextOpen = false;
            ctx.setState(s=>{
              const currentOpen = s.ui?.panels?.classificationOpen !== false;
              nextOpen = !currentOpen;
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  panels:{ ...(s.ui?.panels || {}), classificationOpen: nextOpen }
                }
              };
            });

            persistPanelPreference('classificationOpen', nextOpen);
            const snapshot = ctx.getState();
            scheduleDiagramRender(snapshot);
          }
        },
        'erd.json.tab':{
          on:['click'],
          gkeys:['erd:json:tab'],
          handler:(e,ctx)=>{
            const target = e?.target ? e.target.closest('[data-editor-mode]') : null;
            if(!target) return;
            const editorId = target.getAttribute('data-editor-id');
            const mode = target.getAttribute('data-editor-mode');
            if(!editorId || (mode !== 'viewer' && mode !== 'editor')) return;
            ctx.setState(s=>{
              const currentEditors = s.ui?.jsonEditors || {};
              const currentMode = currentEditors[editorId]?.mode;
              if(currentMode === mode) return s;
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  jsonEditors:{
                    ...currentEditors,
                    [editorId]:{ ...(currentEditors[editorId] || {}), mode }
                  }
                }
              };
            });
            scheduleJsonEditorRefresh(document);
          }
        },
        'erd.json.copy':{
          on:['click'],
          gkeys:['erd:json:copy'],
          handler:async (e,ctx)=>{
            if(e?.preventDefault) e.preventDefault();
            const container = e?.target ? e.target.closest('[data-json-editor]') : null;
            if(!container) return;
            const textarea = container.querySelector('textarea[data-codemirror="json"]');
            let text = textarea ? (textarea.value || '') : '';
            if((!text || !text.trim()) && container){
              const viewer = container.querySelector('[data-json-source="viewer"]');
              if(viewer){
                const attr = viewer.getAttribute('data-json-text');
                if(attr){
                  text = decodeJsonAttribute(attr);
                } else {
                  const raw = viewer.getAttribute('data-json-raw');
                  text = typeof raw === 'string' ? raw : (viewer.textContent || '');
                }
              }
            }
            const state = ctx.getState();
            const t = createTranslator(state);
            if(!text || !text.trim()){
              UI.pushToast(ctx, { title:t('json.copy.unavailable', 'لا يوجد نص لنسخه'), icon:'⚠️' });
              return;
            }
            try{
              if(navigator?.clipboard && typeof navigator.clipboard.writeText === 'function'){
                await navigator.clipboard.writeText(text);
              } else {
                const temp = document.createElement('textarea');
                temp.value = text;
                temp.setAttribute('readonly', '');
                temp.style.position = 'absolute';
                temp.style.left = '-9999px';
                document.body.appendChild(temp);
                temp.select();
                document.execCommand('copy');
                document.body.removeChild(temp);
              }
              UI.pushToast(ctx, { title:t('json.copy.success', 'تم نسخ JSON إلى الحافظة'), icon:'📋' });
            } catch(error){
              UI.pushToast(ctx, { title:t('json.copy.error', 'تعذر نسخ JSON'), message:String(error), icon:'🛑' });
            }
          }
        },
        'erd.form.update':{
          on:['input','change'],
          gkeys:['erd:form:update'],
          handler:(e,ctx)=>{
            const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          const parent = input.getAttribute('data-parent');
          if(!formKey) return;
          const value = input.value;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            if(formKey === 'fieldRef' || formKey === 'fieldRefColumn' || parent === 'field'){
              const current = currentForms.field || {};
              let nextRef = { ...(current.references || {}) };
              if(fieldKey){
                nextRef[fieldKey] = value;
              }
              if(fieldKey === 'table'){
                nextRef = { ...nextRef, table: value, column: '' };
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...current, references: nextRef } } } };
            }
            if(formKey === 'table' && fieldKey === 'name'){
              const targetForm = currentForms.table || {};
              const normalized = sanitizeSqlIdentifier(value);
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    table:{ ...targetForm, name: normalized, nameInput: value }
                  }
                }
              };
            }
            if(formKey === 'table' && fieldKey === 'label'){
              const targetForm = currentForms.table || {};
              const hasNameInput = !!(targetForm.nameInput && targetForm.nameInput.trim());
              const suggestion = sanitizeSqlIdentifier(value);
              const nextTable = { ...targetForm, label: value };
              if(!hasNameInput){
                nextTable.name = suggestion;
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, table: nextTable } } };
            }
            if(formKey === 'field' && fieldKey === 'label'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = targetForm.table ? registry.get(targetForm.table) : null;
              const nextField = { ...targetForm, label:value };
              if(!targetForm.nameManual){
                const slug = computeFieldIdentifier(table, value);
                nextField.name = slug;
                nextField.nameInput = slug;
                nextField.columnName = slug;
              }
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field: nextField } } };
            }
            if(formKey === 'field' && fieldKey === 'name'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = targetForm.table ? registry.get(targetForm.table) : null;
              const normalized = sanitizeSqlIdentifier(value);
              let nextName = normalized;
              if(!nextName && targetForm.label){
                nextName = computeFieldIdentifier(table, targetForm.label);
              }
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    field:{
                      ...targetForm,
                      name: nextName,
                      nameInput: value,
                      columnName: nextName || '',
                      nameManual: !!normalized
                    }
                  }
                }
              };
            }
            if(formKey === 'field' && fieldKey === 'table'){
              const registry = getRegistry(s);
              const targetForm = currentForms.field || {};
              const table = value ? registry.get(value) : null;
              let slug = targetForm.name || '';
              let nameInput = targetForm.nameInput || '';
              if(!targetForm.nameManual && targetForm.label){
                slug = computeFieldIdentifier(table, targetForm.label);
                nameInput = slug;
              }
              const currentRefs = targetForm.references || {};
              const references = currentRefs.table === value
                ? currentRefs
                : { table:'', column:'', onDelete: currentRefs.onDelete || 'CASCADE', onUpdate: currentRefs.onUpdate || 'CASCADE' };
              return {
                ...s,
                ui:{
                  ...(s.ui || {}),
                  form:{
                    ...currentForms,
                    field:{
                      ...targetForm,
                      table:value,
                      name: slug,
                      nameInput,
                      columnName: slug,
                      references
                    }
                  }
                }
              };
            }
            if(formKey === 'relation' && fieldKey === 'sourceTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, sourceTable: value, sourceField:'' } } }
              };
            }
            if(formKey === 'relation' && fieldKey === 'targetTable'){
              const targetForm = currentForms.relation || {};
              return {
                ...s,
                ui:{ ...(s.ui || {}), form:{ ...currentForms, relation:{ ...targetForm, targetTable: value, targetField:'' } } }
              };
            }
            if(fieldKey){
              const targetForm = currentForms[formKey] || {};
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: value } } } };
            }
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: value } } };
          });
          
        }
      },
      'erd.form.toggle':{
        on:['change'],
        gkeys:['erd:form:toggle'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          if(!formKey || !fieldKey) return;
          const checked = input.checked;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            const targetForm = currentForms[formKey] || {};
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: checked } } } };
          });
          
        }
      },
      'erd.table.add':{
        on:['click'],
        gkeys:['erd:table:add'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), table:true } }
          }));
          
        }
      },
      'erd.table.create':{
        on:['click'],
        gkeys:['erd:table:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.table || {};
          const registry = getRegistry(state);
          const englishInput = (form.name || '').trim();
          if(!englishInput){
            UI.pushToast(ctx, { title:'يرجى إدخال الاسم الإنجليزي للجدول', icon:'⚠️' });
            return;
          }
          const name = computeTableIdentifier(registry, englishInput);
          const label = (form.label || '').trim();
          try{
            const currentTables = registry.list();
            const fallbackMap = createAutoLayoutFallbackMap(currentTables.concat([{ id:name, name, fields:[] }]));
            const fallbackPosition = fallbackMap[name] || {
              x: AUTO_LAYOUT_ORIGIN_X + currentTables.length * FALLBACK_NODE_SPACING_X,
              y: AUTO_LAYOUT_ORIGIN_Y + currentTables.length * FALLBACK_NODE_SPACING_Y,
            };
            const tableConfig = {
              name,
              label: label || '',
              comment: form.comment || '',
              layout: fallbackPosition,
              classCode: form.classCode || '',
              fields: []
            };
            if(form.includeId){
              tableConfig.fields.push({ name:'id', columnName:'id', type:'uuid', primaryKey:true, nullable:false });
            }
            registry.register(tableConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const layout = ensureLayout({ data:{ layout: s.data.layout, schema: s.data.schema } }, name, { registry });
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout,
                canvas: s.data.canvas,
                classes: s.data.classes || [],
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                head:{ ...(s.head || {}), title: record.title || (s.head?.title || 'مخطط قاعدة بيانات مشكاة') },
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  layout,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), table:false },
                  form:{
                    ...(s.ui?.form || {}),
                    table:{ name:'', nameInput:'', label:'', comment:'', includeId:true, classCode:'' },
                    field:{ ...(s.ui?.form?.field || {}), table: name, label:'', name:'', nameInput:'', nameManual:false, columnName:'' },
                    layout:{ x: layout[name].x, y: layout[name].y }
                  }
                }
              };
              draft = withTableSelection(draft, name);
              next = draft;
              return next;
            });
            
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create table', error);
            UI.pushToast(ctx, { title:'فشل إنشاء الجدول', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.field.add':{
        on:['click'],
        gkeys:['erd:field:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const first = registry.list()[0]?.name || '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), field:true },
              form:{
                ...(s.ui?.form || {}),
                field:{
                  table: s.data.selection?.table || first,
                  label:'',
                  name:'',
                  nameInput:'',
                  nameManual:false,
                  columnName:'',
                  type:'string',
                  nullable:true,
                  primaryKey:false,
                  unique:false,
                  defaultValue:'',
                  references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
                }
              }
            }
          }));
          
        }
      },
      'erd.field.add.table':{
        on:['click'],
        gkeys:['erd:field:add:table'],
        handler:(event, ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const target = (event?.target && typeof event.target.closest === 'function')
            ? event.target.closest('[data-m-gkey="erd:field:add:table"]')
            : null;
          const button = target || event.currentTarget;
          const requestedTable = button?.getAttribute ? button.getAttribute('data-table') : '';
          const fallbackTable = state.data.selection?.table || registry.list()[0]?.name || '';
          const tableName = requestedTable && registry.get(requestedTable) ? requestedTable : fallbackTable;
          ctx.setState(s=>{
            const nextState = {
              ...s,
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), field:true },
                form:{
                  ...(s.ui?.form || {}),
                  field:{
                    table: tableName,
                    label:'',
                    name:'',
                    nameInput:'',
                    nameManual:false,
                    columnName:'',
                    type:'string',
                    nullable:true,
                    primaryKey:false,
                    unique:false,
                    defaultValue:'',
                    references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
                  }
                }
              }
            };
            return tableName ? withTableSelection(nextState, tableName) : nextState;
          });
          
        }
      },
      'erd.field.create':{
        on:['click'],
        gkeys:['erd:field:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.field || {};
          const tableName = (form.table || '').trim();
          const label = (form.label || '').trim();
          const englishSource = (form.name || '').trim();
          if(!tableName || (!label && !englishSource)){
            UI.pushToast(ctx, { title:'يرجى تحديد الجدول واسم الحقل باللغتين على الأقل', icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:'الجدول غير موجود', icon:'⚠️' });
            return;
          }
          try{
            let fieldName = sanitizeSqlIdentifier(englishSource);
            if(!fieldName && label){
              fieldName = computeFieldIdentifier(table, label);
            }
            if(!fieldName){
              UI.pushToast(ctx, { title:'الاسم الإنجليزي للحقل غير صالح', icon:'⚠️' });
              return;
            }
            if(typeof table.getField === 'function' && table.getField(fieldName)){
              UI.pushToast(ctx, { title:'اسم الحقل مستخدم مسبقًا داخل الجدول', icon:'⚠️' });
              return;
            }
            const fieldConfig = {
              name: fieldName,
              columnName: fieldName,
              type: form.type || 'string',
              nullable: form.nullable !== false,
              primaryKey: !!form.primaryKey,
              unique: !!form.unique,
              comment: label
            };
            if(form.defaultValue){
              const val = form.defaultValue;
              if(['integer','number','decimal','float'].includes(fieldConfig.type)){
                const num = Number(val);
                if(!Number.isNaN(num)) fieldConfig.defaultValue = num;
              } else if(fieldConfig.type === 'boolean'){
                fieldConfig.defaultValue = ['true','1','yes','on'].includes(String(val).toLowerCase());
              } else {
                fieldConfig.defaultValue = val;
              }
            }
            if(form.references && form.references.table && form.references.column){
              fieldConfig.references = {
                table: form.references.table,
                column: form.references.column,
                onDelete: form.references.onDelete || 'CASCADE',
                onUpdate: form.references.onUpdate || 'CASCADE'
              };
            }
            table.addField(fieldConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                classes: s.data.classes || [],
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), field:false },
                  form:{
                    ...(s.ui?.form || {}),
                    field:{
                      ...form,
                      label:'',
                      name:'',
                      nameInput:'',
                      nameManual:false,
                      columnName:'',
                      defaultValue:'',
                      primaryKey:false,
                      unique:false
                    }
                  }
                }
              };
              draft = withFieldSelection(draft, tableName, fieldName);
              next = draft;
              return next;
            });
            
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to add field', error);
            UI.pushToast(ctx, { title:'فشل إضافة الحقل', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.columns.open':{
        on:['click'],
        gkeys:['erd:columns:open'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const selection = state.data.selection || {};
          const tables = registry.list();
          const defaultTable = selection.table && registry.get(selection.table)
            ? selection.table
            : (tables[0]?.name || '');
          const tableEntity = defaultTable ? registry.get(defaultTable) : null;
          const rows = buildColumnsFormRows(tableEntity);
          ctx.setState(s=>{
            const nextState = {
              ...s,
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), columns:true },
                form:{ ...(s.ui?.form || {}), columns:{ table: defaultTable, rows, deleted: [] } }
              }
            };
            return defaultTable ? withTableSelection(nextState, defaultTable) : nextState;
          });
          
        }
      },
      'erd.columns.add-row':{
        on:['click'],
        gkeys:['erd:columns:add-row'],
        handler:(e,ctx)=>{
          const button = e.target.closest('[data-table]');
          const state = ctx.getState();
          const registry = getRegistry(state);
          const columnsForm = state.ui?.form?.columns || {};
          const requestedTable = button?.getAttribute('data-table') || '';
          const activeTableName = requestedTable || columnsForm.table || state.data?.selection?.table || '';
          const table = activeTableName ? registry.get(activeTableName) : null;
          const nextRow = createBlankColumnRow(table);
          ctx.setState(s=>{
            const currentForm = s.ui?.form?.columns || {};
            const rows = Array.isArray(currentForm.rows) ? currentForm.rows.slice() : [];
            const deleted = Array.isArray(currentForm.deleted) ? currentForm.deleted.slice() : [];
            rows.push(nextRow);
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  columns:{ table: activeTableName, rows, deleted }
                }
              }
            };
          });
          
        }
      },
      'erd.columns.select-table':{
        on:['click'],
        gkeys:['erd:columns:select-table'],
        handler:(e,ctx)=>{
          const button = e.target.closest('[data-table]');
          if(!button) return;
          const tableName = button.getAttribute('data-table');
          const state = ctx.getState();
          const registry = getRegistry(state);
          if(!tableName || !registry.get(tableName)) return;
          const rows = buildColumnsFormRows(registry.get(tableName));
          ctx.setState(s=>{
            const draft = {
              ...s,
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), columns:true },
                form:{ ...(s.ui?.form || {}), columns:{ table: tableName, rows, deleted: [] } }
              }
            };
            return withTableSelection(draft, tableName);
          });
          
        }
      },
      'erd.columns.update':{
        on:['input','change'],
        gkeys:['erd:columns:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const rowKey = input.getAttribute('data-row');
          const fieldKey = input.getAttribute('data-field');
          if(!rowKey || !fieldKey) return;
          const isCheckbox = input.type === 'checkbox';
          const rawValue = isCheckbox ? input.checked : input.value;
          const state = ctx.getState();
          const t = createTranslator(state);
          const columnsForm = state.ui?.form?.columns || { table:'', rows:[] };
          const rows = Array.isArray(columnsForm.rows) ? columnsForm.rows.slice() : [];
          const rowIndex = rows.findIndex(row => (row.key || row.originalName || row.name) === rowKey);
          if(rowIndex === -1) return;
          const registry = getRegistry(state);
          const currentRow = rows[rowIndex] || {};
          const next = { ...currentRow };
          let shouldPersist = true;
          switch(fieldKey){
            case 'name':
              next.name = rawValue;
              break;
            case 'type':{
              const nextType = rawValue || 'string';
              next.type = nextType;
              if(typeSupportsLength(nextType)){
                if(!next.length) next.length = defaultLengthForType(nextType);
              } else {
                next.length = '';
              }
              if(typeSupportsPrecision(nextType)){
                const defaults = defaultPrecisionForType(nextType);
                if(!next.precision) next.precision = defaults.precision;
                if(!next.scale) next.scale = defaults.scale;
              } else {
                next.precision = '';
                next.scale = '';
              }
              if(next.references && next.references.table && next.references.column){
                const refTable = registry.get(next.references.table);
                const refField = refTable && typeof refTable.getField === 'function' ? refTable.getField(next.references.column) : null;
                if(!refField || !typesAreCompatible(nextType, refField.type)){
                  next.references = Object.assign({}, next.references, { column:'' });
                  UI.pushToast(ctx, { title:t('modal.columns.reference.typeMismatch', 'يجب أن يتطابق نوع بيانات المفتاح الأجنبي مع العمود المرجعي.'), icon:'⚠️' });
                }
              }
              break;
            }
            case 'length':
              next.length = rawValue;
              break;
            case 'precision':
              next.precision = rawValue;
              break;
            case 'scale':
              next.scale = rawValue;
              break;
            case 'defaultValue':
              next.defaultValue = rawValue;
              break;
            case 'nullable':
              next.nullable = !!rawValue;
              break;
            case 'primaryKey':
              next.primaryKey = !!rawValue;
              if(next.primaryKey) next.nullable = false;
              break;
            case 'refTable':{
              const refs = Object.assign({ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }, next.references || {});
              refs.table = rawValue;
              if(!rawValue){
                refs.column = '';
              } else {
                const targetTable = registry.get(rawValue);
                const fallback = findDefaultReferenceColumn(targetTable, next.type || 'string');
                if(fallback){
                  refs.column = fallback.name;
                } else {
                  refs.column = '';
                  UI.pushToast(ctx, { title:t('modal.columns.reference.noMatch', 'لا توجد أعمدة متوافقة في الجدول المحدد.'), icon:'ℹ️' });
                }
              }
              next.references = refs;
              break;
            }
            case 'refColumn':{
              const refs = Object.assign({ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }, next.references || {});
              if(!rawValue){
                refs.column = '';
                next.references = refs;
                break;
              }
              const tableName = refs.table;
              const targetTable = tableName ? registry.get(tableName) : null;
              const targetField = targetTable && typeof targetTable.getField === 'function' ? targetTable.getField(rawValue) : null;
              if(!targetField){
                UI.pushToast(ctx, { title:t('modal.columns.reference.noMatch', 'لا توجد أعمدة متوافقة في الجدول المحدد.'), icon:'⚠️' });
                shouldPersist = false;
                break;
              }
              if(!typesAreCompatible(next.type || 'string', targetField.type)){
                UI.pushToast(ctx, { title:t('modal.columns.reference.typeMismatch', 'يجب أن يتطابق نوع بيانات المفتاح الأجنبي مع العمود المرجعي.'), icon:'⚠️' });
                shouldPersist = false;
                break;
              }
              refs.column = rawValue;
              next.references = refs;
              break;
            }
            default:
              break;
          }
          if(!shouldPersist) return;
          rows[rowIndex] = next;
          ctx.setState(s => ({
            ...s,
            ui:{
              ...(s.ui || {}),
              form:{ ...(s.ui?.form || {}), columns:{ table: columnsForm.table || '', rows, deleted: Array.isArray(columnsForm.deleted) ? columnsForm.deleted.slice() : [] } }
            }
          }));
          
        }
      },
      'erd.columns.delete-row':{
        on:['click'],
        gkeys:['erd:columns:delete-row'],
        handler:(e,ctx)=>{
          const button = e.target.closest('[data-row]');
          if(!button) return;
          const rowKey = button.getAttribute('data-row');
          if(!rowKey) return;
          ctx.setState(s=>{
            const columnsForm = s.ui?.form?.columns || {};
            const rows = Array.isArray(columnsForm.rows) ? columnsForm.rows.slice() : [];
            const index = rows.findIndex(row => (row.key || row.originalName || row.name) === rowKey);
            if(index === -1) return s;
            const removed = rows.splice(index, 1)[0] || {};
            const deleted = Array.isArray(columnsForm.deleted) ? columnsForm.deleted.slice() : [];
            const originalName = removed.originalName || '';
            if(originalName && !deleted.includes(originalName)) deleted.push(originalName);
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                form:{ ...(s.ui?.form || {}), columns:{ table: columnsForm.table || '', rows, deleted } }
              }
            };
          });
          
        }
      },
      'erd.columns.open-relation':{
        on:['click'],
        gkeys:['erd:columns:open-relation'],
        handler:(e,ctx)=>{
          const button = e.target.closest('[data-row]');
          if(!button) return;
          const rowKey = button.getAttribute('data-row');
          const tableName = button.getAttribute('data-table');
          const state = ctx.getState();
          const columnsForm = state.ui?.form?.columns || {};
          const rows = Array.isArray(columnsForm.rows) ? columnsForm.rows : [];
          const row = rows.find(item => (item.key || item.originalName || item.name) === rowKey);
          if(!row) return;
          const sourceField = sanitizeSqlIdentifier(row.name || row.originalName || rowKey) || row.originalName || rowKey;
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), columns:true, relation:true },
              form:{
                ...(s.ui?.form || {}),
                relation:{
                  sourceTable: tableName || columnsForm.table || '',
                  sourceField,
                  targetTable: row.references?.table || '',
                  targetField: row.references?.column || '',
                  onDelete: row.references?.onDelete || 'CASCADE',
                  onUpdate: row.references?.onUpdate || 'CASCADE'
                }
              }
            }
          }));
          
        }
      },
      'erd.columns.focus':{
        on:['click'],
        gkeys:['erd:columns:focus'],
        handler:(e,ctx)=>{
          const button = e.target.closest('[data-row]');
          if(!button) return;
          const rowKey = button.getAttribute('data-row');
          const requestedTable = button.getAttribute('data-table');
          let targetTable = '';
          let targetField = rowKey || '';
          ctx.setState(s=>{
            const columnsForm = s.ui?.form?.columns || {};
            const rows = Array.isArray(columnsForm.rows) ? columnsForm.rows : [];
            const row = rows.find(item => (item.key || item.originalName || item.name) === rowKey);
            const resolvedTable = requestedTable || columnsForm.table || '';
            const resolvedField = row
              ? (sanitizeSqlIdentifier(row.name || row.originalName || rowKey) || row.originalName || rowKey)
              : (rowKey || '');
            targetTable = resolvedTable;
            targetField = resolvedField;
            const draft = {
              ...s,
              data:{ ...(s.data || {}), canvas:{ ...(s.data?.canvas || {}), mode:'manual' } },
              ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), columns:false } }
            };
            if(resolvedTable && resolvedField){
              return withFieldSelection(draft, resolvedTable, resolvedField);
            }
            if(resolvedTable){
              return withTableSelection(draft, resolvedTable);
            }
            return draft;
          });
          
          const snapshot = ctx.getState();
          scheduleDiagramRender(snapshot);
          if(targetTable){
            const focusFn = ()=> focusTableOnCanvas(targetTable, targetField);
            if(typeof requestAnimationFrame === 'function'){
              requestAnimationFrame(()=> requestAnimationFrame(focusFn));
            } else {
              setTimeout(focusFn, 16);
            }
          }
        }
      },
      'erd.columns.save':{
        on:['click'],
        gkeys:['erd:columns:save'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.columns || {};
          const tableName = form.table || '';
          const registry = getRegistry(state);
          const table = tableName ? registry.get(tableName) : null;
          if(!table){
            UI.pushToast(ctx, { title:'اختر جدولاً لتحديث أعمدته', icon:'⚠️' });
            return;
          }
          const rows = Array.isArray(form.rows) ? form.rows : [];
          if(!rows.length){
            UI.pushToast(ctx, { title:'لا توجد أعمدة لتحديثها', icon:'⚠️' });
            return;
          }
          const deleted = Array.isArray(form.deleted) ? form.deleted.filter(Boolean) : [];
          const renameMap = new Map();
          try {
            const preserved = new Set(rows.map(row => row.originalName).filter(Boolean));
            const removalList = Array.from(new Set(deleted)).filter(name => name && !preserved.has(name));
            removalList.forEach(name => {
              if(typeof table.removeField === 'function'){
                try { table.removeField(name); }
                catch(error){ console.warn('[Mishkah][ERD] failed to remove column', name, error); }
              }
            });
            rows.forEach((row, index)=>{
              const original = row.originalName || '';
              let nextName = sanitizeSqlIdentifier(row.name || original || `column_${index+1}`);
              if(!nextName){
                nextName = ensureUniqueFieldName(table, original || 'column');
              }
              const patch = {
                name: nextName,
                columnName: nextName,
                type: row.type || 'string',
                nullable: row.nullable !== false,
                primaryKey: !!row.primaryKey,
                unique: !!row.unique,
                index: !!row.index,
                defaultValue: undefined,
                maxLength: undefined,
                precision: undefined,
                scale: undefined
              };
              if(typeSupportsLength(patch.type)){
                const lengthValue = Number(row.length);
                patch.maxLength = Number.isFinite(lengthValue) && lengthValue > 0 ? lengthValue : undefined;
              }
              if(typeSupportsPrecision(patch.type)){
                const precisionValue = Number(row.precision);
                const scaleValue = Number(row.scale);
                patch.precision = Number.isFinite(precisionValue) && precisionValue > 0 ? precisionValue : undefined;
                patch.scale = Number.isFinite(scaleValue) && scaleValue >= 0 ? scaleValue : undefined;
              }
              if(row.defaultValue != null && row.defaultValue !== ''){
                if(['integer','number','decimal','float'].includes(patch.type)){
                  const num = Number(row.defaultValue);
                  patch.defaultValue = Number.isNaN(num) ? row.defaultValue : num;
                } else if(patch.type === 'boolean'){
                  patch.defaultValue = ['true','1','yes','on'].includes(String(row.defaultValue).toLowerCase());
                } else {
                  patch.defaultValue = row.defaultValue;
                }
              }
              if(row.references && row.references.table && row.references.column){
                patch.references = {
                  table: row.references.table,
                  column: row.references.column,
                  onDelete: row.references.onDelete || 'CASCADE',
                  onUpdate: row.references.onUpdate || 'CASCADE'
                };
              } else {
                patch.references = null;
              }
              const existingField = original && typeof table.getField === 'function' ? table.getField(original) : null;
              if(existingField){
                if(original !== nextName && typeof table.getField === 'function' && table.getField(nextName)){
                  nextName = ensureUniqueFieldName(table, nextName);
                  patch.name = nextName;
                  patch.columnName = nextName;
                }
                table.updateField(original, patch);
                if(original !== nextName) renameMap.set(original, nextName);
              } else {
                if(typeof table.getField === 'function' && table.getField(nextName)){
                  nextName = ensureUniqueFieldName(table, nextName);
                  patch.name = nextName;
                  patch.columnName = nextName;
                }
                const newFieldConfig = Object.assign({}, patch);
                if(newFieldConfig.defaultValue === undefined) delete newFieldConfig.defaultValue;
                if(newFieldConfig.maxLength === undefined) delete newFieldConfig.maxLength;
                if(newFieldConfig.precision === undefined) delete newFieldConfig.precision;
                if(newFieldConfig.scale === undefined) delete newFieldConfig.scale;
                if(newFieldConfig.references == null) delete newFieldConfig.references;
                table.addField(newFieldConfig);
              }
            });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to save columns', error);
            UI.pushToast(ctx, { title:'تعذر تحديث الأعمدة', message:String(error), icon:'🛑' });
            return;
          }
          const schemaJSON = registry.toJSON();
          let persistRecord = null;
          let nextState = null;
          ctx.setState(s=>{
            const now = Date.now();
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: schemaJSON,
              layout: s.data.layout,
              canvas: s.data.canvas,
              classes: s.data.classes || [],
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            persistRecord = record;
            const refreshedTable = registry.get(tableName);
            const refreshedRows = buildColumnsFormRows(refreshedTable);
            let draft = {
              ...s,
              data:{
                ...s.data,
                schema: schemaJSON,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), columns:true, columnsUnique:false, columnsIndex:false },
                form:{ ...(s.ui?.form || {}), columns:{ table: tableName, rows: refreshedRows, deleted: [] } }
              }
            };
            if(renameMap.size){
              const currentSelection = draft.data.selection || {};
              if(currentSelection.table === tableName && currentSelection.field && renameMap.has(currentSelection.field)){
                draft = withFieldSelection(draft, tableName, renameMap.get(currentSelection.field));
              }
            }
            nextState = draft;
            return draft;
          });
          
          if(persistRecord) schedulePersist(recordFromState(nextState));
          UI.pushToast(ctx, { title:'تم حفظ الأعمدة بنجاح', icon:'✅' });
        }
      },
      'erd.columns.unique:open':{
        on:['click'],
        gkeys:['erd:columns:unique:open'],
        handler:(e,ctx)=>{
          const trigger = e.target.closest('[data-table]');
          if(!trigger) return;
          const state = ctx.getState();
          const t = createTranslator(state);
          const tableName = trigger.getAttribute('data-table') || '';
          if(!tableName){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          const indexName = trigger.getAttribute('data-index') || '';
          const indexes = Array.isArray(table.indexes) ? table.indexes : [];
          let targetIndex = indexName ? indexes.find(idx => idx && idx.name === indexName) : null;
          if(!targetIndex && indexName){
            targetIndex = indexes.find(idx => Array.isArray(idx?.columns) && idx.columns.join('__') === indexName);
          }
          const defaultBase = indexName || `${table.name}_unique`;
          const resolvedName = targetIndex?.name || ensureUniqueIndexName(table, defaultBase, targetIndex?.name || '');
          const selectedColumns = targetIndex?.columns ? targetIndex.columns.slice() : [];
          const lookupKey = targetIndex ? (targetIndex.name || indexName) : '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), columns:true, columnsUnique:true, columnsIndex:false },
              form:{
                ...(s.ui?.form || {}),
                columns:{ ...(s.ui?.form?.columns || {}), table: tableName, rows: Array.isArray(s.ui?.form?.columns?.rows) ? s.ui.form.columns.rows : buildColumnsFormRows(table) },
                columnsUnique:{ table: tableName, originalName: targetIndex?.name || '', lookupKey, name: resolvedName, columns: selectedColumns }
              }
            }
          }));
          
        }
      },
      'erd.columns.unique:close':{
        on:['click'],
        gkeys:['erd:columns:unique:close'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), columns:true, columnsUnique:false },
              form:{ ...(s.ui?.form || {}), columnsUnique:null }
            }
          }));
          
        }
      },
      'erd.columns.unique:update':{
        on:['input','change'],
        gkeys:['erd:columns:unique:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const field = input.getAttribute('data-field');
          if(!field) return;
          const value = input.value;
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              form:{
                ...(s.ui?.form || {}),
                columnsUnique:{ ...(s.ui?.form?.columnsUnique || {}), [field]: value }
              }
            }
          }));
          
        }
      },
      'erd.columns.unique:toggle':{
        on:['change'],
        gkeys:['erd:columns:unique:toggle'],
        handler:(e,ctx)=>{
          const input = e.target;
          const column = input.getAttribute('data-column');
          if(!column) return;
          const checked = input.checked;
          ctx.setState(s=>{
            const form = s.ui?.form?.columnsUnique || {};
            const list = Array.isArray(form.columns) ? form.columns.slice() : [];
            const nextColumns = list.filter(col => col !== column);
            if(checked) nextColumns.push(column);
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  columnsUnique:{ ...form, columns: nextColumns }
                }
              }
            };
          });
          
        }
      },
      'erd.columns.unique:save':{
        on:['click'],
        gkeys:['erd:columns:unique:save'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const t = createTranslator(state);
          const form = state.ui?.form?.columnsUnique || {};
          const tableName = form.table || '';
          const selectedColumns = Array.isArray(form.columns) ? form.columns.filter(Boolean) : [];
          if(!tableName){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          if(!selectedColumns.length){
            UI.pushToast(ctx, { title:t('toast.columns.unique.invalid', 'اختر عمودًا واحدًا على الأقل للقيد الفريد.'), icon:'⚠️' });
            return;
          }
          const existingIndexes = Array.isArray(table.indexes) ? table.indexes.slice() : [];
          const originalName = form.originalName || '';
          const lookupKey = form.lookupKey || originalName || '';
          const existingEntry = lookupKey
            ? existingIndexes.find(idx => {
                if(!idx) return false;
                if(idx.name === lookupKey) return true;
                if(!idx.name && Array.isArray(idx.columns) && idx.columns.join('__') === lookupKey) return true;
                return false;
              })
            : null;
          const baseName = sanitizeSqlIdentifier(form.name || '') || `${table.name}_unique`;
          const finalName = ensureUniqueIndexName(table, baseName, originalName || '');
          const nextIndex = {
            name: finalName,
            columns: selectedColumns.slice(),
            unique:true,
            method: existingEntry?.method || 'btree'
          };
          if(existingEntry){
            const idx = existingIndexes.indexOf(existingEntry);
            if(idx >= 0) existingIndexes[idx] = Object.assign({}, nextIndex);
          } else {
            existingIndexes.push(nextIndex);
          }
          table.indexes = existingIndexes;
          persistColumnsEditorState(ctx, registry, tableName, {
            toastTitle: t('toast.columns.unique.saved', 'تم حفظ القيد الفريد'),
            formOverrides:{ columnsUnique:null }
          });
        }
      },
      'erd.columns.unique:delete':{
        on:['click'],
        gkeys:['erd:columns:unique:delete'],
        handler:(e,ctx)=>{
          const trigger = e.target.closest('[data-table]');
          if(!trigger) return;
          const state = ctx.getState();
          const t = createTranslator(state);
          const tableName = trigger.getAttribute('data-table') || '';
          const indexName = trigger.getAttribute('data-index') || '';
          if(!tableName || !indexName){
            UI.pushToast(ctx, { title:t('toast.columns.indexMissing', 'الفهرس غير موجود'), icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          const existingIndexes = Array.isArray(table.indexes) ? table.indexes.slice() : [];
          let removed = false;
          const filtered = existingIndexes.filter(idx => {
            if(!idx) return false;
            const joinKey = Array.isArray(idx.columns) ? idx.columns.join('__') : '';
            if(idx.name === indexName || (!idx.name && joinKey === indexName)){
              removed = true;
              return false;
            }
            return true;
          });
          if(!removed){
            UI.pushToast(ctx, { title:t('toast.columns.indexMissing', 'الفهرس غير موجود'), icon:'⚠️' });
            return;
          }
          table.indexes = filtered;
          persistColumnsEditorState(ctx, registry, tableName, {
            toastTitle: t('toast.columns.unique.deleted', 'تم حذف القيد الفريد'),
            formOverrides:{ columnsUnique:null }
          });
        }
      },
      'erd.columns.index:open':{
        on:['click'],
        gkeys:['erd:columns:index:open'],
        handler:(e,ctx)=>{
          const trigger = e.target.closest('[data-table]');
          if(!trigger) return;
          const state = ctx.getState();
          const t = createTranslator(state);
          const tableName = trigger.getAttribute('data-table') || '';
          if(!tableName){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          const indexName = trigger.getAttribute('data-index') || '';
          const indexes = Array.isArray(table.indexes) ? table.indexes : [];
          let targetIndex = indexName ? indexes.find(idx => idx && idx.name === indexName) : null;
          if(!targetIndex && indexName){
            targetIndex = indexes.find(idx => Array.isArray(idx?.columns) && idx.columns.join('__') === indexName);
          }
          const defaultBase = indexName || `${table.name}_idx`;
          const resolvedName = targetIndex?.name || ensureUniqueIndexName(table, defaultBase, targetIndex?.name || '');
          const selectedColumns = targetIndex?.columns ? targetIndex.columns.slice() : [];
          const method = targetIndex?.method || 'btree';
          const where = targetIndex?.where || '';
          const lookupKey = targetIndex ? (targetIndex.name || indexName) : '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), columns:true, columnsUnique:false, columnsIndex:true },
              form:{
                ...(s.ui?.form || {}),
                columns:{ ...(s.ui?.form?.columns || {}), table: tableName, rows: Array.isArray(s.ui?.form?.columns?.rows) ? s.ui.form.columns.rows : buildColumnsFormRows(table) },
                columnsIndex:{ table: tableName, originalName: targetIndex?.name || '', lookupKey, name: resolvedName, method, where, columns: selectedColumns }
              }
            }
          }));
          
        }
      },
      'erd.columns.index:close':{
        on:['click'],
        gkeys:['erd:columns:index:close'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), columns:true, columnsIndex:false },
              form:{ ...(s.ui?.form || {}), columnsIndex:null }
            }
          }));
          
        }
      },
      'erd.columns.index:update':{
        on:['input','change'],
        gkeys:['erd:columns:index:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const field = input.getAttribute('data-field');
          if(!field) return;
          const value = input.value;
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              form:{
                ...(s.ui?.form || {}),
                columnsIndex:{ ...(s.ui?.form?.columnsIndex || {}), [field]: value }
              }
            }
          }));
          
        }
      },
      'erd.columns.index:toggle':{
        on:['change'],
        gkeys:['erd:columns:index:toggle'],
        handler:(e,ctx)=>{
          const input = e.target;
          const column = input.getAttribute('data-column');
          if(!column) return;
          const checked = input.checked;
          ctx.setState(s=>{
            const form = s.ui?.form?.columnsIndex || {};
            const list = Array.isArray(form.columns) ? form.columns.slice() : [];
            const nextColumns = list.filter(col => col !== column);
            if(checked) nextColumns.push(column);
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  columnsIndex:{ ...form, columns: nextColumns }
                }
              }
            };
          });
          
        }
      },
      'erd.columns.index:save':{
        on:['click'],
        gkeys:['erd:columns:index:save'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const t = createTranslator(state);
          const form = state.ui?.form?.columnsIndex || {};
          const tableName = form.table || '';
          const selectedColumns = Array.isArray(form.columns) ? form.columns.filter(Boolean) : [];
          if(!tableName){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          if(!selectedColumns.length){
            UI.pushToast(ctx, { title:t('toast.columns.index.invalid', 'اختر عمودًا واحدًا على الأقل للفهرس.'), icon:'⚠️' });
            return;
          }
          const existingIndexes = Array.isArray(table.indexes) ? table.indexes.slice() : [];
          const originalName = form.originalName || '';
          const lookupKey = form.lookupKey || originalName || '';
          const existingEntry = lookupKey
            ? existingIndexes.find(idx => {
                if(!idx) return false;
                if(idx.name === lookupKey) return true;
                if(!idx.name && Array.isArray(idx.columns) && idx.columns.join('__') === lookupKey) return true;
                return false;
              })
            : null;
          const baseName = sanitizeSqlIdentifier(form.name || '') || `${table.name}_idx`;
          const finalName = ensureUniqueIndexName(table, baseName, originalName || '');
          const methodValue = INDEX_METHOD_OPTIONS.includes((form.method || '').toLowerCase())
            ? (form.method || '').toLowerCase()
            : 'btree';
          const whereValue = typeof form.where === 'string' ? form.where.trim() : '';
          const nextIndex = {
            name: finalName,
            columns: selectedColumns.slice(),
            unique:false,
            method: methodValue
          };
          if(whereValue) nextIndex.where = whereValue;
          if(existingEntry){
            const idx = existingIndexes.indexOf(existingEntry);
            if(idx >= 0) existingIndexes[idx] = Object.assign({}, nextIndex);
          } else {
            existingIndexes.push(nextIndex);
          }
          table.indexes = existingIndexes;
          persistColumnsEditorState(ctx, registry, tableName, {
            toastTitle: t('toast.columns.index.saved', 'تم حفظ الفهرس بنجاح'),
            formOverrides:{ columnsIndex:null }
          });
        }
      },
      'erd.columns.index:delete':{
        on:['click'],
        gkeys:['erd:columns:index:delete'],
        handler:(e,ctx)=>{
          const trigger = e.target.closest('[data-table]');
          if(!trigger) return;
          const state = ctx.getState();
          const t = createTranslator(state);
          const tableName = trigger.getAttribute('data-table') || '';
          const indexName = trigger.getAttribute('data-index') || '';
          if(!tableName || !indexName){
            UI.pushToast(ctx, { title:t('toast.columns.indexMissing', 'الفهرس غير موجود'), icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:t('toast.columns.tableMissing', 'الجدول غير موجود'), icon:'⚠️' });
            return;
          }
          const existingIndexes = Array.isArray(table.indexes) ? table.indexes.slice() : [];
          let removed = false;
          const filtered = existingIndexes.filter(idx => {
            if(!idx) return false;
            const joinKey = Array.isArray(idx.columns) ? idx.columns.join('__') : '';
            if(idx.name === indexName || (!idx.name && joinKey === indexName)){
              removed = true;
              return false;
            }
            return true;
          });
          if(!removed){
            UI.pushToast(ctx, { title:t('toast.columns.indexMissing', 'الفهرس غير موجود'), icon:'⚠️' });
            return;
          }
          table.indexes = filtered;
          persistColumnsEditorState(ctx, registry, tableName, {
            toastTitle: t('toast.columns.index.deleted', 'تم حذف الفهرس'),
            formOverrides:{ columnsIndex:null }
          });
        }
      },
      'erd.classes.add':{
        on:['click'],
        gkeys:['erd:classes:add'],
        handler:(e,ctx)=>{
          ctx.setState(s => {
            const classificationForm = s.ui?.form?.classification || {};
            const rows = Array.isArray(classificationForm.rows) ? classificationForm.rows.slice() : [];
            rows.push({ code:'', name:'', parent:'' });
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  classification:{ ...(classificationForm || {}), rows }
                }
              }
            };
          });
          
        }
      },
      'erd.classes.update':{
        on:['input','change'],
        gkeys:['erd:classes:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const index = Number(input?.getAttribute('data-index'));
          const field = input?.getAttribute('data-field');
          if(!Number.isInteger(index) || !field) return;
          const value = input.value;
          ctx.setState(s => {
            const classificationForm = s.ui?.form?.classification || {};
            const rows = Array.isArray(classificationForm.rows) ? classificationForm.rows.slice() : [];
            if(!rows[index]) return s;
            const nextRows = rows.slice();
            nextRows[index] = { ...nextRows[index], [field]: value };
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  classification:{ ...(classificationForm || {}), rows: nextRows }
                }
              }
            };
          });
          
        }
      },
      'erd.classes.remove':{
        on:['click'],
        gkeys:['erd:classes:remove'],
        handler:(e,ctx)=>{
          const button = e.currentTarget || e.target;
          const index = Number(button?.getAttribute('data-index'));
          if(!Number.isInteger(index)) return;
          ctx.setState(s => {
            const classificationForm = s.ui?.form?.classification || {};
            const rows = Array.isArray(classificationForm.rows) ? classificationForm.rows.slice() : [];
            if(index < 0 || index >= rows.length) return s;
            rows.splice(index, 1);
            return {
              ...s,
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  classification:{ ...(classificationForm || {}), rows }
                }
              }
            };
          });
          
        }
      },
      'erd.classes.save':{
        on:['click'],
        gkeys:['erd:classes:save'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const rows = Array.isArray(state.ui?.form?.classification?.rows) ? state.ui.form.classification.rows : [];
          const normalized = normaliseClasses(rows);
          const filled = rows.filter(row => (row && row.code != null && String(row.code).trim() !== ''));
          if(normalized.length !== filled.length){
            UI.pushToast(ctx, { title:'تحقق من الأكواد', message:'يرجى استخدام صيغ صحيحة من خانتين لكل مستوى وعدم تكرار الأكواد.', icon:'⚠️' });
            return;
          }
          const codeSet = new Set(normalized.map(item => item.code));
          const invalidParent = normalized.find(item => item.parent && !codeSet.has(item.parent));
          if(invalidParent){
            UI.pushToast(ctx, { title:'أكواد الآباء غير موجودة', message:`${invalidParent.parent} غير معرف كأب`, icon:'⚠️' });
            return;
          }
          commitClasses(ctx, normalized);
          UI.pushToast(ctx, { title:'تم حفظ الشجرة', icon:'✅' });
        }
      },
      'erd.classes.open-bulk':{
        on:['click'],
        gkeys:['erd:classes:open-bulk'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const rows = Array.isArray(state.ui?.form?.classification?.rows) ? state.ui.form.classification.rows : [];
          const normalized = normaliseClasses(rows);
          ctx.setState(s => ({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), classification:true },
              form:{
                ...(s.ui?.form || {}),
                classification:{ ...(s.ui?.form?.classification || {}), bulkText: normalized.length ? JSON.stringify(normalized, null, 2) : '' }
              }
            }
          }));
          
        }
      },
      'erd.classes.update-bulk':{
        on:['input','change'],
        gkeys:['erd:classes:update-bulk'],
        handler:(e,ctx)=>{
          const value = e.target?.value ?? '';
          ctx.setState(s => ({
            ...s,
            ui:{
              ...(s.ui || {}),
              form:{
                ...(s.ui?.form || {}),
                classification:{ ...(s.ui?.form?.classification || {}), bulkText:value }
              }
            }
          }));
        }
      },
      'erd.classes.apply-bulk':{
        on:['click'],
        gkeys:['erd:classes:apply-bulk'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const text = state.ui?.form?.classification?.bulkText || '';
          let parsed;
          try {
            parsed = JSON.parse(text || '[]');
          } catch(error){
            UI.pushToast(ctx, { title:'تعذر قراءة البيانات', message:String(error), icon:'🛑' });
            return;
          }
          if(!Array.isArray(parsed)){
            UI.pushToast(ctx, { title:'صيغة غير صحيحة', message:'استخدم مصفوفة JSON تحتوي على عناصر {code,name,parent}.', icon:'⚠️' });
            return;
          }
          const normalized = normaliseClasses(parsed);
          const filled = parsed.filter(item => item && item.code != null && String(item.code).trim() !== '');
          if(normalized.length !== filled.length){
            UI.pushToast(ctx, { title:'تحقق من الأكواد', message:'يوجد أكواد غير صالحة أو مكررة.', icon:'⚠️' });
            return;
          }
          const codeSet = new Set(normalized.map(item => item.code));
          const invalidParent = normalized.find(item => item.parent && !codeSet.has(item.parent));
          if(invalidParent){
            UI.pushToast(ctx, { title:'أكواد الآباء غير موجودة', message:`${invalidParent.parent} غير معرف كأب`, icon:'⚠️' });
            return;
          }
          commitClasses(ctx, normalized, { closeModal:true });
          UI.pushToast(ctx, { title:'تم تحديث الشجرة', icon:'✅' });
        }
      },
      'erd.context.close':{
        on:['click'],
        gkeys:['erd:context:close'],
        handler:()=>{
          closeContextMenu();
        }
      },
      'erd.context.action':{
        on:['click'],
        gkeys:['erd:context:action'],
        handler:async (event, ctx)=>{
          const button = event.target.closest('[data-action]');
          if(!button) return;
          const action = button.getAttribute('data-action');
          const tableName = button.getAttribute('data-table') || '';
          const fieldName = button.getAttribute('data-field') || '';
          closeContextMenu();
          switch(action){
            case 'canvas:new-table':{
              ctx.setState(s=>({
                ...s,
                ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), table:true } }
              }));
              
              break;
            }
            case 'canvas:auto-layout':
              autoLayoutDiagram(ctx);
              break;
            case 'canvas:fit':{
              const driver = ensureDriverInstance(ctx.getState());
              if(driver && typeof driver.fitToScreen === 'function'){
                try { driver.fitToScreen(16); }
                catch(error){ console.warn('[Mishkah][ERD] fit failed', error); }
              }
              break;
            }
            case 'canvas:paste':
              await pasteSchemaFromClipboard(ctx);
              break;
            case 'canvas:import':{
              const state = ctx.getState();
              const payload = {
                name: state.data.schemaMeta?.name || '',
                title: state.data.schemaMeta?.title || '',
                description: state.data.schemaMeta?.description || '',
                schema: state.data.schema,
                layout: state.data.layout,
                canvas: state.data.canvas
              };
              ctx.setState(s=>({
                ...s,
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), import:true },
                  form:{ ...(s.ui?.form || {}), import:{ name: payload.name, title: payload.title, targetId: s.data.schemaId || '', text: JSON.stringify(payload, null, 2) } }
                }
              }));
              
              break;
            }
            case 'table:columns':
              openColumnsManager(ctx, tableName);
              break;
            case 'table:add-unique':
            case 'table:add-index':
              openColumnsManager(ctx, tableName);
              UI.pushToast(ctx, { title:'استخدم محرر الأعمدة لضبط القيود', icon:'ℹ️' });
              break;
            case 'table:generate-fk':
              openRelationModal(ctx, tableName, '');
              break;
            case 'table:toggle-visibility':
              toggleTableVisibility(ctx, tableName);
              UI.pushToast(ctx, { title:'تم تحديث حالة الظهور', icon:'👁️' });
              break;
            case 'table:export-sql':{
              const state = ctx.getState();
              const registry = getRegistry(state);
              const table = tableName ? registry.get(tableName) : null;
              if(!table){
                UI.pushToast(ctx, { title:'الجدول غير موجود', icon:'⚠️' });
                break;
              }
              const sql = table.toSQL({ schemaName:'public' });
              ctx.setState(s=>({
                ...s,
                data:{ ...(s.data || {}), sqlPreview: sql },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), exportSql:true },
                  form:{ ...(s.ui?.form || {}), sql:{ text: sql } }
                }
              }));
              
              break;
            }
            case 'table:export-json':{
              const state = ctx.getState();
              const registry = getRegistry(state);
              const table = tableName ? registry.get(tableName) : null;
              if(!table){
                UI.pushToast(ctx, { title:'الجدول غير موجود', icon:'⚠️' });
                break;
              }
              const payload = { tables:[table.toJSON()] };
              ctx.setState(s=>({
                ...s,
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), exportJson:true },
                  form:{ ...(s.ui?.form || {}), export:{ text: JSON.stringify(payload, null, 2) } }
                }
              }));
              
              break;
            }
            case 'field:pk':
              toggleFieldProperty(ctx, tableName, fieldName, 'primaryKey');
              break;
            case 'field:null':
              toggleFieldProperty(ctx, tableName, fieldName, 'nullable');
              break;
            case 'field:unique':
              toggleFieldProperty(ctx, tableName, fieldName, 'unique');
              break;
            case 'field:index':
              toggleFieldProperty(ctx, tableName, fieldName, 'index');
              break;
            case 'field:create-fk':
              openRelationModal(ctx, tableName, fieldName);
              break;
            case 'field:rename':
            case 'field:type':
            case 'field:length':
              openColumnsManager(ctx, tableName);
              break;
            case 'table:rename':
            case 'table:duplicate':
            case 'table:delete':
              UI.pushToast(ctx, { title:'هذه الميزة قيد التطوير', icon:'🛠️' });
              break;
            default:
              UI.pushToast(ctx, { title:'هذه الميزة قيد التطوير', icon:'🛠️' });
              break;
          }
        }
      },
      'erd.relation.add':{
        on:['click'],
        gkeys:['erd:relation:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), relation:true },
              form:{ ...(s.ui?.form || {}), relation:{ sourceTable: selection.table || '', sourceField: selection.field || '', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' } }
            }
          }));
          
        }
      },
      'erd.relation.create':{
        on:['click'],
        gkeys:['erd:relation:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.relation || {};
          if(!form.sourceTable || !form.sourceField || !form.targetTable || !form.targetField){
            UI.pushToast(ctx, { title:'الرجاء اختيار الحقول المصدر والهدف', icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(form.sourceTable);
          if(!table){
            UI.pushToast(ctx, { title:'الجدول المصدر غير موجود', icon:'⚠️' });
            return;
          }
          try{
            table.updateField(form.sourceField, {
              references:{
                table: form.targetTable,
                column: form.targetField,
                onDelete: form.onDelete || 'CASCADE',
                onUpdate: form.onUpdate || 'CASCADE'
              }
            });
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              let draft = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), relation:false } }
              };
              draft = withFieldSelection(draft, form.sourceTable, form.sourceField);
              next = draft;
              return next;
            });
            
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create relation', error);
            UI.pushToast(ctx, { title:'فشل إنشاء العلاقة', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.import.apply':{
        on:['click'],
        gkeys:['erd:import:apply'],
        handler:async (e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.import || {};
          const raw = form.text || '';
          try{
            const parsed = JSON.parse(raw);
            const schemaPayload = parsed.schema && parsed.schema.tables ? parsed.schema : parsed;
            const registry = Schema.Registry.fromJSON(schemaPayload);
            const normalizedSchema = registry.toJSON();
            const layout = computeLayout(registry, parsed.layout);
            const targetId = form.targetId || '';
            let existing = null;
            if(targetId){ existing = await SchemaLibrary.get(targetId); }
            const classesSource = parsed.classes != null ? parsed.classes : parsed.classification;
            const importedClasses = classesSource != null
              ? normaliseClasses(classesSource)
              : normaliseClasses(existing?.classes || state.data.classes || []);
            const now = Date.now();
            const canvasState = normaliseCanvas(parsed.canvas || existing?.canvas || state.data.canvas);
            const recordInput = {
              id: targetId || undefined,
              name: form.name || parsed.name || schemaPayload.name || `schema_${now}`,
              title: form.title || parsed.title || form.name || `مخطط ${now}`,
              description: parsed.description || '',
              schema: normalizedSchema,
              layout,
              canvas: canvasState,
              classes: importedClasses,
              createdAt: existing?.createdAt,
              updatedAt: now
            };
            const saved = await SchemaLibrary.save(recordInput);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: saved.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: saved.id,
                schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' },
                schemaCreatedAt: saved.createdAt,
                schemaUpdatedAt: saved.updatedAt,
                schema: normalizedSchema,
                layout,
                selection:{ table:first, field:null },
                canvas: canvasState,
                classes: importedClasses,
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), import:false },
                form:{
                  ...(s.ui?.form || {}),
                  import:{ name:'', title:'', targetId:'', text:'' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' },
                  classification:{ rows: importedClasses.map(item => ({ ...item })), bulkText: importedClasses.length ? JSON.stringify(importedClasses, null, 2) : '' },
                  table:{ ...(s.ui?.form?.table || {}), classCode:'' }
                }
              }
            }));
            
            UI.pushToast(ctx, { title:'تم استيراد المخطط وتخزينه', icon:'✅' });
          } catch(error){
            console.warn('[Mishkah][ERD] import failed', error);
            UI.pushToast(ctx, { title:'تعذر استيراد JSON', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.layout.input':{
        on:['input','change'],
        gkeys:['erd:layout:input'],
        handler:(e,ctx)=>{
          const axis = e.target.getAttribute('data-axis');
          if(!axis) return;
          const value = Number(e.target.value);
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), form:{ ...(s.ui?.form || {}), layout:{ ...(s.ui?.form?.layout || {}), [axis]: Number.isFinite(value) ? value : 0 } } }
          }));
          
        }
      },
      'erd.layout.apply':{
        on:['click'],
        gkeys:['erd:layout:apply'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          if(!selection.table){
            UI.pushToast(ctx, { title:'اختر جدولاً لتحديث موقعه', icon:'⚠️' });
            return;
          }
          const formLayout = state.ui?.form?.layout || { x:120, y:120 };
          let next;
          ctx.setState(s=>{
            const layout = Object.assign({}, s.data.layout || {});
            layout[selection.table] = { x: Number(formLayout.x) || 0, y: Number(formLayout.y) || 0 };
            const now = Date.now();
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout,
              canvas: s.data.canvas,
              classes: s.data.classes || [],
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              data:{
                ...s.data,
                layout,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.library.new':{
        on:['click'],
        gkeys:['erd:library:new'],
        handler:async (e,ctx)=>{
          try{
            const record = await SchemaLibrary.createBlank({ title:'مخطط جديد' });
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            const classes = normaliseClasses(record.classes || []);
            const classificationForm = {
              rows: classes.map(item => ({ ...item })),
              bulkText: classes.length ? JSON.stringify(classes, null, 2) : ''
            };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: normaliseCanvas(record.canvas),
                library:{ ...(s.data.library || {}), items: list },
                classes
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  table:{ name:'', nameInput:'', label:'', comment:'', includeId:true, classCode:'' },
                  field:{ table:first || '', label:'', name:'', nameInput:'', nameManual:false, columnName:'', type:'string', nullable:true, primaryKey:false, unique:false, defaultValue:'', references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' } },
                  relation:{ sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                  classification: classificationForm
                }
              }
            }));
            
            UI.pushToast(ctx, { title:'تم إنشاء مخطط جديد', icon:'✨' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create new schema', error);
            UI.pushToast(ctx, { title:'تعذر إنشاء المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.library.select':{
        on:['click'],
        gkeys:['erd:library:select'],
        handler:async (e,ctx)=>{
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId || schemaId === state.data.schemaId) return;
          try{
            const record = await SchemaLibrary.get(schemaId);
            if(!record){
              UI.pushToast(ctx, { title:'تعذر تحميل المخطط', icon:'🛑' });
              return;
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            const classes = normaliseClasses(record.classes || []);
            const classificationForm = {
              rows: classes.map(item => ({ ...item })),
              bulkText: classes.length ? JSON.stringify(classes, null, 2) : ''
            };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: normaliseCanvas(record.canvas),
                library:{ ...(s.data.library || {}), items: list },
                classes
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                  classification: classificationForm,
                  table:{ ...(s.ui?.form?.table || {}), classCode:'' }
                }
              }
            }));
            
          } catch(error){
            console.warn('[Mishkah][ERD] failed to select schema', error);
            UI.pushToast(ctx, { title:'فشل تحميل المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.library.delete':{
        on:['click'],
        gkeys:['erd:library:delete'],
        handler:async (e,ctx)=>{
          e.preventDefault();
          e.stopPropagation();
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId) return;
          const count = state.data.library?.items?.length || 0;
          if(count <= 1){
            UI.pushToast(ctx, { title:'لا يمكن حذف آخر مخطط', icon:'⚠️' });
            return;
          }
          try{
            await SchemaLibrary.remove(schemaId);
            let list = await SchemaLibrary.list();
            if(!list.length){
              const blank = await SchemaLibrary.createBlank({ title:'مخطط جديد' });
              list = [blank];
            }
            let record = null;
            if(schemaId === state.data.schemaId){
              record = list[0];
            } else {
              record = await SchemaLibrary.get(state.data.schemaId) || list[0];
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            const classes = normaliseClasses(record.classes || []);
            const classificationForm = {
              rows: classes.map(item => ({ ...item })),
              bulkText: classes.length ? JSON.stringify(classes, null, 2) : ''
            };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: normaliseCanvas(record.canvas),
                library:{ ...(s.data.library || {}), items: list },
                classes
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                  classification: classificationForm,
                  table:{ ...(s.ui?.form?.table || {}), classCode:'' }
                }
              }
            }));
            
            UI.pushToast(ctx, { title:'تم حذف المخطط', icon:'🗑️' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to delete schema', error);
            UI.pushToast(ctx, { title:'تعذر حذف المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.schema.meta.open':{
        on:['click'],
        gkeys:['erd:schema:meta:open'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), schemaMeta:true },
              form:{ ...(s.ui?.form || {}), schemaMeta:{ ...(s.data.schemaMeta || {}) } }
            }
          }));
          
        }
      },
      'erd.schema.meta.save':{
        on:['click'],
        gkeys:['erd:schema:meta:save'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const form = s.ui?.form?.schemaMeta || {};
            const now = Date.now();
            const meta = {
              name: (form.name || s.data.schemaMeta?.name || '').trim() || `schema_${s.data.schemaId?.slice(-4) || 'new'}`,
              title: (form.title || form.name || s.data.schemaMeta?.title || '').trim() || 'مخطط جديد',
              description: (form.description || '').trim()
            };
            const record = {
              id: s.data.schemaId,
              name: meta.name,
              title: meta.title,
              description: meta.description,
              schema: s.data.schema,
              layout: s.data.layout,
              canvas: s.data.canvas,
              classes: s.data.classes || [],
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              head:{ ...(s.head || {}), title: meta.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaMeta: meta,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), schemaMeta:false },
                form:{ ...(s.ui?.form || {}), schemaMeta: meta }
              }
            };
            return next;
          });
          
          if(next) schedulePersist(recordFromState(next));
        }
      }
    };

    const app = M.app.createApp(erdState, {});
    erdAppInstance = app;
    const auto = U.twcss.auto(erdState, app, { pageScaffold:true });

    M.app.setBody(AppView);

    app.setOrders(Object.assign({}, UI.orders, auto.orders, erdOrders));
    app.mount('#app');
  })();
  </script>
</body>
</html>
