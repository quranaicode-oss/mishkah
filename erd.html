<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>مخطط قاعدة بيانات مشكاة</title>
  <style>
    :root { color-scheme: light dark; }
    html, body {
      height: 100%;
      min-height: 100vh;
      margin: 0;
      background: var(--background, #0f1115);
      color: var(--foreground, #f8fafc);
      font-family: "Tajawal", "Cairo", system-ui, sans-serif;
    }
    body { display: flex; min-height: 100vh; }
    #app { flex: 1 1 auto; display: flex; }
    textarea[readonly] { user-select: all; }
  </style>
  <script src="./mishkah-utils.js"></script>
  <script src="./mishkah.core.js"></script>
  <script src="./mishkah-ui.js"></script>
  <script src="./mishkah-schema.js"></script>
</head>
<body>
  <div id="app"></div>
  <script>
  (async function(){
    const M = Mishkah;
    const UI = M.UI;
    const U = M.utils;
    const D = M.DSL;
    const Schema = M.schema;
    const { tw } = U.twcss;

    const TABLE_WIDTH = 280;
    const HEADER_HEIGHT = 48;
    const ROW_HEIGHT = 28;

    const DEFAULT_FIELD_TYPES = [
      'string','integer','decimal','float','boolean','timestamp','date','json','uuid','text'
    ];

    const clone = (U.JSON && U.JSON.clone) ? U.JSON.clone : (obj => JSON.parse(JSON.stringify(obj)));

    const SchemaLibrary = (function(){
      const storeName = 'schemas';
      const AdapterClass = (U && (U.IndexedDBX || U.IndexedDB)) || null;
      const hasIndexedDB = typeof indexedDB !== 'undefined' && !!AdapterClass;
      const adapter = hasIndexedDB ? new AdapterClass({
        name:'mishkah-erd',
        version:1,
        schema:{
          stores:{
            [storeName]:{
              keyPath:'id',
              autoIncrement:false,
              indexes:{
                by_name:{ keyPath:'name', unique:true },
                by_updatedAt:{ keyPath:'updatedAt' },
                by_createdAt:{ keyPath:'createdAt' }
              }
            }
          }
        }
      }) : null;
      const memory = new Map();
      const status = hasIndexedDB ? 'indexeddb' : 'memory';

      function normalize(input, { bumpUpdatedAt=true }={}){
        const now = Date.now();
        const id = input.id || U.Id.uid('schema');
        const name = (input.name || '').trim() || `schema_${id.slice(-4)}`;
        const title = (input.title || '').trim() || name;
        const description = (input.description || '').trim();
        const schema = clone(input.schema || { tables: [] });
        const layout = clone(input.layout || {});
        const canvas = clone(input.canvas || { zoom:1 });
        const createdAt = input.createdAt || now;
        const updatedAt = bumpUpdatedAt ? now : (input.updatedAt || now);
        return { id, name, title, description, schema, layout, canvas, createdAt, updatedAt };
      }

      async function ready(){
        if(adapter && adapter.ensureSchema){
          try { await adapter.ensureSchema(); }
          catch(error){ console.warn('[Mishkah][ERD] failed to ensure schema store', error); }
        }
        return true;
      }

      async function save(input, opts={}){
        const record = normalize(input, opts);
        if(adapter){
          try { await adapter.put(storeName, record, record.id); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB save failed', error); }
        }
        memory.set(record.id, clone(record));
        return clone(record);
      }

      async function get(id){
        if(!id) return null;
        if(adapter){
          try {
            const row = await adapter.get(storeName, id);
            if(row){
              memory.set(row.id, clone(row));
              return clone(row);
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB get failed', error);
          }
        }
        const existing = memory.get(id);
        return existing ? clone(existing) : null;
      }

      async function list(){
        if(adapter){
          try {
            const rows = await adapter.getAll(storeName);
            if(Array.isArray(rows)){
              rows.forEach(row => memory.set(row.id, clone(row)));
            }
          } catch(error){
            console.warn('[Mishkah][ERD] IndexedDB list failed', error);
          }
        }
        const out = Array.from(memory.values()).map(item => clone(item));
        out.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
        return out;
      }

      async function remove(id){
        if(!id) return false;
        if(adapter){
          try { await adapter.delete(storeName, id); }
          catch(error){ console.warn('[Mishkah][ERD] IndexedDB delete failed', error); }
        }
        memory.delete(id);
        return true;
      }

      async function createBlank(meta={}){
        return save({
          id: meta.id,
          name: meta.name || '',
          title: meta.title || meta.name || 'مخطط جديد',
          description: meta.description || '',
          schema: new Schema.Registry().toJSON(),
          layout:{},
          canvas:{ zoom:1 },
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
      }

      return { status, available:true, ready, save, get, list, remove, createBlank };
    })();

    await SchemaLibrary.ready();

    let libraryItems = await SchemaLibrary.list();
    if(!libraryItems.length){
      const blankRecord = await SchemaLibrary.createBlank({ title:'مخطط جديد' });
      libraryItems = [blankRecord];
    }

    const activeRecord = libraryItems[0];
    const activeRegistry = Schema.Registry.fromJSON(activeRecord.schema || { tables: [] });

    function computeLayout(registry, layout){
      const map = Object.assign({}, layout || {});
      registry.list().forEach((table, index)=>{
        if(!map[table.name]){
          map[table.name] = table.layout || { x: 160 + index * 160, y: 120 + index * 80 };
        }
      });
      return map;
    }

    const initialLayout = computeLayout(activeRegistry, activeRecord.layout);
    const firstTable = activeRegistry.list()[0]?.name || null;
    const initialLayoutPoint = firstTable ? (initialLayout[firstTable] || { x:120, y:120 }) : { x:120, y:120 };

    const erdState = {
      head:{ title: activeRecord.title || 'مخطط قاعدة بيانات مشكاة' },
      env:{ theme:'dark', lang:'ar', dir:'rtl' },
      data:{
        schemaId: activeRecord.id,
        schemaMeta:{
          name: activeRecord.name,
          title: activeRecord.title,
          description: activeRecord.description || ''
        },
        schemaCreatedAt: activeRecord.createdAt,
        schemaUpdatedAt: activeRecord.updatedAt,
        schema: activeRegistry.toJSON(),
        layout: initialLayout,
        selection:{ table:firstTable, field:null },
        canvas: activeRecord.canvas || { zoom:1 },
        sqlPreview:'',
        error:null,
        library:{ items: libraryItems, status: SchemaLibrary.status }
      },
      ui:{
        modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false },
        form:{
          table:{ name:'', label:'', comment:'', includeId:true },
          field:{
            table:firstTable || '',
            name:'',
            columnName:'',
            type:'string',
            nullable:true,
            primaryKey:false,
            unique:false,
            defaultValue:'',
            references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
          },
          relation:{
            sourceTable:firstTable || '',
            sourceField:'',
            targetTable:'',
            targetField:'',
            onDelete:'CASCADE',
            onUpdate:'CASCADE'
          },
          import:{ name: activeRecord.name || '', title: activeRecord.title || '', targetId: activeRecord.id || '', text:'' },
          export:{ text:'' },
          sql:{ text:'' },
          layout:{ x: initialLayoutPoint.x, y: initialLayoutPoint.y },
          schemaMeta:{
            name: activeRecord.name || '',
            title: activeRecord.title || '',
            description: activeRecord.description || ''
          }
        }
      }
    };

    function getRegistry(db){
      try {
        return Schema.Registry.fromJSON(db.data.schema);
      } catch(error){
        console.warn('[Mishkah][ERD] schema parse failed', error);
        return new Schema.Registry();
      }
    }

    function ensureLayout(db, tableName){
      const layout = Object.assign({}, db.data.layout || {});
      if(!layout[tableName]) layout[tableName] = { x: 120, y: 120 };
      return layout;
    }

    function mergeLibraryItems(list, record){
      const items = Array.isArray(list) ? list.slice() : [];
      const entry = clone(record);
      const idx = items.findIndex(item => item.id === record.id);
      if(idx >= 0) items[idx] = entry; else items.push(entry);
      items.sort((a,b)=> (b.updatedAt || 0) - (a.updatedAt || 0));
      return items;
    }

    function fieldReferenceLabel(field){
      if(!field.references) return null;
      return `→ ${field.references.table}`;
    }

    const schedulePersist = (function(){
      if(!SchemaLibrary.available) return ()=>{};
      const debounced = U.Control.debounce(async (record)=>{
        try{
          await SchemaLibrary.save(record, { bumpUpdatedAt:false });
        } catch(error){
          console.warn('[Mishkah][ERD] persist failed', error);
        }
      }, 600);
      return record => debounced(clone(record));
    })();

    function recordFromState(state){
      const meta = state.data.schemaMeta || {};
      return {
        id: state.data.schemaId,
        name: meta.name || '',
        title: meta.title || '',
        description: meta.description || '',
        schema: state.data.schema,
        layout: state.data.layout,
        canvas: state.data.canvas,
        createdAt: state.data.schemaCreatedAt,
        updatedAt: state.data.schemaUpdatedAt
      };
    }

    function SchemaLibraryPanel(db){
      const library = db.data.library || {};
      const items = library.items || [];
      const activeId = db.data.schemaId;
      return D.Containers.Aside({ attrs:{ class: tw`hidden lg:flex w-72 flex-col border-l border-[var(--border)] bg-[var(--surface-2)]/70 backdrop-blur` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between px-4 py-3 border-b border-[var(--border)]` }}, [
          D.Text.Span({ attrs:{ class: tw`text-base font-semibold` }}, ['مكتبة المخططات']),
          D.Text.Span({ attrs:{ class: tw`text-[10px] uppercase tracking-wide text-[var(--muted)]` }}, [library.status === 'indexeddb' ? 'IndexedDB' : 'ذاكرة مؤقتة'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`px-4 py-3 flex flex-col gap-2` }}, [
          UI.Button({ attrs:{ gkey:'erd:library:new' }, variant:'solid', size:'sm' }, ['➕ مخطط جديد']),
          UI.Button({ attrs:{ gkey:'erd:import:open' }, variant:'ghost', size:'sm' }, ['⬆️ استيراد JSON'])
        ]),
        D.Containers.Div({ attrs:{ class: tw`flex-1 overflow-y-auto px-3 pb-4` }}, [
          items.length ? D.Lists.Ul({ attrs:{ class: tw`flex flex-col gap-2 list-none m-0 p-0` }},
            items.map(item=> D.Lists.Li({ attrs:{ class: tw`rounded-xl border border-[var(--border)]/60 bg-[var(--surface-1)]/70 px-3 py-2 transition ${item.id === activeId ? 'ring-2 ring-[var(--primary)]/60' : 'hover:border-[var(--primary)]/50'}`, gkey:'erd:library:select', 'data-schema-id': item.id } }, [
              D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between gap-2` }}, [
                D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-0.5` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-sm font-semibold` }}, [item.title || item.name]),
                  D.Text.Span({ attrs:{ class: tw`text-[11px] text-[var(--muted)]` }}, [item.name])
                ]),
                D.Containers.Div({ attrs:{ class: tw`flex items-center gap-1` }}, [
                  D.Text.Span({ attrs:{ class: tw`text-[10px] text-[var(--muted)]` }}, [U.Time.fmt(item.updatedAt || item.createdAt || Date.now())]),
                  UI.Button({ attrs:{ gkey:'erd:library:delete', 'data-schema-id': item.id, title:'حذف المخطط', class: tw`!px-2 !py-1` }, variant:'ghost', size:'xs' }, ['🗑️'])
                ])
              ])
            ])) : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['لم يتم حفظ أي مخططات بعد.'])
        ])
      ]);
    }

    function SchemaCanvas(db){
      const registry = getRegistry(db);
      const tables = registry.list();
      const zoom = db.data.canvas?.zoom || 1;
      return D.Containers.Div({ attrs:{ class: tw`relative flex-1 overflow-hidden bg-[var(--surface-1)]` }}, [
        D.Containers.Div({ attrs:{ class: tw`absolute inset-0`, style:`transform:scale(${zoom});transform-origin:top left;` }}, [
          RelationshipLayer(db, tables),
          ...tables.map(table=> TableCard(db, table))
        ])
      ]);
    }

    function Toolbar(db){
      const zoom = db.data.canvas?.zoom || 1;
      const metaTitle = db.data.schemaMeta?.title || 'مخطط بدون اسم';
      return UI.Toolbar({
        left:[
          D.Text.Span({ attrs:{ class: tw`text-xl font-bold` }}, [metaTitle]),
          UI.Button({ attrs:{ gkey:'erd:schema:meta:open' }, variant:'ghost', size:'sm' }, ['✏️ خصائص المخطط']),
          UI.Button({ attrs:{ gkey:'erd:table:add' }, variant:'ghost', size:'sm' }, ['➕ جدول']),
          UI.Button({ attrs:{ gkey:'erd:field:add' }, variant:'ghost', size:'sm' }, ['➕ حقل']),
          UI.Button({ attrs:{ gkey:'erd:relation:add' }, variant:'ghost', size:'sm' }, ['🔗 علاقة'])
        ],
        right:[
          UI.Button({ attrs:{ gkey:'erd:export:json' }, variant:'ghost', size:'sm' }, ['⬇️ تصدير JSON']),
          UI.Button({ attrs:{ gkey:'erd:export:sql' }, variant:'ghost', size:'sm' }, ['🧾 SQL']),
          UI.Button({ attrs:{ gkey:'erd:zoom:out', title:'تصغير' }, variant:'ghost', size:'sm' }, ['➖']),
          D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, [`${Math.round(zoom * 100)}%`]),
          UI.Button({ attrs:{ gkey:'erd:zoom:reset', title:'إعادة الحجم' }, variant:'ghost', size:'sm' }, ['⟳']),
          UI.Button({ attrs:{ gkey:'erd:zoom:in', title:'تكبير' }, variant:'ghost', size:'sm' }, ['➕'])
        ]
      });
    }

    function InspectorPanel(db){
      const selection = db.data.selection || {};
      const registry = getRegistry(db);
      const table = selection.table ? registry.get(selection.table) : null;
      const layout = db.data.layout || {};
      const formLayout = db.ui?.form?.layout || { x:0, y:0 };
      const relationships = table ? (table.fields || []).filter(field=> field.references) : [];
      return D.Containers.Aside({ attrs:{ class: tw`hidden xl:flex w-80 flex-col border-r border-[var(--border)] bg-[var(--surface-2)]/90 backdrop-blur p-4 gap-4` }}, [
        D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
          D.Text.H3({ attrs:{ class: tw`text-lg font-semibold` }}, ['خصائص المخطط']),
          UI.Button({ attrs:{ gkey:'erd:schema:meta:open', class: tw`justify-center` }, variant:'secondary', size:'sm' }, ['تحرير الاسم والوصف'])
        ]),
        D.Text.H3({ attrs:{ class: tw`text-lg font-semibold` }}, ['التفاصيل']),
        table ? D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
          D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, [`${table.sqlName || Schema.utils.toSnakeCase(table.name)}`]),
          D.Text.Span({ attrs:{ class: tw`text-sm` }}, [`عدد الحقول: ${table.fields.length}`]),
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-2` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['إحداثيات اللوحة']),
            UI.Input({ attrs:{ gkey:'erd:layout:input', 'data-axis':'x', value:String(formLayout.x), type:'number', class: tw`w-full`, placeholder:'المحور X' } }),
            UI.Input({ attrs:{ gkey:'erd:layout:input', 'data-axis':'y', value:String(formLayout.y), type:'number', class: tw`w-full`, placeholder:'المحور Y' } }),
            UI.Button({ attrs:{ gkey:'erd:layout:apply', variant:'solid', size:'sm' }}, ['تحديث الموقع'])
          ]),
          relationships.length ? D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-1` }}, [
            D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['العلاقات الخارجة']),
            ...relationships.map(field=> D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [`${field.name} → ${field.references.table}.${field.references.column}`]))
          ]) : D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, ['لا توجد علاقات محددة.'])
        ]) : D.Text.Span({ attrs:{ class: tw`text-sm text-[var(--muted)]` }}, ['اختر جدولًا من المخطط لاستعراض تفاصيله.'])
      ]);
    }

    function TableCard(db, table){
      const layout = db.data.layout || {};
      const pos = layout[table.name] || table.layout || { x:0, y:0 };
      const selected = db.data.selection?.table === table.name;
      const fields = table.fields || [];
      return D.Containers.Div({
        attrs:{
          class: tw`absolute rounded-2xl border border-[var(--border)] bg-[var(--surface-2)]/90 backdrop-blur shadow-lg p-4 transition ${selected ? 'ring-2 ring-[var(--primary)]' : ''}`,
          style:`transform:translate(${pos.x}px,${pos.y}px);width:${TABLE_WIDTH}px;`,
          gkey:'erd:table:select',
          'data-table-name': table.name
        }
      }, [
        D.Containers.Div({ attrs:{ class: tw`flex items-center justify-between mb-3` }}, [
          D.Text.H4({ attrs:{ class: tw`text-lg font-semibold` }}, [table.label || table.name]),
          D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [table.sqlName || Schema.utils.toSnakeCase(table.name)])
        ]),
        D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-1` }}, fields.map((field, idx)=> FieldRow(db, table, field, idx)))
      ]);
    }

    function FieldRow(db, table, field, index){
      const selected = db.data.selection?.table === table.name && db.data.selection?.field === field.name;
      return D.Containers.Div({
        attrs:{
          class: tw`flex items-center justify-between rounded-lg px-3 py-1 text-sm transition ${selected ? 'bg-[var(--primary)]/15 text-[var(--primary)]' : 'bg-[var(--surface-1)]/60 text-[var(--foreground)]/90'}`,
          style:`height:${ROW_HEIGHT}px;`,
          gkey:'erd:field:select',
          'data-table-name': table.name,
          'data-field-name': field.name
        }
      }, [
        D.Text.Span({ attrs:{ class: tw`font-medium` }}, [field.name]),
        D.Containers.Div({ attrs:{ class: tw`flex items-center gap-2` }}, [
          D.Text.Span({ attrs:{ class: tw`text-xs text-[var(--muted)]` }}, [field.type]),
          field.references ? D.Text.Span({ attrs:{ class: tw`text-[10px] px-2 py-0.5 rounded-full bg-[var(--primary)]/15 text-[var(--primary)]` }}, [fieldReferenceLabel(field)]) : null
        ])
      ]);
    }

    function RelationshipLayer(db, tables){
      const layout = db.data.layout || {};
      const registry = getRegistry(db);
      const paths = [];
      tables.forEach(table=>{
        const fields = table.fields || [];
        fields.forEach((field, idx)=>{
          if(!field.references) return;
          const target = registry.get(field.references.table);
          if(!target) return;
          const sourcePos = layout[table.name] || table.layout || { x:0, y:0 };
          const targetPos = layout[target.name] || target.layout || { x:0, y:0 };
          const targetIndex = target.fields.findIndex(col=> (col.columnName || Schema.utils.toSnakeCase(col.name)) === field.references.column || col.name === field.references.column);
          const startX = sourcePos.x + TABLE_WIDTH;
          const startY = sourcePos.y + HEADER_HEIGHT + idx * ROW_HEIGHT + ROW_HEIGHT / 2;
          const endX = targetPos.x;
          const endY = targetPos.y + HEADER_HEIGHT + (targetIndex >= 0 ? targetIndex : 0) * ROW_HEIGHT + ROW_HEIGHT / 2;
          paths.push(D.SVG.Path({ attrs:{ d:`M${startX},${startY} C${startX + 40},${startY} ${endX - 40},${endY} ${endX},${endY}`, stroke:'var(--primary)', 'stroke-width':1.5, fill:'none', 'marker-end':'url(#erd-arrow)' } }));
        });
      });
      return D.SVG.Svg({ attrs:{ class: tw`overflow-visible`, width:'2000', height:'1400' }}, [
        D.SVG.Defs({}, [
          D.SVG.Marker({ attrs:{ id:'erd-arrow', markerWidth:6, markerHeight:6, refX:6, refY:3, orient:'auto' }}, [
            D.SVG.Path({ attrs:{ d:'M0,0 L6,3 L0,6 Z', fill:'var(--primary)' } })
          ])
        ]),
        ...paths
      ]);
    }

    function ModalImport(db){
      const open = db.ui?.modals?.import;
      const form = db.ui?.form?.import || { name:'', title:'', targetId:'', text:'' };
      const library = db.data.library || {};
      const items = library.items || [];
      return UI.Modal({
        open,
        size:'lg',
        title:'استيراد مخطط JSON',
        description:'ألصق بيانات المخطط أو استبدل مخططًا موجودًا.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'name', value: form.name || '', placeholder:'المعرف الفريد للمخطط (name)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'title', value: form.title || '', placeholder:'العنوان المعروض' } }),
            UI.Select({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'targetId', value: form.targetId || '' }, options:[
              { value:'', label:'إنشاء مخطط جديد' },
              ...items.map(item=> ({ value:item.id, label:`استبدال: ${item.title || item.name}` }))
            ] }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'import', 'data-field':'text', value: form.text || '', rows:12, class: tw`w-full font-mono text-xs`, placeholder:'{"schema":{...}}' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:import:apply', variant:'solid', size:'sm' }}, ['استيراد وتخزين']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إغلاق'])
        ]
      });
    }

    function ModalExportJson(db){
      const open = db.ui?.modals?.exportJson;
      const text = db.ui?.form?.export?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'مخطط JSON',
        description:'انسخ المحتوى للاستخدام في أماكن أخرى.',
        closeGkey:'erd:modal:close',
        content:[
          UI.Textarea({ attrs:{ readonly:true, value: text, rows:14, class: tw`w-full font-mono text-xs` } })
        ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['تم']) ]
      });
    }

    function ModalExportSql(db){
      const open = db.ui?.modals?.exportSql;
      const text = db.ui?.form?.sql?.text || '';
      return UI.Modal({
        open,
        size:'lg',
        title:'نص SQL',
        description:'هذا النص يمثل أوامر إنشاء الجداول PostgreSQL.',
        closeGkey:'erd:modal:close',
        content:[ UI.Textarea({ attrs:{ readonly:true, value: text, rows:16, class: tw`w-full font-mono text-xs` } }) ],
        actions:[ UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['تم']) ]
      });
    }

    function ModalSchemaMeta(db){
      const open = db.ui?.modals?.schemaMeta;
      const form = db.ui?.form?.schemaMeta || { name:'', title:'', description:'' };
      return UI.Modal({
        open,
        size:'md',
        title:'خصائص المخطط',
        description:'قم بتحديث اسم التعريف والعنوان والوصف.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'name', value: form.name || '', placeholder:'Name (snake_case)' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'title', value: form.title || '', placeholder:'Title' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'schemaMeta', 'data-field':'description', value: form.description || '', rows:4, placeholder:'وصف مختصر للمخطط' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:schema:meta:save', variant:'solid', size:'sm' }}, ['حفظ التعديلات']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalAddTable(db){
      const open = db.ui?.modals?.table;
      const form = db.ui?.form?.table || { name:'', label:'', comment:'', includeId:true };
      return UI.Modal({
        open,
        size:'md',
        title:'إنشاء جدول جديد',
        description:'حدد اسم الجدول بالعربية أو الإنجليزية.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'name', value: form.name || '', placeholder:'اسم الجدول' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'label', value: form.label || '', placeholder:'العنوان المعروض' } }),
            UI.Textarea({ attrs:{ gkey:'erd:form:update', 'data-form':'table', 'data-field':'comment', value: form.comment || '', rows:3, placeholder:'ملاحظات' } }),
            UI.Label({ text:'إنشاء حقل id افتراضي؟' }),
            UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'table', 'data-field':'includeId', type:'checkbox', checked: form.includeId !== false } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:table:create', variant:'solid', size:'sm' }}, ['إنشاء']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalAddField(db){
      const open = db.ui?.modals?.field;
      const form = db.ui?.form?.field || {};
      return UI.Modal({
        open,
        size:'lg',
        title:'إضافة حقل',
        description:'حدد تفاصيل الحقل الجديد.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`grid grid-cols-1 md:grid-cols-2 gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'table', value: form.table || '', placeholder:'اسم الجدول' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'name', value: form.name || '', placeholder:'اسم الحقل' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'columnName', value: form.columnName || '', placeholder:'اسم العمود في SQL' } }),
            UI.Select({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'type', value: form.type || 'string' }, options: DEFAULT_FIELD_TYPES.map(type=> ({ value:type, label:type })) }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'field', 'data-field':'defaultValue', value: form.defaultValue || '', placeholder:'قيمة افتراضية' } }),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Nullable؟' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'nullable', type:'checkbox', checked: form.nullable !== false } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Primary Key؟' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'primaryKey', type:'checkbox', checked: !!form.primaryKey } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`flex items-center gap-3` }}, [
              UI.Label({ text:'Unique؟' }),
              UI.Input({ attrs:{ gkey:'erd:form:toggle', 'data-form':'field', 'data-field':'unique', type:'checkbox', checked: !!form.unique } })
            ]),
            D.Containers.Div({ attrs:{ class: tw`col-span-full flex flex-col gap-2` }}, [
              D.Text.Span({ attrs:{ class: tw`text-sm font-medium` }}, ['علاقة مرجعية اختيارية']),
              UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'fieldRef', 'data-field':'table', value: form.references?.table || '', placeholder:'الجدول الهدف' } }),
              UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'fieldRef', 'data-field':'column', value: form.references?.column || '', placeholder:'العمود الهدف' } }),
              UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'fieldRef', 'data-field':'onDelete', value: form.references?.onDelete || 'CASCADE', placeholder:'On Delete' } }),
              UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'fieldRef', 'data-field':'onUpdate', value: form.references?.onUpdate || 'CASCADE', placeholder:'On Update' } })
            ])
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:field:create', variant:'solid', size:'sm' }}, ['إضافة']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function ModalRelation(db){
      const open = db.ui?.modals?.relation;
      const form = db.ui?.form?.relation || {};
      return UI.Modal({
        open,
        size:'md',
        title:'إنشاء علاقة بين الجداول',
        description:'حدد الجدول المصدر والهدف وأسلوب التحديث.',
        closeGkey:'erd:modal:close',
        content:[
          D.Containers.Div({ attrs:{ class: tw`flex flex-col gap-3` }}, [
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceTable', value: form.sourceTable || '', placeholder:'الجدول المصدر' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'sourceField', value: form.sourceField || '', placeholder:'الحقل المصدر' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetTable', value: form.targetTable || '', placeholder:'الجدول الهدف' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'targetField', value: form.targetField || '', placeholder:'الحقل الهدف' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onDelete', value: form.onDelete || 'CASCADE', placeholder:'On Delete' } }),
            UI.Input({ attrs:{ gkey:'erd:form:update', 'data-form':'relation', 'data-field':'onUpdate', value: form.onUpdate || 'CASCADE', placeholder:'On Update' } })
          ])
        ],
        actions:[
          UI.Button({ attrs:{ gkey:'erd:relation:create', variant:'solid', size:'sm' }}, ['حفظ العلاقة']),
          UI.Button({ attrs:{ gkey:'erd:modal:close', variant:'ghost', size:'sm' }}, ['إلغاء'])
        ]
      });
    }

    function Modals(db){
      return [
        ModalImport(db),
        ModalExportJson(db),
        ModalExportSql(db),
        ModalSchemaMeta(db),
        ModalAddTable(db),
        ModalAddField(db),
        ModalRelation(db)
      ];
    }

    function AppView(db){
      return D.Containers.Div({ attrs:{ class: tw`flex h-screen w-full bg-[var(--surface-0)] text-[var(--foreground)]` }}, [
        SchemaLibraryPanel(db),
        D.Containers.Div({ attrs:{ class: tw`flex flex-1 flex-col` }}, [
          Toolbar(db),
          SchemaCanvas(db)
        ]),
        InspectorPanel(db),
        ...Modals(db)
      ]);
    }

    const erdOrders = {
      'erd.zoom.in':{
        on:['click'],
        gkeys:['erd:zoom:in'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.min(2, (s.data.canvas?.zoom || 1) + 0.1);
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas:{ zoom },
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas:{ zoom },
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.out':{
        on:['click'],
        gkeys:['erd:zoom:out'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const zoom = Math.max(0.2, (s.data.canvas?.zoom || 1) - 0.1);
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas:{ zoom },
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas:{ zoom },
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.zoom.reset':{
        on:['click'],
        gkeys:['erd:zoom:reset'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout: s.data.layout,
              canvas:{ zoom:1 },
              createdAt: s.data.schemaCreatedAt,
              updatedAt: s.data.schemaUpdatedAt
            };
            next = {
              ...s,
              data:{
                ...s.data,
                canvas:{ zoom:1 },
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.table.select':{
        on:['click'],
        gkeys:['erd:table:select'],
        handler:(e,ctx)=>{
          const card = e.target.closest('[data-table-name]');
          if(!card) return;
          const tableName = card.getAttribute('data-table-name');
          let next;
          ctx.setState(s=>{
            const layout = ensureLayout({ data:{ layout: s.data.layout } }, tableName);
            const tablePos = layout[tableName] || { x:120, y:120 };
            next = {
              ...s,
              data:{ ...s.data, selection:{ table: tableName, field:null }, layout },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table: tableName },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable: tableName },
                  layout:{ x: tablePos.x, y: tablePos.y }
                }
              }
            };
            return next;
          });
          ctx.rebuild();
        }
      },
      'erd.field.select':{
        on:['click'],
        gkeys:['erd:field:select'],
        handler:(e,ctx)=>{
          const row = e.target.closest('[data-field-name]');
          if(!row) return;
          const tableName = row.getAttribute('data-table-name');
          const fieldName = row.getAttribute('data-field-name');
          ctx.setState(s=>({
            ...s,
            data:{ ...s.data, selection:{ table: tableName, field: fieldName } },
            ui:{ ...(s.ui || {}), form:{ ...(s.ui?.form || {}), relation:{ ...(s.ui?.form?.relation || {}), sourceTable: tableName, sourceField: fieldName } } }
          }));
          ctx.rebuild();
        }
      },
      'erd.import.open':{
        on:['click'],
        gkeys:['erd:import:open'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), import:true },
              form:{ ...(s.ui?.form || {}), import:{ name: payload.name, title: payload.title, targetId: s.data.schemaId || '', text: JSON.stringify(payload, null, 2) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.export.json':{
        on:['click'],
        gkeys:['erd:export:json'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const payload = {
            name: state.data.schemaMeta?.name || '',
            title: state.data.schemaMeta?.title || '',
            description: state.data.schemaMeta?.description || '',
            schema: state.data.schema,
            layout: state.data.layout,
            canvas: state.data.canvas,
            createdAt: state.data.schemaCreatedAt,
            updatedAt: state.data.schemaUpdatedAt
          };
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), exportJson:true },
              form:{ ...(s.ui?.form || {}), export:{ text: JSON.stringify(payload, null, 2) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.export.sql':{
        on:['click'],
        gkeys:['erd:export:sql'],
        handler:(e,ctx)=>{
          const registry = getRegistry(ctx.getState());
          const sql = registry.generateSQL({ schemaName:'public' });
          ctx.setState(s=>({
            ...s,
            data:{ ...s.data, sqlPreview: sql },
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), exportSql:true },
              form:{ ...(s.ui?.form || {}), sql:{ text: sql } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.modal.close':{
        on:['click'],
        gkeys:['erd:modal:close','ui:modal:close'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ import:false, exportJson:false, exportSql:false, table:false, field:false, relation:false, schemaMeta:false } }
          }));
          ctx.rebuild();
        }
      },
      'erd.form.update':{
        on:['input','change'],
        gkeys:['erd:form:update'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          const parent = input.getAttribute('data-parent');
          if(!formKey) return;
          const value = input.value;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            if(formKey === 'fieldRef' || formKey === 'fieldRefColumn' || parent === 'field'){
              const current = currentForms.field || {};
              const nextRef = { ...(current.references || {}), [fieldKey]: value };
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, field:{ ...current, references: nextRef } } } };
            }
            if(fieldKey){
              const targetForm = currentForms[formKey] || {};
              return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: value } } } };
            }
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: value } } };
          });
          ctx.rebuild();
        }
      },
      'erd.form.toggle':{
        on:['change'],
        gkeys:['erd:form:toggle'],
        handler:(e,ctx)=>{
          const input = e.target;
          const formKey = input.getAttribute('data-form');
          const fieldKey = input.getAttribute('data-field');
          if(!formKey || !fieldKey) return;
          const checked = input.checked;
          ctx.setState(s=>{
            const currentForms = s.ui?.form || {};
            const targetForm = currentForms[formKey] || {};
            return { ...s, ui:{ ...(s.ui || {}), form:{ ...currentForms, [formKey]: { ...targetForm, [fieldKey]: checked } } } };
          });
          ctx.rebuild();
        }
      },
      'erd.table.add':{
        on:['click'],
        gkeys:['erd:table:add'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), table:true } }
          }));
          ctx.rebuild();
        }
      },
      'erd.table.create':{
        on:['click'],
        gkeys:['erd:table:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.table || {};
          const name = (form.name || '').trim();
          if(!name){
            UI.pushToast(ctx, { title:'يرجى تحديد اسم الجدول', icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          try{
            const tableConfig = {
              name,
              label: form.label || name,
              comment: form.comment || '',
              layout:{ x: 160 + registry.list().length * 120, y: 120 + registry.list().length * 60 },
              fields: []
            };
            if(form.includeId){
              tableConfig.fields.push({ name:'id', columnName:'id', type:'uuid', primaryKey:true, nullable:false });
            }
            registry.register(tableConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const layout = ensureLayout({ data:{ layout: s.data.layout } }, name);
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              next = {
                ...s,
                head:{ ...(s.head || {}), title: record.title || (s.head?.title || 'مخطط قاعدة بيانات مشكاة') },
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  layout,
                  selection:{ table:name, field:null },
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), table:false },
                  form:{
                    ...(s.ui?.form || {}),
                    table:{ name:'', label:'', comment:'', includeId:true },
                    field:{ ...(s.ui?.form?.field || {}), table: name },
                    layout:{ x: layout[name].x, y: layout[name].y }
                  }
                }
              };
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create table', error);
            UI.pushToast(ctx, { title:'فشل إنشاء الجدول', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.field.add':{
        on:['click'],
        gkeys:['erd:field:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const registry = getRegistry(state);
          const first = registry.list()[0]?.name || '';
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), field:true },
              form:{
                ...(s.ui?.form || {}),
                field:{
                  table: s.data.selection?.table || first,
                  name:'',
                  columnName:'',
                  type:'string',
                  nullable:true,
                  primaryKey:false,
                  unique:false,
                  defaultValue:'',
                  references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' }
                }
              }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.field.create':{
        on:['click'],
        gkeys:['erd:field:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.field || {};
          const tableName = (form.table || '').trim();
          const fieldName = (form.name || '').trim();
          if(!tableName || !fieldName){
            UI.pushToast(ctx, { title:'اسم الجدول والحقل مطلوبان', icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(tableName);
          if(!table){
            UI.pushToast(ctx, { title:'الجدول غير موجود', icon:'⚠️' });
            return;
          }
          try{
            const fieldConfig = {
              name: fieldName,
              columnName: (form.columnName || Schema.utils.toSnakeCase(fieldName)),
              type: form.type || 'string',
              nullable: form.nullable !== false,
              primaryKey: !!form.primaryKey,
              unique: !!form.unique
            };
            if(form.defaultValue){
              const val = form.defaultValue;
              if(['integer','number','decimal','float'].includes(fieldConfig.type)){
                const num = Number(val);
                if(!Number.isNaN(num)) fieldConfig.defaultValue = num;
              } else if(fieldConfig.type === 'boolean'){
                fieldConfig.defaultValue = ['true','1','yes','on'].includes(String(val).toLowerCase());
              } else {
                fieldConfig.defaultValue = val;
              }
            }
            if(form.references && form.references.table && form.references.column){
              fieldConfig.references = {
                table: form.references.table,
                column: form.references.column,
                onDelete: form.references.onDelete || 'CASCADE',
                onUpdate: form.references.onUpdate || 'CASCADE'
              };
            }
            table.addField(fieldConfig);
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              next = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  selection:{ table: tableName, field: fieldName },
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{
                  ...(s.ui || {}),
                  modals:{ ...(s.ui?.modals || {}), field:false },
                  form:{ ...(s.ui?.form || {}), field:{ ...form, name:'', columnName:'', defaultValue:'', primaryKey:false, unique:false } }
                }
              };
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to add field', error);
            UI.pushToast(ctx, { title:'فشل إضافة الحقل', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.relation.add':{
        on:['click'],
        gkeys:['erd:relation:add'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), relation:true },
              form:{ ...(s.ui?.form || {}), relation:{ sourceTable: selection.table || '', sourceField: selection.field || '', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.relation.create':{
        on:['click'],
        gkeys:['erd:relation:create'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.relation || {};
          if(!form.sourceTable || !form.sourceField || !form.targetTable || !form.targetField){
            UI.pushToast(ctx, { title:'الرجاء اختيار الحقول المصدر والهدف', icon:'⚠️' });
            return;
          }
          const registry = getRegistry(state);
          const table = registry.get(form.sourceTable);
          if(!table){
            UI.pushToast(ctx, { title:'الجدول المصدر غير موجود', icon:'⚠️' });
            return;
          }
          try{
            table.updateField(form.sourceField, {
              references:{
                table: form.targetTable,
                column: form.targetField,
                onDelete: form.onDelete || 'CASCADE',
                onUpdate: form.onUpdate || 'CASCADE'
              }
            });
            const schemaJSON = registry.toJSON();
            let next;
            ctx.setState(s=>{
              const now = Date.now();
              const record = {
                id: s.data.schemaId,
                name: s.data.schemaMeta?.name || '',
                title: s.data.schemaMeta?.title || '',
                description: s.data.schemaMeta?.description || '',
                schema: schemaJSON,
                layout: s.data.layout,
                canvas: s.data.canvas,
                createdAt: s.data.schemaCreatedAt,
                updatedAt: now
              };
              next = {
                ...s,
                data:{
                  ...s.data,
                  schema: schemaJSON,
                  schemaUpdatedAt: now,
                  library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
                },
                ui:{ ...(s.ui || {}), modals:{ ...(s.ui?.modals || {}), relation:false } }
              };
              return next;
            });
            ctx.rebuild();
            if(next) schedulePersist(recordFromState(next));
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create relation', error);
            UI.pushToast(ctx, { title:'فشل إنشاء العلاقة', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.import.apply':{
        on:['click'],
        gkeys:['erd:import:apply'],
        handler:async (e,ctx)=>{
          const state = ctx.getState();
          const form = state.ui?.form?.import || {};
          const raw = form.text || '';
          try{
            const parsed = JSON.parse(raw);
            const schemaPayload = parsed.schema && parsed.schema.tables ? parsed.schema : parsed;
            const registry = Schema.Registry.fromJSON(schemaPayload);
            const normalizedSchema = registry.toJSON();
            const layout = computeLayout(registry, parsed.layout);
            const targetId = form.targetId || '';
            let existing = null;
            if(targetId){ existing = await SchemaLibrary.get(targetId); }
            const now = Date.now();
            const recordInput = {
              id: targetId || undefined,
              name: form.name || parsed.name || schemaPayload.name || `schema_${now}`,
              title: form.title || parsed.title || form.name || `مخطط ${now}`,
              description: parsed.description || '',
              schema: normalizedSchema,
              layout,
              canvas: parsed.canvas || existing?.canvas || state.data.canvas,
              createdAt: existing?.createdAt,
              updatedAt: now
            };
            const saved = await SchemaLibrary.save(recordInput);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: saved.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: saved.id,
                schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' },
                schemaCreatedAt: saved.createdAt,
                schemaUpdatedAt: saved.updatedAt,
                schema: normalizedSchema,
                layout,
                selection:{ table:first, field:null },
                canvas: saved.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), import:false },
                form:{
                  ...(s.ui?.form || {}),
                  import:{ name:'', title:'', targetId:'', text:'' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  schemaMeta:{ name: saved.name, title: saved.title, description: saved.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'تم استيراد المخطط وتخزينه', icon:'✅' });
          } catch(error){
            console.warn('[Mishkah][ERD] import failed', error);
            UI.pushToast(ctx, { title:'تعذر استيراد JSON', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.layout.input':{
        on:['input','change'],
        gkeys:['erd:layout:input'],
        handler:(e,ctx)=>{
          const axis = e.target.getAttribute('data-axis');
          if(!axis) return;
          const value = Number(e.target.value);
          ctx.setState(s=>({
            ...s,
            ui:{ ...(s.ui || {}), form:{ ...(s.ui?.form || {}), layout:{ ...(s.ui?.form?.layout || {}), [axis]: Number.isFinite(value) ? value : 0 } } }
          }));
          ctx.rebuild();
        }
      },
      'erd.layout.apply':{
        on:['click'],
        gkeys:['erd:layout:apply'],
        handler:(e,ctx)=>{
          const state = ctx.getState();
          const selection = state.data.selection || {};
          if(!selection.table){
            UI.pushToast(ctx, { title:'اختر جدولاً لتحديث موقعه', icon:'⚠️' });
            return;
          }
          const formLayout = state.ui?.form?.layout || { x:120, y:120 };
          let next;
          ctx.setState(s=>{
            const layout = Object.assign({}, s.data.layout || {});
            layout[selection.table] = { x: Number(formLayout.x) || 0, y: Number(formLayout.y) || 0 };
            const now = Date.now();
            const record = {
              id: s.data.schemaId,
              name: s.data.schemaMeta?.name || '',
              title: s.data.schemaMeta?.title || '',
              description: s.data.schemaMeta?.description || '',
              schema: s.data.schema,
              layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              data:{
                ...s.data,
                layout,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      },
      'erd.library.new':{
        on:['click'],
        gkeys:['erd:library:new'],
        handler:async (e,ctx)=>{
          try{
            const record = await SchemaLibrary.createBlank({ title:'مخطط جديد' });
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: record.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  table:{ name:'', label:'', comment:'', includeId:true },
                  field:{ table:first || '', name:'', columnName:'', type:'string', nullable:true, primaryKey:false, unique:false, defaultValue:'', references:{ table:'', column:'', onDelete:'CASCADE', onUpdate:'CASCADE' } },
                  relation:{ sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'تم إنشاء مخطط جديد', icon:'✨' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to create new schema', error);
            UI.pushToast(ctx, { title:'تعذر إنشاء المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.library.select':{
        on:['click'],
        gkeys:['erd:library:select'],
        handler:async (e,ctx)=>{
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId || schemaId === state.data.schemaId) return;
          try{
            const record = await SchemaLibrary.get(schemaId);
            if(!record){
              UI.pushToast(ctx, { title:'تعذر تحميل المخطط', icon:'🛑' });
              return;
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const list = await SchemaLibrary.list();
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: record.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
          } catch(error){
            console.warn('[Mishkah][ERD] failed to select schema', error);
            UI.pushToast(ctx, { title:'فشل تحميل المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.library.delete':{
        on:['click'],
        gkeys:['erd:library:delete'],
        handler:async (e,ctx)=>{
          e.preventDefault();
          e.stopPropagation();
          const card = e.target.closest('[data-schema-id]');
          if(!card) return;
          const schemaId = card.getAttribute('data-schema-id');
          const state = ctx.getState();
          if(!schemaId) return;
          const count = state.data.library?.items?.length || 0;
          if(count <= 1){
            UI.pushToast(ctx, { title:'لا يمكن حذف آخر مخطط', icon:'⚠️' });
            return;
          }
          try{
            await SchemaLibrary.remove(schemaId);
            let list = await SchemaLibrary.list();
            if(!list.length){
              const blank = await SchemaLibrary.createBlank({ title:'مخطط جديد' });
              list = [blank];
            }
            let record = null;
            if(schemaId === state.data.schemaId){
              record = list[0];
            } else {
              record = await SchemaLibrary.get(state.data.schemaId) || list[0];
            }
            const registry = Schema.Registry.fromJSON(record.schema || { tables: [] });
            const layout = computeLayout(registry, record.layout);
            const first = registry.list()[0]?.name || null;
            const layoutPoint = first ? (layout[first] || { x:120, y:120 }) : { x:120, y:120 };
            ctx.setState(s=>({
              ...s,
              head:{ ...(s.head || {}), title: record.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaId: record.id,
                schemaMeta:{ name: record.name, title: record.title, description: record.description || '' },
                schemaCreatedAt: record.createdAt,
                schemaUpdatedAt: record.updatedAt,
                schema: registry.toJSON(),
                layout,
                selection:{ table:first, field:null },
                canvas: record.canvas || { zoom:1 },
                library:{ ...(s.data.library || {}), items: list }
              },
              ui:{
                ...(s.ui || {}),
                form:{
                  ...(s.ui?.form || {}),
                  field:{ ...(s.ui?.form?.field || {}), table:first || '' },
                  relation:{ ...(s.ui?.form?.relation || {}), sourceTable:first || '', sourceField:'', targetTable:'', targetField:'', onDelete:'CASCADE', onUpdate:'CASCADE' },
                  layout:{ x: layoutPoint.x, y: layoutPoint.y },
                  schemaMeta:{ name: record.name, title: record.title, description: record.description || '' }
                }
              }
            }));
            ctx.rebuild();
            UI.pushToast(ctx, { title:'تم حذف المخطط', icon:'🗑️' });
          } catch(error){
            console.warn('[Mishkah][ERD] failed to delete schema', error);
            UI.pushToast(ctx, { title:'تعذر حذف المخطط', message:String(error), icon:'🛑' });
          }
        }
      },
      'erd.schema.meta.open':{
        on:['click'],
        gkeys:['erd:schema:meta:open'],
        handler:(e,ctx)=>{
          ctx.setState(s=>({
            ...s,
            ui:{
              ...(s.ui || {}),
              modals:{ ...(s.ui?.modals || {}), schemaMeta:true },
              form:{ ...(s.ui?.form || {}), schemaMeta:{ ...(s.data.schemaMeta || {}) } }
            }
          }));
          ctx.rebuild();
        }
      },
      'erd.schema.meta.save':{
        on:['click'],
        gkeys:['erd:schema:meta:save'],
        handler:(e,ctx)=>{
          let next;
          ctx.setState(s=>{
            const form = s.ui?.form?.schemaMeta || {};
            const now = Date.now();
            const meta = {
              name: (form.name || s.data.schemaMeta?.name || '').trim() || `schema_${s.data.schemaId?.slice(-4) || 'new'}`,
              title: (form.title || form.name || s.data.schemaMeta?.title || '').trim() || 'مخطط جديد',
              description: (form.description || '').trim()
            };
            const record = {
              id: s.data.schemaId,
              name: meta.name,
              title: meta.title,
              description: meta.description,
              schema: s.data.schema,
              layout: s.data.layout,
              canvas: s.data.canvas,
              createdAt: s.data.schemaCreatedAt,
              updatedAt: now
            };
            next = {
              ...s,
              head:{ ...(s.head || {}), title: meta.title || 'مخطط قاعدة بيانات مشكاة' },
              data:{
                ...s.data,
                schemaMeta: meta,
                schemaUpdatedAt: now,
                library:{ ...(s.data.library || {}), items: mergeLibraryItems(s.data.library?.items || [], record) }
              },
              ui:{
                ...(s.ui || {}),
                modals:{ ...(s.ui?.modals || {}), schemaMeta:false },
                form:{ ...(s.ui?.form || {}), schemaMeta: meta }
              }
            };
            return next;
          });
          ctx.rebuild();
          if(next) schedulePersist(recordFromState(next));
        }
      }
    };

    const app = M.app.createApp(erdState, {});
    const auto = U.twcss.auto(erdState, app, { pageScaffold:true });

    M.Head.setBody(AppView);

    app.setOrders(Object.assign({}, UI.orders, auto.orders, erdOrders));
    app.mount('#app');
  })();
  </script>
</body>
</html>
